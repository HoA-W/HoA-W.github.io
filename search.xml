<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[会话技术--Cookie&Session]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie-Session%2F</url>
    <content type="text"><![CDATA[会话：一次会话中包含多次请求和响应。在一次会话中，浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止会话技术能够在一次会话的多次请求响应间共享数据 会话技术的实现方式 客户端会话技术：Cookie 服务器端会话技术：Session 客户端会话技术–CookieCookie使用步骤 创建Cookie对象，绑定数据:new Cookie(String name, String value) 发送Cookie对象::response.addCookie(Cookie cookie) 获取Cookie，拿到数据:Cookie[] request.getCookies() Cookie实现原理基于响应头set-cookie和请求头cookie实现 客户端和服务器第一次请求响应：服务器创建Cookie对象，并在set-cookie响应头将Cookie响应给浏览器 浏览器接收到服务器带有set-cookie头的响应后，将Cookie存储在浏览器中，当下一次浏览器向服务器发送请求时，会在请求头cookie头中附带这cookie 这样就实现了多次请求响应之间的数据共享 Cookie的细节 一次可以发送多个cookie：在服务器端创建多个Cookie对象，多次调用response的addCookie方法将多个Cookie对象发送，但是如果两个Cookie的值相同，那么后加入的Cookie值会覆盖前面的值 cookie在浏览器中保存时间 默认情况下，当浏览器关闭后，Cookie数据被销毁(服务器关闭，Cookie仍然存在，因为Cookie存储在浏览器中) 持久化存储：调用Cookie对象的setMaxAge(int seconds)方法实现 参数取值情况： 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值，即浏览器关闭后Cookie被销毁 零：删除cookie信息 cookie存储中文问题:在tomcat 8 之前 cookie中不能直接存储中文数据。但是在tomcat8之后，支持直接存储中文，但是对于一些特殊字符(如空格等)，仍不能直接存储，需要借助URL编码才行(具体步骤下一篇文章说到) cookie的共享 在一个tomcat服务器中部署了多个项目，在默认情况下，这些项目之间的Cookie是不能共享的但是可以通过Cookie对象的setPath(String path)方法来设置Cookie的共享范围 默认情况下，设置的是当前项目的虚拟目录 如果要在多个项目之间共享，则可以将path设置为"/"(“/”为服务器路径) 不同服务器之间Cookie的共享 setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 例如：设置path为".baidu.com"，那么tieba.baidu.com和news.baidu.com两个不同的服务器之间可以共享数据，因为它们的一级域名是.baidu.com Cookie的特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) Cookie存储的键值对都是String类型 作用 cookie一般用于存出少量的不太敏感的数据，这是因为Cookie的存储位置决定的，存储在客户端容易丢失和被篡改。 在不登录的情况下，完成服务器对客户端的身份识别 服务器端会话技术–SessionSession使用步骤 通过resquest获取Session对象：request.getSession() 调用Session对象的方法存储数据(和request请求转发方法一样) Object getAttribute(String name)：通过键获取值 void setAttribute(String name, Object value)：将数据存储进Session对象 void removeAttribute(String name)：通过键移除相应的键值对 Session实现原理Session的实现是依赖于Cookie的。 客户端第一次向服务器发送请求，服务器在服务器内部开辟一块内存空间，存放Session对象，并给该内存空间指定一个id 服务器在响应头set-cookie中设置JSESSIONID=id这个键值对发送给客户端 客户端接收到服务器的相应后，会将保存着Sessionid的Cookie对象保存在浏览器内存 当客户端下一次向服务器发送请求的时候，会带着Cookie一起(在请求头cookie中有JSESSIONID=id键值对) 服务器接收到请求后，得到JSESSIONID=id键值对的id后，会在内存中找到对应id的Session对象 这就是为什么说Session依赖于Cookie的原因以及多次请求响应之间共享数据的原理 Session细节 当客户端关闭后，服务器不关闭，两次获取session不是同一个：前面说到过，Session是依赖于Cookie的，Cookie在默认情况下当客户端浏览器关闭后是自动销毁的，因此Cookie中的键值对自然也就销毁了，所以两次获取的Session不是同一个，如果需要两次的Cookie是同一个 创建一个Cookie对象，设置cookie的键为JSESSIONID，值为session对象的id 设置cookie的存活时间 那么在cookie存活时间内，服务器通过cookie请求头拿到session的id都是一样的，这样通过id找到的Session对象自然也是同一个 客户端不关闭，服务器关闭后，两次获取的session不是同一个，因为服务器关闭后相应内存会被释放，Session自然也会被释放 但是一般我们需要获取到的Session对象是同一个，确保数据不丢失，tomcat会自动完成Session的钝化和活化 Session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上 Session的活化：在服务器启动后，将session文件转化为内存中的session对象。 Session被销毁 服务器关闭 session对象调用invalidate() 自杀 session默认失效时间 30分钟,可以tomcat服务器的web.xml配置文件中session-config设置所有项目的失效时间,也可以在项目的wen.xml配置文件单独配置项目的失效时间 Session的特点 用于一次会话的多次请求间共享数据，存储在服务器端 session可以存储任意类型，任意大小的数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>会话技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器中的四种路径]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在Web开发中，会很频繁的用到各种路径，路径又大致分为四种，分别是相对路径、绝对路径、虚拟路径、资源路径 # 相对路径 通过相对路径不能确定唯一资源 例如：./index.html ## 相对路径的使用规则 以"./"开头, 在使用时先确定当前资源和目标资源的之间的相对位置关系 如果两资源位于同一级目录：./+目标资源名称 ./可以不加，默认有./ 如果目标资源位于上一级目录：../+目标资源名称 如何确定当前资源和目标资源的关系 对于src目录下的资源，可以用request.getRequestURL()来得到该资源的位置src下的java资源的URI都是虚拟路径+资源名称无论该java文件位于src下的哪一级目录，只要在src目录里，都是这个形式。这里说的资源名称并不是实际的java类名，而是@WebServlet中的资源名称，服务器通过这个资源名称找到实际的类。 对于web目录下的资源，如果直接在web目录下，那么资源的URI就是虚拟路径+/文件名称如果在web目录下的其他目录，那么资源的URI就是虚拟路径+/目录名称+/文件名称，有几级目录写几级目录。 绝对路径通过绝对路径确定唯一资源例如：http://localhost/response/responseDemo2或者/response/responseDemo2协议名+ip地址+端口号+虚拟路径+文件资源 两种路径使用规则规则：判断要定义的路径是给谁用的，即判断请求将来从哪发出 给客户端浏览器使用 需要加虚拟目录(项目的访问路径,查看项目的xml配置文件) 例如：&lt;\a&gt;标签，&lt;\form&gt;，重定向等从浏览器发出，需要加虚拟路径 给服务器使用不需要加虚拟目录例如：请求转发就是服务器内部的资源跳转，不需要加虚拟路径，直接写资源名称就可以了 虚拟路径虚拟路径代表的是项目实际部署的位置，服务器通过虚拟路径能够映射到项目实际部署的位置通过查看项目的xml文件可以发现:&lt;\Context path=”虚拟路径” docBase=”资源在电脑上存储的位置” /&gt;这就是配置文件的内容，我们在浏览器输入的是Contextpath，也就是项目的虚拟路径，服务器就通过该虚拟目录映射到后面项目部署的真实目录 虚拟路径的好处 虚拟目录的名称通常要比物理目录的名称易记，因此更便于用户访问。 使用虚拟目录可以提高安全性，因为客户端并不知道文件在服务器上的实际物理位置，所以无法使用该信息来修改服务器中的目标文件。 使用虚拟目录可以更方便地移动网站中的目录，只需更改虚拟目录物理位置之间的映射，无需更改目录的URL。 使用虚拟目录可以发布多个目录下的内容，并可以单独控制每个虚拟目录的访问权限。 使用虚拟目录可以均衡Web服务器的负载，因为网站中资源来自于多个不同的服务器，从而避免单一服务器负载过重，响应缓慢。 资源路径资源路径也不是文件的真实路径，它和真是路径之间存在着映射关系，服务器可以通过资源路径找到文件link这篇文章提到了配置Servlet的方法，一种是通过web.xml来配置，通过这种方法很容易理解资源路径和文件路径的映射关系，服务器通过资源路径映射到实际文件，通过@WebServlet配置原理一样 我们在浏览器输入的是项目的URL是由协议名+ip地址+端口号+虚拟路径+文件资源组成，服务器会通过虚拟路径找到项目在电脑上部署的位置，通过文件资源路径找到文件在电脑上的实际位置]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ServletContext对象]]></title>
    <url>%2F2019%2F09%2F08%2FServletContext%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ServletContext对象，代表了整个web应用，可以和程序的容器(服务器)来通信 获取方式 通过request对象获取:request.getServletContext() 通过HttpServlet获取:this.getServletContext(); ServletContext对象的功能 获取MIME类型(文后将什么是MIME类型):String getMimeType(String file) 获取到数据的类型后，可以用于设置响应头content-type的值 获取方法：String getMimeType(String file)； 域对象：共享数据，前面说到，ServletContext代表了整个web应用，因此ServletContext对象中存放的数据整个web应用的资源都可以访问和修改 方法和request域对象的三个方法一样，只是两者的作用范围不同 动态的获取文件的真实(服务器)路径 方法：String getRealPath(String path) 文件直接位于web目录下时：context.getRealPath("/+文件名称"); 文件位于web目录下下的目录a中时：context.getRealPath("/a/+文件名称"); 文件直接位于src目录下时：context.getRealPath("/WEB-INF/classes+文件名称"); 以上可以通过查看tomcat项目的层次结构，以tomcat项目的web目录为基准 tomcat项目目录位于IDEA工作空间目录的\out\artifacts下 MIME类型MIME类型:在互联网通信过程中定义的一种文件数据类型MIME类型的格式：大类型/小类型&nbsp;&nbsp;&nbsp;&nbsp;例如：text/html、image/jpg getMimeType方法获取MIME类型的原理在web.xml配置文件中，tomcat定义了上千种MIME类型和文件后缀名的对应关系，而ServletContext又可以和服务器通信，所以ServletContext的getMimeType实际上是通过文件的后缀名来映射获取的文件的MIME类型。]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求转发和重定向]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[目前已经学习了两种资源跳转的方式：分别是request对象的请求转发和response的重定向，那么这两者各自有什么特点以及它们之间的区别是什么呢？ request请求转发一种在服务器内部的资源跳转方式举个例子：浏览器向服务器发出请求，服务器中的AServlet收到了请求，但是AServlet无法单独完成这个请求，如果要完成这个请求，还需要服务器内BServlet的参与，这时候就会用到请求转发，AServlet执行完自己能执行的部分后跳转到BServlet中继续执行，(这中间还涉及到了共享数据，文章后面会将) 请求转发的特点 浏览器地址栏路径不发生变化：就是说，浏览器请求访问AServlet，Aservlet执行完自己能执行的部分后跳转到BServlet，在这个过程中浏览器地址栏的路径还是AServlet的路径，并不会发生改变 只能转发到当前服务器内部资源中。 转发是一次请求：从上面的例子可以看出，整个转发的过程中，无论在服务器内部资源跳转多少次，浏览器只发出过一次请求，而服务请经过多次跳转处理完浏览器的请求后只会做出一次响应 共享数据上面说到了，AServlet和BServlet一起完成浏览器的请求，那么这两者之间必定是有数据交互的，因为AServlet要告诉BServlet自己做了哪些部分(修改了那些数据..)，并将这些部分共享给BServlet说共享数据之前，先说一个概念域对象：一个有作用范围的对象，可以在范围内共享数据request域：代表一次请求的范围，即在一个请求的范围内各个服务器资源可以共享数据。因为上面说到了请求转发这个过程是一次请求响应的过程，所以请求转发过程中的多个资源可以共享数据 存储数据，在当前资源中调用此方法(转发之前调用)void setAttribute(String name, Object o)参数：String name：给数据起一个名，在后面取出数据用到Object o：要共享的数据 在跳转后的资源调用此方法，可以达到共享数据的目的：Object getAttribute(String name) 参数：String name：存储数据时起的名 还有一个相关的方法：通过键来移除键值对void removeAttribute(String name) response重定向一种资源跳转的方式，不限于服务器内部，可以跳转到其他服务器资源(如跳转到百度) 重定向实现步骤 设置状态码为302(代表重定向) 设置响应头location：response.setHeader("location","目的资源的路径"); 以上是分步实现，其实一个方法就能够完成上述步骤 调用response的sendRedirect方法，方法中传递跳转资源的路径 response.sendRedirect("https://www.baidu.com"); 重定向的原理 浏览器向服务器发出请求，AServlet接收到了这个请求,AServlet表示无法处理服务器的这个请求，但AServlet却知道BServlet(可以是服务器内部的资源也可以是其他服务器的资源) 所以AServlet在在响应消息中干了两件事情 设置状态码为302，告诉服务器重定向 告诉浏览器BServlet的路径，(设置响应头location为BServlet的路径) 浏览器收到了AServlet的响应消息后，根据AServlet给出的location路径去访问BServlet 重定向的特点 地址栏发生变化：在资源跳转的过程中，浏览器地址栏会发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response输出中文乱码]]></title>
    <url>%2F2019%2F09%2F08%2Fresponse%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用response对象设置响应体时有两个步骤： 获取输出流(字节流或字符流) 使用输出流，将数据输出到客户端浏览器这时候如果传输的数据是中文，输出到浏览器就会乱码 乱码原因首先，要知道乱码的根本原因是什么，乱码的根本原因在于编码和解码使用的字符集不一样。那么在从服务器输出数据到客户端的过程中，有几次编码和解码过程？又分别是在哪里执行的？在输出数据的过程中，有一次编码，是tomcat执行的，它按照自己的字符集将数据编码后发送给客户端浏览器有一次解码，是浏览器执行的，浏览器将接收的数据按照自己的字符集解码后打印在屏幕上。而tomcat的默认编码是ISO-8859-1，浏览器的默认编码是操作系统的编码，也就是GBK，两者的编码格式不一样，就造成了中文乱码问题 解决方案解决方案不止一种，记录一种比较简单地使用response设置响应头的方法来设置 Content-Type 具体操作在获取输出流之前(一定是之前)设置响应头content-typeresponse.setHeader(“content-type”,”text/html;charset=utf-8”);这个方法不仅可以设置流的编码，还可以告诉浏览器发送数据的编码方式，并建议浏览器使用同样的字符集解码，这样就解决了乱码的问题由于只需要设置content-type这个响应头，所以有另一个方法更为简单response.setContentType(“text/html;charset=utf-8”);]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--request和response对象]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[首先要知道request对象和response对象是由服务器创建的，我们只是使用并不创建request对象是来获取请求消息，response对象是来设置响应消息 request对象request继承结构&nbsp;&nbsp;&nbsp;&nbsp;ServletRequest(接口)–&gt;HttpServletRequest(接口)–&gt;RequestFacade 类(tomcat实现) request功能获取请求消息数据 获取请求行数据:这是一个GET请求方式的请求行：GET /day14/demo1?name=zhangsan HTTP/1.1 获取请求方式 ：String getMethod() -->上例得到结果：GET 获取虚拟目录(常用)：String getContextPath() -->上例得到结果：/day14 获取Servlet路径: String getServletPath()-->上例得到结果：/demo1 获取get方式请求参数：String getQueryString()-->上例得到结果：name=zhangsan 获取请求URI(常用)(有两个方法) String getRequestURI()-->上例得到结果：/day14/demo1 StringBuffer getRequestURL()上例得到结果 :http://localhost/day14/demo1 获取协议及版本：String getProtocol()-->上例得到结果：HTTP/1.1 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据: 通过请求头的名称获取请求头的值(常用):String getHeader(String name) 获取所有的请求头名称:Enumeration getHeaderNames() 获取请求体数据:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 获取流对象 获取字符输入流，只能操作字符数据:BufferedReader getReader() 获取字节输入流，可以操作所有类型数据:ServletInputStream getInputStream() 其他功能因为对于不同的请求方式，它们的请求参数所在位置不同，GET方式请求参数在请求行中，POST方式请求参数封装在请求体中，所以服务器在获取请求参数的时候，需要分别在doGet和doPost方法中写不同的逻辑代码来获取请求参数，比较麻烦，因此就有一种通用的获取请求参数的方法 获取请求参数通用方式 根据参数名称获取参数值:String getParameter(String name) 根据参数名称获取参数值的数组(多选框):String[] getParameterValues(String name) 获取所有请求的参数名称:Enumeration getParameterNames() 获取所有参数的map集合:Map' 请求转发:一种在服务器内部的资源跳转方式 通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发:forward(ServletRequest re, ServletResponse res) 注意:path是要跳转的资源的路径， 获取ServletContext(后面博客会详细讲到): ServletContext getServletContext() request的请求转发和资源共享以及response的重定向，它们各自的特点和区别会新开一篇博客 response对象response功能:设置响应消息 设置响应行(设置状态码):setStatus(int sc) 设置响应头:setHeader(String name, String value) 设置响应体: 使用步骤 获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--请求响应模型]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Http–Hyper Text Transfer Protocol 超文本传输协议传输协议：定义了客户端和服务器端通信时，发送数据的格式 # Http协议的特点 基于TCP/IP的高级协议,默认端口是80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 Http协议的历史版本 1.0版本每次请求响应之后都会断开连接，下一次请求响应又会建立新的连接，即每次请求响应都会建立新的连接缺点：连接会被多次建立和多次丢弃掉，影响传输速度，消耗资源 1.1版本在一次请求响应之后，连接不会立刻断开，而是会等待一定的时间，如果在这一定时间内，还有其他请求，就会默认使用该连接，而不去建立新的连接，这样就实现了连接的复用 上面说了，Http定义了客户端和服务器通信时传输数据的格式，而传输数据分为两种： 客户端向服务器传输数据：请求消息数据 服务器向客户端传输数据：相应消息数据 Http请求消息数据格式 请求行:请求方式 请求url 请求协议/版本例如：GET /login.html HTTP/1.1请求url=虚拟路径+Servlet资源路径 请求头：客户端浏览器告诉服务器一些信息请求头消息以键值对的方式给出：请求头名称：请求头值常见的请求头： User-Agent：浏览器告诉服务器，使用的浏览器版本信息,可以在服务器端获取该头的信息，解决浏览器的兼容性问题(可以在服务器端对不同的服务器写不同的逻辑代码，然后根据该头的内容获取浏览器名称，执行对应浏览器的代码) Referer：告诉服务器，当前请求从哪里来？可以用来防盗链和统计工作 请求空行：一个空行，用于分割请求头和请求体 请求体(正文)：封装POST请求消息的请求参数 对于请求行中的请求方式，http协议7中请求方式，常用的有2种 GET:请求参数在请求行中，跟在url后。 请求的url长度有限制的 不太安全 POST: 请求参数在请求体中 请求的url长度没有限制的 相对安全 Http响应消息数据格式 响应行:协议/版本 响应状态码 状态码描述例如：HTTP/1.1 200 OK请求url=虚拟路径+Servlet资源路径 响应头：服务器告诉浏览器一些信息响应头消息以键值对的方式给出：响应头名称：响应头值常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据常见有两种取值 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体，用于文件下载 注意：这个filename是浏览器在弹出框显示，和服务器中要下载的文件名无关 响应空行：一个空行，用于分割响应头和响应体 响应体(正文)：传输的数据 响应状态码服务器告诉客户端浏览器本次请求和响应的一个状态。状态码都是3位数字 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：本次请求响应成功。代表码：200 4xx：客户端错误。 404:请求路径没有对应的资源-->路径错误 405:请求方式没有对应的doxxx方法-->比如浏览器请求方式是Post方式，而客户端没有doPost方法 5xx：服务器端错误。代表码：500(服务器内部出现异常)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FServlet%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Servlet：server applet官方给出的解释是运行在服务器端的小程序 # Servlet的本质 浏览器通过ip和端口来找到服务器，服务器中的资源分为两类 静态资源， 动态资源所谓动态资源，就是不同的用户访问到的页面是不一样的，这说明动态资源中肯定有一些逻辑性，来实现不同的用户访问同样的资源看到的是不一样的。而这些逻辑性，就要通过Java代码(Java类)来实现。 也就是说浏览器请求动态资源的时候，访问的就是服务器上的Java类 要注意的是：这里说的Java类没有main方法，不能自己运行，需要依赖服务器才能运行，相当于Tomcat(服务器软件)来执行它。那么问题来了，如果要Tomcat能够认识这个类并执行这个类，这个类就需要遵守一定的规则，在Java中，规则==接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说的规则，就是Servlet，它本质上就是一个接口，定义了Java类被tomcat识别的规则 Servlet的使用 创建JavaEE项目 在src目录内定义一个类，实现Servlet接口 实现接口中的抽象方法 配置Servlet(一共有两种方法，这里先记录第一种)在web.xml中配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;全类名(包名+类名)&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1(Servlet资源路径)&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在web.xml中加上以上内容 Servlet配置原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的url-pattern标签体内容。 如果有，则通过映射找到对应的servlet-class全类名 tomcat会将字节码文件加载进内存，并且创建其对象注意：这个实现了Servlet接口的类是由Tomcat通过反射创建的对象，并不是由程序员创建的 调用对象的方法 Servlet的生命周期 被创建：执行init()方法，该方法只执行一次 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么Servlet在什么时候被创建呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，在资源第一次被访问时，Servlet被创建 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在web.xml文件中配置改变Servlet被创建的时机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面说到的servlet标签下配置，具体下面有图 提供服务：执行service方法，可以执行多次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有服务器正常关闭时，才会执行destroy方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy方法在Servlet被销毁之前执行，一般用于释放资源 设置Servlet被创建的时机使用load-on-startup标签，这是一个围堵标签，当标签的值为负数的时候，默认第一次被访问时创建当标签的值为正数或0的时候，服务器启动时创建 注解配置Servlet在Servlet3.0以后，可以使用注解配置Servlet，相比较在web.xml文件中配置更加方便使用方法：在类上加注解@WebServlet(“资源路径”)，这样就可以通过注解的资源路径找到相应的类，直接将类加载进内存 Servlet体系结构 Servlet是一个接口，里面有5个抽象方法，每次继承Servlet接口的时候，都需要重写这5个抽象方法，而实际上，很多时候并用不到其中的有些方法，所以每次都要重写，很麻烦 Servlet的子类GenericServletGenericServlet也是一个抽象类，将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象，将来定义Servlet类时，可以继承GenericServlet，只实现service()方法即可(但实际上，这种方法使用较少) HttpServletHttpServlet出现原因HttpServlet extends GenericServlet该类是对Http协议的一种封装和描述对于一般的Servlet实现类，在service方法中通过一些操作获取浏览器的数据，但在获取数据之前，需要判断浏览器的请求方式是get方式还是put方式，因为两种方式封装数据的位置和格式是不一样的，对于不同的方式需要进行不同的逻辑处理。也就是说，我们需要在service方法里作两步操作： 判断浏览器请求方式 根据不同的请求方式编写不同的逻辑代码 HttpServlet实现原理这个过程比较麻烦，但却是所有的service方法都必须要做的一个过程，因此sun公司就提供了HttpServlet这个类。在HttpServlet类的Service方法中，已经写好了判断浏览器请求方式的逻辑代码，我们需要做的就是重写相应doxxx()方法，service方法判断请求方式后，会根据判断的结果调用我们重写的doxxx()方法以上是HttpServlet类service的源码，可以发现，HttpServlet中的service方法主要用于判断浏览器的请求方式，然后根据不同的请求方式调用相应的doxxx()方法，我们只需要重写这些方法，省略了判断请求方式的步骤]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Servlet类</tag>
        <tag>HttpServlet类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--SQL语句总结(一)]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这里主要总结两类SQL语句 DDL和DML，即操作数据库和表的语句以及对表中数据进行增删改操作的语句 DDL语句这类语句又分为两部分 操作数据库(CRUD) 操作表(CRUD) 操作数据库 (Create)创建： 1. 创建数据库：create database 数据库名称; 2. 先判断数据库是否存在，如果不存在，再创建：create database if not exists 数据库名称; 3. 创建数据库，并指定字符集：create database 数据库名称 character set 字符集名; 4. 创建db4数据库，判断是否存在，并指定字符集为gbk：create database if not exists db4 character set gbk; (Retrieve)查询： 1. 查询所有数据库名称：show databases; 2. 查询某个数据库的字符集:show create database 数据库名称; (Update)修改： 修改数据库的字符集:alter database 数据库名称 character set 字符集名称; (Delete)删除： 1. 删除数据库:drop database 数据库名称; 2. 判断数据库存在，存在再删除:drop database if exists 数据库名称; 使用数据库： 1. 查询当前正在使用的数据库名称:select database(); 2. 使用数据库:use 数据库名称; 操作表 (Create)创建： 1. 创建表：create table 表名( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名1 数据类型1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名2 数据类型2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名n 数据类型n); 注意：最后一列不加逗号 2. 复制表：create table 表名 like 被复制的表名; 数据库数据类型 int：整数类型 double:小数类型 date:日期，只包含年月日，形如yyyy-MM-dd datetime:日期，包含年月日时分秒, yyyy-MM-dd HH:mm:ss timestamp:时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串，在使用的时候需要指定长度，例如varchar(2)表示最大长度2个字符 (Retrieve)查询： 1. 查询某个数据库中所有的表名称:show tables; 2. 查询表结构:desc 表名; (Update)修改： 1. 修改表名:alter table 表名 rename to 新的表名; 2. alter table 表名 character set 字符集名称:alter table 表名 character set 字符集名称; 3. 添加一列:alter table 表名 add 列名 数据类型; 4. 修改列名称 类型:alter table 表名 modify 列名 新数据类型; (Delete)删除： 1. 判断数据库存在，存在再删除:drop table if exists 表名 ; 从上面这些语句不难总结得出，无论是数据库还是表，它们的增删改语句都和create、alter、drop、show有关 DML语句增删改表中的语句 添加数据insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n);列名和值要一一对应如果不指定列名，则默认给所有列添加值：insert into 表名 values(值1,值2,…值n);除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据delete from 表名 [where 条件]如果不加条件，则默认删除表中所有数据但是，如果要删除表中所有的话，不推荐使用这种方法，因为效率低推荐使用TRUNCATE TABLE 表名; 效率更高 先删除表，然后再创建一张一样的表。 修改数据update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件];注意：如果不加条件，则会将表中的记录全部修改 总结：DML语句用来操作表中的数据，主要对数据进行增删改操作，主要有insert 、delete、update三个关键字]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--数据库概念和SQL简介]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%92%8CSQL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[数据库(DataBase)，简称DB，用于存储和管理数据的仓库能够持久化存储数据，实际上，数据库就是一个文件系统，能够方便的存储和管理数据，使用了统一的方式来操作数据库，即SQL MySQL的配置MySQL服务启动 cmd--> services.msc 打开服务的窗口 使用管理员方式打开cmd net start mysql : 启动mysql的服务 net start mysql :关闭mysql的服务 MySQL登录 mysql -uroot -p密码 mysql -hip -uroot -p连接目标的密码 mysql –host=ip –user=root –password=连接目标的密码 MySQL退出 exit/quit命令 SQLStructured Query Language：结构化查询语言定义了操作所有关系型数据库的规则，但是不同的数据库操作的方式可能存在不同的地方，可以理解为‘方言’SQL分为四类 DL(Data Definition Language)数据定义语言用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 一张图来帮助理解四类SQL语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中创建多个Project]]></title>
    <url>%2F2019%2F09%2F08%2FIDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProject%2F</url>
    <content type="text"><![CDATA[我们知道，IDEA是没有workspace这个概念的，它是以Project为单位，一个窗口对应着一个Project，而一个Project对应着很多Model，Model相当于eclipse中的project，那么如何在一个项目中存放多个Project呢？ 首先，创建一个空的Project 给项目命名并点击finish会进入到新创建的Project窗口中，接着IDEA就会弹出下面界面，让你为新的Priject创建一个Model：在这里很重要，不选择给新的Project创建一个Model，直接点OK这样，常见出来的没有Model的Project就相当于一个空文件夹，(查看创建的Project文件夹，会发现它是没有src的) 在新的Projrect中，new一个Model我这里创建的时web项目，如果要创建普通的项目，点击左侧第一个按钮JAVA就可以给新创建的Model起名，通过这里就可以发现，第一个untitled是创建的project名(由于没有命名，默认就是untitled)，第二个是正在创建的Model名，点击finish这样就创建成功了一个，按照上面的方法再来一遍这样就成功地在一个窗口创建了两个Project 另外IDEA会为这两个web项目分别部署一份配置文件，这样这两个web项目就可以分别设置不同的端口，虚拟路径等配置运行项目的时候，查看控制台的log：Using CATALINA_BASE: 的值，就能找到配置文件的路径]]></content>
      <categories>
        <category>Utils</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat部署项目的方式]]></title>
    <url>%2F2019%2F09%2F08%2FTomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Tomcat有三种部署项目的方式将项目直接放到Tomcat的webapps目录下也可以将项目打包成war包，放到webapps目录下，运行时Tomcat会自动解压 利用Tomcat的配置文件sever.xm打开conf目录，找到sever.xml配置文件(先关闭Tomcat服务) 找到Host标签，加上一个Context标签，path值可以自己设置 启动Tomcat服务 在浏览器输入localhost:8080(端口号)/path的值/docBase的值就能正确访问项目 这种部署方式项目可以放在硬盘上的任意位置，Tomcat会通过path映射到docBase。 注意：因为server.xml是Tomcat服务核心的配置文件，是配置Tomcat整体的，在里面配置项目有可能损坏配置文件，导致出错，比较危险，所以一般不推荐使用 自定义xml配置文件(先**关闭Tomcat**) 打开Tomcat下的conf\Catalina\localhost这个目录，在localhost下创建一个xml配置文件， 文件名可以任意起(但是这个文件名就是浏览器搜索时的虚拟路径)，假设是aaa.xml； 在配置文件中：将上图中红框里的Context标签及内容写进去，把后面的path键值对删掉(因为虚拟路径已经指定为xml文件名，所以不需要再指定虚拟路径) 再次启动Tomcat 浏览器搜索**localhost:8080(端口号)/xml文件名/docBase的值**即可这种部署方式还有一个好处： 这是一种热部署的方式，如果不想要这个项目，可以将创建的xml文件删掉，或者后缀名改一下 例如：将aaa.xml改为aaa.xml_bak；无需重新启动Tomcat就能生效(浏览器就访问不到项目资源)]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动问题分析]]></title>
    <url>%2F2019%2F09%2F08%2Ftomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[问题前提在Tomcat目录下的bin目录中双击startup.bat直接打开tomcat时，可能会出现以下两个问题 Tomcat的窗口一闪而过 启动报错 Tomcat的窗口一闪而过原因没有正确配置JAVA_HOME环境变量在安装JDK时，需要将JDK的目录配置到Path变量下，问题就在这里，因为配置的时候，有可能是直接将JDK的目录配置到了Path环境变量双击Path变量，如下图所示这样的做法是错误的 正确的做法应该先创建一个JAVA_HOME环境变量将JAVA_HOME的值设置问JDK的路径，如下图然后再将JAVA_HOME代替JDK安装路径给Path变量将startup.bat关掉，重新启动即可 分析一下原因先以文档的形式打开startup.bat，发现和catolina.bat有关，我们就以文档形式打开bin目录下的catolina.bat在文档里可以看到，这里用到了环境变量的JAVA_HOME，所以在配置环境变量的时候，必须用JAVA_HOME来设置JDK路径，否则这里就无法找到JDK，由于Tomcat是纯java编写的，它的启动和运行要依赖与JDK，所以Tomcat就无法正常运行 启动报错，然后窗口自动关闭原因有可能是已经打开了一个Tomcat(或者有其他程序占用了Tomcat的端口号)，再次启动的时候由于端口被占用，所以无法正常启动如果是这种情况，通过查看日志会发现有一个异常：java.net.BindException:Address already in use 解决方法找到占用Tomcat端口号(一般是8080)的程序，关闭该程序1、打开cmd窗口，输入 netstat -ano命令找到Tomcat端口(我的是默认8080)，记录该端口程序的PID2、打开任务管理器找到刚记录的PID对应的程序，把它关掉。这样，Tomcat就能正确启动了]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>问题分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM模型基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FBOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[BOM，全称Browser Object Model，浏览器对象模型它将浏览器的各个组成部分封装成对象 五个对象window-窗口对象Location-地址栏对象History-历史记录对象Screen-显示器屏幕对象Navigator-浏览器对象 window-窗口对象该对象无需创建，可以直接使用对象的方法和属性 window对象的方法与弹出框有关的方法alert()显示带有一段消息和一个确认按钮的警告框。 confirm()显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法close()关闭浏览器窗口。 谁调用我 ，我关谁 open()打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式setTimeout()在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器clearTimeout()取消由 setTimeout() 方法设置的 timeout。setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()取消由 setInterval() 设置的 timeout。window对象的属性获取其他BOM对象historylocationNavigatorScreen获取DOM对象document Location-地址栏对象创建(获取)1. window.location 2. location方法reload() 重新加载当前文档。刷新 属性href 设置或返回完整的 URL。如图，给按钮设置监听器，点击按钮后修改页面的URL为百度页面，就会自动跳转到百度的页面 History-历史记录对象创建(获取)1. window.history 2. history方法back()加载 history 列表中的前一个 URL。 forward()加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性length返回当前窗口历史列表中的 URL 数量。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>BOM</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F09%2F08%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS和HTML结合方式内部样式在html文件内部定义一个script标签、在标签里面写的JS代码注意：和CSS不同的是，JS标签可以有很多个，而且可以写在HTML文件中的任意位置 外部样式在html文件内部定义一个script标签，通过script的src属性，来指定JS配置文件的路径 JS代码写在JS配置文件中 数据类型和变量JS数据类型和JAVA类似，分为**原始数据类型**和**引用数据类型**两大类数据类型number包括整数、小数和NaN类型(不是数字的数字类型 not a numebr) string字符/字符串类型 booleantrue/false、 null一个对象为空的占位符 undefined未定义，如果一个表量没有给初始化值，就会被默认赋值为 undefined ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828110402952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)变量一小块存储数据的内存空间 JAVA是强类型语言，而JavaScript是弱类型语言强类型在开辟内存空间时，定义了空间将来存储数据的类型，只能存储固定的类型 弱类型在开辟内存空间时，没有定义空间将来存储数据的类型，可以存放任意类型的数据 运算符在JS中，如果运算数不是运算符要求的类型，那么JS会自动将运算数进行类型转换 例如：一元运算符+(正号)和-(负号)是对数字类型进行操作，但是有+&apos;a&apos;这样的运算，就会将字符串类型的&apos;a&apos;转换为number类型其他类型转numberstring--&gt;number：**按照字面值转换**，如果字面值是数字，如&apos;123&apos;，会转换成数字123， 如果字面值不是数字，如&apos;abc&apos;，会转换为NaN(不是数字的数字)注意：NaN和整数小数运算，还是NaN; boolean–&gt;number: true=1 false=0 比较运算符字符串按照字典顺序比较(如c&gt;b),按位逐一比较，直到得出大小 **类型不同比较，先进行类型转换** ”===“运算符：在比较之前先进行类型判断，如果类型不同，直接返回false逻辑运算符！：非运算其他类型转boolean number--&gt;boolean：0和NaN为false，其他都是true string--&gt;boolean：除了空字符串，都是true null/undefined--&gt;boolean：false 对象--&gt;boolean：true 注意：在JS中，所有的**变量都是关键字var**定义的，var可以省略，但是，**用var定义的是局部变量**，不用var定义的 是全局变量常用对象function对象 方法对象 Array对象数组对象 数组长度可变 Date对象 Math对象该对象不用创建，可以直接使用对象的方法和属性，Math.调用 常用方法和属性： Global对象 特点：是一个全局对象，这个对象中封装的方法不需要对象就能够直接使用,和Math不同的是，使用它的方法前面不 用加对象名 在说该对象的方法之前先说一下**URL编码**： 浏览器将从表单中收集的数据经过URL编码后发送给服务器，服务器再将接收到的URL编码的数据解码。 URL编码的规则：对于汉字，先将汉字按照GBK/UTF8编码成对应的二进制数字，再将每四位二进制数字组合在 一起转换成十六进制数字，这样就将汉字转换成了一串十六进制数字，最后，每两个十六进制数字一组，在前面 +%，这样就组成了URL编码，字母和数字不编码第二组方法编码的字符更多，会将网址中./等符号也用URL编码]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器和常用属性]]></title>
    <url>%2F2019%2F09%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基础选择器id选择器使用此选择器要求HTML相应的标签必须指定了id属性 格式： #+标签id属性{ //对应id标签的属性 如color等}通过HTML标签的id来指定标签，修改样式 元素选择器格式：标签名称{ //通过标签名称找到标签(可能不止一个)并修改内容样式 }这个元素选择器会找到HTML中所有的div标签，并将标签内容字体改为红色 类选择器 格式： .+类名{ 通过标签的class属性值找到标签 }其中：三个选择器中 id选择器优先级最高，元素选择器优先级最低 扩展选择器![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828103900651.png) CSS常见属性 盒子模型 参见JAVA_WEB/HTML&amp;CSS]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础回顾]]></title>
    <url>%2F2019%2F09%2F08%2FHTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[HTML用于搭建基础页面，展示页面内容，一般和CSS以及JS搭配使用HTML标签分类# 1、围堵标签 顾名思义，就是开始和结束标签，例如&lt; html&gt; &lt; /html&gt;，内容放在标签中 # 2、自闭合标签 开始标签和结束标签在一起。例如换行标签&lt; br/&gt;、超链接标签&lt; a&gt;等 标签不区分大小写，建议小写无论是哪种标签，都可以在开始标签中定义属性，属性是由键值对组成，其中值需要由引(单/双)号引起来 &lt; html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt; /html&gt;文件标签&lt; html&gt;文档的根标签 &lt; head&gt;头标签，用于指定html文档的一些属性，引入外部资源，如CSS、JS文件等 &lt; title&gt; 标题标签 &lt; body&gt; 体标签，html代码写在body标签中 以上均为围堵标签 文本标签&lt; h1&gt;~&lt; h6&gt;标题标签，从h1到h6字体大小递减 –&gt;围堵标签 &lt; p&gt;段落标签：被该标签包裹的文本会换行两次 –&gt;围堵标签 &lt; br&gt;换行标签 &lt; hr&gt;展示一条水平线 该标签有一些属性：color、width、height、align(对齐方式)来设置水平线的样式 &lt; b&gt;字体加粗标签 &lt; i&gt;字体斜体标签以上四个均为自闭合标签 &lt; font&gt;字体标签 该标签属性：color、size、face(字体)来改变字体 center：文本居中标签 图片标签&lt; img&gt;图片标签，是一个自闭合标签，其中有src属性，可以指定展示图片的路径 相对路径： 其中如果html文件和图片所在文件夹目录是同一级目录，那么./+图片所在文件夹目录/图片 如果图片所在文件夹目录是html文件上一级目录，那么就用../ 列表标签&lt; ol&gt;/&lt; li&gt;有序列表 type属性：指定序号的样式 &lt; ul&gt;/&lt; li&gt;无序列表无序列表的type属性有三种： disc：原点 square：正方形点 circle：圆圈 链接标签&lt; a&gt;定义一个超链接 属性： href 指定访问资源的URL()统一资源定位符)，可以是网址 target 指定打开资源的方式，有两种方式 _ selt:在当前页面打开 _ blank：在新空白页面打开 和CSS以及JS搭配的标签 div标签和span标签，两者的区别是div自带换行，而span没有换行功能 表格标签&lt; table&gt; 定义表格，table的开始标签可以指定一些属性 width：表格宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt; tr&gt;标签定义行标签 &lt; td&gt;标签定义单元格标签 &lt; th&gt;标签定义表头单元格标签 表单标签注意：表单中的数据要想被提交，必须指定其name属性 表单：用于采集用户输入的数据，用于和服务器进行交互 &lt; form&gt;用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围form标签有以下属性 action：指定提交数据的URL路径 method：指定提交方式，有两种比较常用，分别是post和get form只是制定了收集用户数据的范围，并没有指定提交形式(输入框、按钮、下拉列表…)因此就会用到表单项标签表单项标签主要有三种：input标签、select标签、textarea标签 &lt; input&gt;标签展示效果 &lt; select&gt;标签子元素：option，指定列表项展示效果 文本域标签主要有两个属性：cols：指定列数，每一行有多少个字符rows：默认多少行。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--Byte类]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[学习过程中参考此篇文章，写的很好 1、观察它继承的父类，实现了那些接口 2、找到它的成员变量 3、学习构造方法 4、学习方法 一、父类和接口从图中可以知道，Byte类继承了Number类，实现了Comparable接口 对于Comparable接口，只有一个抽象方法这个接口赋予它和它的子类比较的能力，用于排序，比较大小对于一个存储自定义类的数组或集合，只有这个类实现了该接口，重写了接口中的compareTo()方法，重写了排序规则才能使用Arrays类的sort方法进行排序； 二、成员变量定义了Byte类型数据的边界值，就是说，Byte类型的值只能在-128~127之间TYPE是一个Byte的Class类对象，相当于TYPE=Byte.class；这就是Byte类型的基础类型，数据存储的地方(从下面的构造方法可以看出)这三个成员变量分别表示Byte数据的位数，字节数和UID(用于序列化和反序列化) 三、构造方法Byte的构造方法有两个，可以看出，两个构造方法都会将传入的数据存放到成员变量byte中 四、私有静态内部类![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171705760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70) 这是Byte类的一个静态内部类，类里面还有一个静态代码块 静态代码块会在类第一次被加载的时候执行，并且只执行一次 这里的作用就是，创建一个Byte类型的数组，数组的长度是256 里面存储着-128~127的数字(Byte类数据所有可能的取值) 并且数组是静态的并且final修饰， 因为后面的有些成员方法会需要用到Byte对象，所以这样做就避免了重复创建对象和回收对象五、成员方法1、toString(byte b)方法![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171318100.png) 注意：这个toString()方法不是重写Object的toString方法，因为它有参数 作用：将一个byte类型数据转化为String字符串类型 实质上是直接调用Integer类的toString方法， radix：10：用10进制表示2、valueOf(byte b)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172235507.png) 作用：将基本类型--&gt;包装类型，直接从上面的数组中得到3、parseByte(String s,int radix) 参数： String s:要解析的字符串 int radix:指定字符串表示的进制 例如：s=“10000”，radix=2，解析出来的值就是16 作用： 将字符串按照指定进制解析为byte类型 实质上调用的是Integer的parseInt方法，解析成int类型 判断是否超出范围，超出范围就抛异常，否则就返回 4、parseByte(String s)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172742458.png) 不指定进制默认十进制解析5、valueOf(String s,int radix) 参数： String s:要转换的字符串 int radix：字符串表示的进制，和解析方法一样作用： 将字符串转换为按照指定进制形式表示的Byte类型，先将字符串解析为byte类型，在调用valueOf()方法，从静态代码块初始的数组中找到对应的Byte并返回 6、valueOf(String s)默认10进制7、xxxValue()方法重写父类的方法，由于byte数值最小，不用担心出现溢出 直接用强制类型转换，然后return8、hashCode()重写了父类的hashCode方法，对于Byte类型，它的hashCode方法实质上就是返回它的值 9、equals()方法 重写了父类的equals方法 10、compareTo()方法 重写了接口中的compareTo方法，直接返回两个对象的差值 调用方法的对象-方法的参数]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>Byte</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流和字节流]]></title>
    <url>%2F2019%2F09%2F07%2FJAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[深入理解字符流编码 首先要理解字符流输入的原理：字符流输入其实底层也是字节流输入 字符–&gt;计算机二进制数字（字节）：编码字节(计算机二进制数字)–&gt;字符：解码 写入时：1、当使用字符流的write方法向文件写入数据的时候，数据会先写进内存缓冲区中， 2、内存缓冲区会先字符对比着系统码表编码(中文系统是GBK)为对应的字节：字符--&gt;数字 3、调用了flush方法或者是close方法后，内存缓冲区中编码为字节(数字)会写入到文件中读取时：使用read方法读取文件的时候，文建会先将存储在计算机中的二进制对照系统码表解码成相应的字符，读入程序图片不能用字符流的原因因为图片是字节文件，计算机中存储的也是字节数字，所以用字节流输入的时候不需要编码解码的过程，直接将计算机中的字节读取写入就可以了 但是用字符流读取的时候，一次读取两个字节，然后将这两个字节按照码表解码成相应的字符，当读取图片的时候，将两个字节拼在一起对比码表解码，码表中可能没有相应的字符，就会将此二进制数据标记为未知字符， 在写入的时候，会将未知字符丢掉，所以图片拷贝不成功 因为原图片和你拷贝的“图片”在计算机中的字节都是不一样的 拷贝的“图片”丢失了很多 **解码后**被标记为“未知字符”的**字节** 举个例子：一个图片在计算机中存储的字节是：-121，34，124，53，-65，-43，1.... 使用字节流读取的时候，一次读取一个字节，会原封不动的读取出来：-121，34，124，53，-65，-43，1.... 但是当使用字符流读取的时候，一次读两个字节-12134，12453....然后将每次读取到的两个字节对照系统码表解码成相应的字符，但是码表中可能没有相应的字符； 例如没有和-12134对应的字符，就会将此二进制数据标记为未知字符(假设标记为￥)； 在写入的时候，就会将￥字符给丢掉，所以**最后实际写入的数据为**124，53，-65，-43，1.... 这样拷贝自然就失败了关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接**最后**：字符流因为解码编码等原因，比字节流慢很多 字符流一般用于传输纯文本文件，尤其是中文文档，不能用于视频，图片等传输 图片等视频音频文件要用字节流]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>乱码</tag>
        <tag>字符流/字节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树镜像对称]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC101%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度–简单题目 分析： 通过题目可以知道，这个树镜像对称，那么这棵树关于根节点这条线对称 就是说，将它所有的左子树变成右子树，所有右子树变成左子树，它是不变的 递归//这里直接传递tree根节点的左右子树会比pre(TreeNode tree,TreeNode tree)好，因为减少一层递归，LeetCode速度直接 //快1ms，亲测 1、pre(TreeNode tree.left,TreeNode tree.right) 2、如果A.val==B.val --&gt;return true 3、如果A==null&amp;&amp;B==null --&gt;return true 4、如果A和B不同时为空，说明树是不对称的 --&gt;return false 5、遍历A的左子树和B的右子树 //pre(A.left,B.right) 6、遍历A的右子树和A的左子树 //pre(A.right,B.left)迭代法使用队列，比较容易理解，直接上代码(LeetCode官方题解)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC70%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度： 简单 1、动态规划可以知道，如果要到达第n阶台阶，有两种方式：第一：从n-1阶台阶跨1步第二：从n-2阶台阶跨2步设到达第n阶台阶的方法总数为sum(n)那么由上面可以知道：sum(n)=sum(n-2)+sum(n-1) 可以举例假设一下假设n等于3，那么到达第3阶台阶由两种方法1、从第1阶台阶跨2步上去2、从第2阶跨1步上去 相应的，到达第1阶台阶只有一种方法，sum(1)=1；到达第2阶台阶也有两种方法：从起始位置跨2步，和先跨1步再跨1步，sum(2)=2；所以sum(3)=3; 2、斐波那契数列通过观察规律可以知道：假设第0阶为1；那么可以得到从第1阶往后分别是：1，2，3，5，8，13…..这是一个很明显的斐波那契数列 3、递归同样的思路，爬第n阶台阶的方法和等于爬上第n-1阶台阶和爬上第n-2阶台阶方法之和递归出口：n=0的时候返回1，n&lt;0的时候返回0；运行到44个样例的时候栈爆了…..]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
