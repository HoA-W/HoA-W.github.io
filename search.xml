<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>相交链表</title>
      <link href="/2019/10/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/10/27/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百六十题</b><br>难度：<font color="green">简单</font><br>题目：编写一个程序，找到两个单链表相交的起始节点。</p><hr><a id="more"></a><p>如下面的两个链表：<br><img src="/2019/10/27/相交链表/1.png" alt><br>在节点 c1 开始相交。</p><p>示例 1：<br><img src="/2019/10/27/相交链表/2.png" alt><br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：<br><img src="/2019/10/27/相交链表/3.png" alt><br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：<br><img src="/2019/10/27/相交链表/4.png" alt><br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p><b>注意：</b><br>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>看到题第一时间，想到了哈希表来实现，利用哈希表存储一个链表的所有节点，然后遍历另一个链表，看是否有节点在哈希表中即可，但是空间复杂度较高，为O(m+n)。<br>其实有一种更为简单巧妙地方法</p><ol><li>设置两个指针pA和pB分别遍历A和B两链表，</li><li>如果pA遍历完了A链表，那就将pA指向B链表的头部继续遍历</li><li>同样的，pB遍历完B链表后，指向A链表的头部继续遍历</li><li>最后当pA和pB相等时，如果pA和pB为空，那么说明两链表不相交；反之，两链表相交。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">if(headA==null||headB==null)</span><br><span class="line">return null;</span><br><span class="line">ListNode pA=headA;</span><br><span class="line">ListNode pB=headB;</span><br><span class="line">while(pA!=pB)&#123;</span><br><span class="line">pA=(pA==null?headB:pA.next);</span><br><span class="line">pB=(pB==null?headA:pB.next);</span><br><span class="line">&#125;</span><br><span class="line">return pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，这个方法很是巧妙。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java I/O系统</title>
      <link href="/2019/10/27/%E6%B5%85%E8%B0%88Java-I-O%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/10/27/%E6%B5%85%E8%B0%88Java-I-O%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Java的I/O系统涉及了大量的类，本文只是简单的了解其中一些类的用法和分类，不涉及深层次的分析。</p><hr><a id="more"></a><h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>Java的I/O库系统也使用流这个概念，它代表任何有能力产出数据源对象或是有能力接收数据的接收端对象。“流”屏蔽了实际I/O设备中处理数据的细节。<br>Java类库中的I/O类分为输入和输出两部分，通过JDK可以查阅到，任何InputStream或Reader派生的子类都有read()方法，用于读取单个字节或者字节数组。同样的任何OutputStream或Writer派生的子类都有Write()方法，用于写单个字节或字节数组。</p><h2 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a><font size="5">InputStream类型</font></h2><p>InputStream的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p><ul><li>字节数组</li><li>文件</li><li>“管道”，工作方式与实际管道类似，即从一端输入，从另一端输出</li><li>一个由其他流组成的序列，以便我们可以将它们收集合并到一个流内</li><li>其他数据源，如网络等</li></ul><p>每一种数据源都有相应的InputStream子类。另外FilterInputStreamu也属于一种InputStream，为“装饰器”类提供基类。</p><h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a><font size="5">ByteArrayInputStream</font></h3><ul><li><b>构造方法</b><br>传递一个字节数组作为其缓冲区<br>ByteArrayInputStream(byte[] buf)<br>ByteArrayInputStream(byte[] buf, int offset, int length) </li><li><b>作用</b><br>将其缓冲区(构造参数的字节数组)作为数据源，从中读取数据进输入流。</li><li><b>常用方法</b><ul><li>int available()<br>在没有阻塞的情况下所能读取的字节数。对于文件来说，就是整个文件</li><li>void mark(int readAheadLimit)<br>设置流中的当前标记位置。 </li><li>void reset()<br>将缓冲区的位置重置为标记位置。和mark()搭配使用。</li><li>boolean markSupported()<br>测试此 InputStream 是否支持 mark/reset。 </li><li>long skip(long n)<br>从此输入流中跳过 n 个输入字节。 </li></ul></li></ul><p><b>测试代码</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">byte[] res = &quot;Hello ByteArrayInputStream&quot;.getBytes();</span><br><span class="line">//使用字节数组作为缓冲区</span><br><span class="line">ByteArrayInputStream bin = new ByteArrayInputStream(res);</span><br><span class="line">int count=0;</span><br><span class="line">//利用available()方法判断是否到数据源末尾</span><br><span class="line">while (bin.available() != 0) &#123;</span><br><span class="line">char ch = (char) bin.read();</span><br><span class="line">count++;</span><br><span class="line">//在空格字符后面做标记</span><br><span class="line">if(ch==&apos; &apos;)</span><br><span class="line">bin.mark(count+1);</span><br><span class="line">System.out.print(ch);</span><br><span class="line">//当第一次读到数据源末尾时将缓冲区位置重置到标记位置</span><br><span class="line">if (bin.available() == 0&amp;&amp;count&lt;res.length+1) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">bin.reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“===========================”</span><br><span class="line">Output：</span><br><span class="line">Hello ByteArrayInputStream</span><br><span class="line">ByteArrayInputStream</span><br></pre></td></tr></table></figure><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><font size="5">FileInputStream</font></h3><p>将文件作为其数据源，通过构造方法绑定一个文件。<br>方法和ByteArrayInputStream类似，比较常用也比较简单</p><h3 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a><font size="5">PipedInputStream</font></h3><p>产生用于写入相关PipedOutputStream的数据，实现管道化概念</p><ul><li><b>构造方法</b><ul><li>PipedInputStream()<br>创建尚未连接的 PipedInputStream。 </li><li>PipedInputStream(PipedOutputStream src)<br>创建 PipedInputStream，以使其连接到传送输出流 src。 </li></ul></li><li><b>作用</b><br>多用于多线程环境。数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。不建议对这两个对象尝试使用单个线程，因为这样可能会死锁该线程。传送输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。 </li><li><b>常用方法</b><ul><li>void connect(PipedOutputStream src)<br>使此传送输入流连接到传送输出流 src。如果使用无参构造方法创建了一个尚未连接的流，那么要先调用该方法和一个输出流连接</li><li>int available()<br>返回可以不受阻塞地从此输入流中读取的字节数量。 </li></ul></li></ul><p><b>测试代码</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//创建一个接收线程</span><br><span class="line">public class Receiver implements Runnable &#123;</span><br><span class="line">    public PipedInputStream in = new PipedInputStream();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">将管道中的数据读取出来</span><br><span class="line">            System.out.println(&quot;开始使用管道流&quot;);</span><br><span class="line">            System.out.println(new String(in.readAllBytes()));</span><br><span class="line">            System.out.println(&quot;数据接收完毕&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个发送线程</span><br><span class="line">public class Sender implements Runnable &#123;</span><br><span class="line">    public PipedOutputStream out = new PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String msg = &quot;Hello Receiver&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">//将数据写入到输出流中</span><br><span class="line">            out.write(msg.getBytes());</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主线程</span><br><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        Sender send=new Sender();</span><br><span class="line">        Receiver rece = new Receiver();</span><br><span class="line">        //连接管道</span><br><span class="line">        send.out.connect(rece.in);</span><br><span class="line">        //rece.in.connect(send);    两种方式效果都一样</span><br><span class="line">        //先启动发送线程</span><br><span class="line">        new Thread(send).start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        new Thread(rece).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=====================”</span><br><span class="line">Output：</span><br><span class="line">开始使用管道流</span><br><span class="line">Hello Receiver</span><br><span class="line">数据接收完毕</span><br></pre></td></tr></table></figure><p>在本例中，是由一个线程使用管道输出流将数据写入到流中，另一个线程使用管道输入流将数据从流中读取到内存。</p><h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a><font size="5">SequenceInputStream</font></h3><p>序列化流，将两个或多个InputStream对象传换成单一InputStream</p><ul><li><b>构造方法</b><br>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)<br>将多个输入流转换为单一输入流<br>SequenceInputStream(InputStream s1, InputStream s2)<br>将两个输入流转换为单一输入流</li><li><b>作用</b><br>表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。</li><li><b>常用方法</b><ul><li>int available()<br>返回当前流中可用的字节数。 </li></ul></li></ul><p><b>测试代码</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream bin1 = new ByteArrayInputStream(&quot;hello&quot;.getBytes());</span><br><span class="line">ByteArrayInputStream bin2 = new ByteArrayInputStream(&quot;SequenceInputStream&quot;.getBytes());</span><br><span class="line">//创建序列化流，将两个输入流转换成单一输入流</span><br><span class="line">SequenceInputStream in = new SequenceInputStream(bin1, bin2);</span><br><span class="line">int ch=0;</span><br><span class="line">//不能使用available()方法，否则只能读取第一个流的数据</span><br><span class="line">while ((ch = in.read()) != -1) &#123;</span><br><span class="line">System.out.print((char)ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=======================”</span><br><span class="line">Output：</span><br><span class="line">helloSequenceInputStream</span><br></pre></td></tr></table></figure><h2 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a><font size="5">OutputStream类型</font></h2><p>和InputStream类型对应的，也有几种输出流类型</p><h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a><font size="5">ByteArrayOutputStream</font></h3><ul><li><b>构造方法</b><br>ByteArrayOutputStream()<br>创建一个新的字节数组输出流。<br>ByteArrayOutputStream(int size)<br>创建一个新的字节数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 </li><li><b>作用</b><br>将数据写入到内部缓冲区中</li><li><b>常用方法</b><ul><li>String toString(String enc)<br>将缓冲区的内容转换为字符串，根据指定的字符编码将字节转换成字符 </li><li>byte[] toByteArray()<br>创建一个新分配的字节数组。 </li><li>String toString()<br>将缓冲区的内容转换为字符串，根据平台的默认字符编码将字节转换成字符。 </li></ul></li></ul><p><b>示例代码</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream bou = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">int read;</span><br><span class="line">//从将控制台输入的数据写入到缓冲区中</span><br><span class="line">while ((read=System.in.read())!=10)&#123;</span><br><span class="line">bou.write(read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将缓冲区数据转换为字符串输出</span><br><span class="line">System.out.println(bou.toString());</span><br><span class="line"></span><br><span class="line">“=================”</span><br><span class="line">Input：</span><br><span class="line">qwertyu</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line">qwertyu</span><br></pre></td></tr></table></figure><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><font size="5">FileOutputStream</font></h3><p>比较常用，和FileInputStream对应使用。</p><h3 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a><font size="5">PipedOutputStream</font></h3><p>和管道输入流搭配使用，示例代码见前面PipedInputStream流</p><h1 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h1><p>Jaav的I/O库需要多种不同功能的组合，这正是装饰器模式的理由所在。FilterInputStream和FilterOutputStream用于装饰InputStream和OutputStream字节流。它们分别继承自基类InputStream和OutputStream。</p><h2 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a><font size="5">通过FilterInputStream从InputStream读取数据</font></h2><p>FilterInputStream有不同的子类，能够提供不同的功能</p><h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a><font size="5">DataInputStream</font></h3><ul><li><b>构造方法</b><br>传递一个InputStream实现类对象</li><li><b>作用</b><br>和DataOutputStream搭配使用，允许应用程序以与机器无关方式从基础输入流中读取基本Java数据类型和String类型。与机器无关的方式也就是说在不同的机器上使用该流传递数据都是正确的。</li><li><b>常用方法</b><ul><li><b>readxxx()</b><br>readByte、readShort…一系列的read方法以相应的方式从流中读取数据。读取的方法要和写入的方法对应(如果使用writeBoolean()写入，那么就要用readBoolean()读取)</li><li><b>readUTF</b><br>读取字符串数据</li></ul></li></ul><p><font color="blue">当使用readByte()读取数据时，每一个字节都是有效的，不能使用返回值是否为-1来判断是否读取到文件末尾，可以使用处理异常的方法或者是available()方法</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream din = new DataInputStream(new ByteArrayInputStream(</span><br><span class="line">//这是自己写的一个类，read方法返回一个字符串，通过getBytes()得到byte数据传递给ByteArrayInputStream对象</span><br><span class="line">BufferedInputFile.read(&quot;.\\src\\eighteenth\\formattedmemoryinput\\FormattedMemoryInput.java&quot;).getBytes()));</span><br><span class="line">//当使用readByte()方法一次一个字节的读取字符，那么任何字节的值都是合法效果</span><br><span class="line">//此时方法的返回值不能用来检测输入是否结束。这是我们有两种方法</span><br><span class="line">//这是第一种，使用捕获异常的方式来进行流控制(不是很推荐)</span><br><span class="line">//        try &#123;</span><br><span class="line">//            while (true) &#123;</span><br><span class="line">//                System.out.println((char) din.readByte());</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (EOFException e) &#123;</span><br><span class="line">//            System.out.println(&quot;End of Stream&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//第二种方法，使用available()方法，该方法的字面意思就是</span><br><span class="line">//“在没有阻塞情况下所能读取的字节数</span><br><span class="line">while (din.available() != 0) &#123;</span><br><span class="line">System.out.println((char) din.readByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a><font size="5">BufferedInputStream</font></h3><ul><li><b>构造方法</b><br>传递一个InputStream子类对象。</li><li><b>作用</b><br>对字节输入流进行缓冲，防止每次读写时都得进行实际操作，能够很好的加快读写速度。</li><li><b>常用方法</b><br>基本上和InputStream提供的方法一样</li></ul><h2 id="通过FilterOutputStream从OutputStream读取数据"><a href="#通过FilterOutputStream从OutputStream读取数据" class="headerlink" title="通过FilterOutputStream从OutputStream读取数据"></a><font size="5">通过FilterOutputStream从OutputStream读取数据</font></h2><p>和FilterInputStream对应的，FilterOutputStream也有一些子类，用于提供不同的功能</p><h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a><font size="5">DataOutputStream</font></h3><ul><li><b>构造方法</b><br>传递一个OutputStream实现类对象</li><li><b>作用</b><br>和DataInputStream一起使用，将各种基本数据类型以及String类型格式化输出到流中，这样一来，任何机器上的任何DataInputStream都能够读取它们。</li><li><b>常用方法</b><ul><li><b>writexxx()</b><br>以不同的方式将数据格式化写入到流中，当使用DataInputStream读取这些数据时，要使用和写入对应的读取方法。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建DataOutputStream对象，传递缓冲字节流</span><br><span class="line">DataOutputStream out = new DataOutputStream(</span><br><span class="line">new BufferedOutputStream(</span><br><span class="line">new FileOutputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line">out.writeDouble(3.1415926535);</span><br><span class="line">out.writeUTF(&quot;That was Pi&quot;);</span><br><span class="line">out.writeDouble(1.41413);</span><br><span class="line">out.writeUTF(&quot;Square root of 2&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">//创建DataInputStream对象，传递缓冲字节流</span><br><span class="line">DataInputStream in = new DataInputStream(</span><br><span class="line">new BufferedInputStream(</span><br><span class="line">new FileInputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line"></span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">“===============”</span><br><span class="line">Output：</span><br><span class="line">3.1415926535</span><br><span class="line">That was Pi</span><br><span class="line">1.41413</span><br><span class="line">Square root of 2</span><br></pre></td></tr></table></figure><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><font size="5">PrintStream</font></h3><ul><li><b>构造方法</b><br>传递OutputStream子类对象或者直接传递文件对象或文件名</li><li><b>作用</b><br>用于产生格式化输出，PrintStream会捕获所有的IOException(因此必须使用checkError()自行测试错误状态，如果出现错误返回true)，PrintStream不能以平台无关的方式处理换行动作(PrintWriter可以)</li><li><b>常用方法</b><ul><li><b>println()</b><br>将数据输出到流中并换行</li><li><b>append()</b><br>向流中追加数据并返回该流</li></ul></li></ul><p>更多方法见API手册</p><h3 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a><font size="5">BufferedOutputStream</font></h3><ul><li><b>构造方法</b><br>传递一个OutputStream对象</li><li><b>作用</b><br>对OutputStream进行了修改，对数据流使用了缓冲技术，因此每次向流写入时，不必每次都进行实际的物理写动作，因此它的速度更快。一般在进行输出时，使用该流更多一些。</li></ul><h1 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h1><p>设计Reader和Writer继承层次结构主要是为了国际化，In/OutputStream只能处理8位字节流，并且不能很好的处理16位的Unicode字符。因此设计了Reader和Writer字符流<br>与InputStream以及OutputStream对应的，Reader和Writer也有相应的子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;========================================&quot;</span><br><span class="line">基类</span><br><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">文件流</span><br><span class="line">FileInputStreamFileReader</span><br><span class="line">FileOutputStreamFileWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">数组流</span><br><span class="line">ByteArrayInputStreamCharArrayReader</span><br><span class="line">ByteArrayOutputStreamCharArrayWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">管道流</span><br><span class="line">PipedInputStreamPipedReader</span><br><span class="line">PipedOutputStreamPipedWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">转换流：字节流通向字符流的桥梁</span><br><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">字符串流(字节流的已经废弃)</span><br><span class="line">StringReader</span><br><span class="line">StringWriter</span><br></pre></td></tr></table></figure><h1 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h1><p>对于InputStream和OutputStream来说，我们会使用FilterInputStream和FilterOutputStream装饰器的子类来对流添加一些功能。对于Reader和Writer，也会使用一些装饰器来改变流的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;========================================&quot;</span><br><span class="line">过滤器</span><br><span class="line">FilterInputStreamFilterReader</span><br><span class="line">FilterOutputStreamFilterWriter(抽象类，无子类)</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">缓冲流直接继承自Reader和Writer</span><br><span class="line">BufferedInputStreamBufferedReader</span><br><span class="line">BufferedOutputStreamBufferedWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">打印流直接继承自Reader和Writer</span><br><span class="line">PrintStreamPrintWriter(构造参数技能接收Writer对象也能接收OutputStream对象)</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">数据流</span><br><span class="line">DataInputStreamDataInputStream(当需要使用readLine()方法时应该使用BufferedReader)</span><br></pre></td></tr></table></figure><p>可以看出字符流装饰器的继承体系和字节流的有所不同(具体参考API类库)<br><font color="blue">有一点要注意：当我们需要使用readLine()方法时，一定不能使用DataInputStream，而应该使用BufferedReader。除了这一点，DataInputStream仍是首选。</font></p><h1 id="RandomAccessFle"><a href="#RandomAccessFle" class="headerlink" title="RandomAccessFle"></a>RandomAccessFle</h1><p>该流适用于由大小已知的记录组成的文件，我们可以使用seek()方法将记录从一处转移到另一处，然后读取和修改记录。<font color="blue">RandomAccessFile不是InputStream或者OutputStream继承层次体系结构中的一部分</font>。除了实现DataInput和DataOutput(DataInput/OutputStreamStream实现了这两个接口)之外，它和这两个继承层次结构没有任何关系。</p><ul><li><b>构造方法</b><br>RandomAccessFile(File file, String mode)<br>RandomAccessFile(String name, String mode)<br>传递文件对象或者文件路径名并指定模式(“r”随机读，”rw”既读由写)</li><li><b>作用</b><br>支持对随机存取文件的读取和写入</li><li><b>常用方法</b><ul><li><b>readxxx</b><br>以各种形式读取数据(类似于DataInputStream)</li><li><b>writexxx</b><br>以各种形式写入数据(类似于DataOutputStream)</li><li><b>read/writeUTF()</b><br>对字符串进行读写操作</li><li><b>seek()</b><br>将指针移到距离文件开头一定字节的偏移量，从此处开始读取数据<br>(更多方法参见API)</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 使用RandomAccessFile对象，该对象类似于组合了DataInputStream和DataOutputStream</span><br><span class="line"> * (因为它实现了DataOut和DataInput接口)</span><br><span class="line"> * 该对象的seek()方法能够移动到文件的某个字节处。</span><br><span class="line"> *</span><br><span class="line"> * 如下，因为double是8字节，因此使用seek方法，将指针移动到第5个double值并修改它</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class UsingRandomAccessFile &#123;</span><br><span class="line">    static String file = &quot;.\\src\\eighteenth\\usingrandomaccessfile\\UsingRandomAccessFile.dat&quot;;</span><br><span class="line">    static void display() throws IOException &#123;</span><br><span class="line">        RandomAccessFile rf = new RandomAccessFile(file, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            System.out.println(&quot;Value &quot; + i + &quot;: &quot; + rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        RandomAccessFile rf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            rf.writeDouble(i * 1.414);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(&quot;The end of the file&quot;);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        System.out.println(&quot;=================&quot;);</span><br><span class="line"></span><br><span class="line">        rf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">//调用seek()方法</span><br><span class="line">        rf.seek(5 * 8);</span><br><span class="line">        rf.writeDouble(47.0001);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">”=====================“</span><br><span class="line">Output：</span><br><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">Value 5: 7.069999999999999</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br><span class="line">=================</span><br><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">//使用seek()方法后指针移动到这里</span><br><span class="line">Value 5: 47.0001</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br></pre></td></tr></table></figure><h1 id="I-O的典型使用方式"><a href="#I-O的典型使用方式" class="headerlink" title="I/O的典型使用方式"></a>I/O的典型使用方式</h1><p>我们可以通过不同的方式组合I/O流，但是我们可能用到的组合不多，介绍几种典型的组合</p><h2 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a><font size="5">缓冲输入文件</font></h2><p>如果要打开一个文件用于<b>字符输入</b></p><ol><li>可以使用String或者File对象作为文件名的FileReader。</li><li>为了提高速度，我们可以使用缓冲，因此可以将FileReader对象作为参数传递给BufferedReader构造器，得到一个BufferedReader对象。</li><li>并且该对象提供一个readLine()方法，当读取到文件末尾时，返回null。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//该read()方法传递一个文件名，返回文件的字符串表示</span><br><span class="line">public static String read(String filename) throws IOException &#123;</span><br><span class="line">//创建缓冲字符输入流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(filename));</span><br><span class="line">String s;</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">//readLine()方法一次读取一行，但是不读取换行符，因此要自己加上&quot;\n&quot;</span><br><span class="line">while ((s = br.readLine()) != null) &#123;</span><br><span class="line">sb.append(s + &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a><font size="5">从内存输入</font></h2><p>下面的示例中，从上面说的read方法中读入文件返回的String结果被用来创建一个StringReader，然后调用read()每次读取一个字符，并将它发送到控制台。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存中读取数据，使用StringReader，构造参数传递一个字符串</span><br><span class="line"> * 使用StringReader对象的read方法从字符串中读取内容</span><br><span class="line"> */</span><br><span class="line">public class MemoryInput &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//BufferedInputFile.read()即为上面介绍的从文件读取数据返回String对象</span><br><span class="line">//利用String构造StringReader对象，从String中读取数据</span><br><span class="line">        StringReader sr = new StringReader(BufferedInputFile.read(&quot;.\\src\\eighteenth\\memoryinput\\MemoryInput.java&quot;));</span><br><span class="line">        int c;</span><br><span class="line">        while ((c = sr.read()) != -1) &#123;</span><br><span class="line">            System.out.println((char) c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="格式化内存输入"><a href="#格式化内存输入" class="headerlink" title="格式化内存输入"></a><font size="5">格式化内存输入</font></h2><p>要读取格式化数据，可以使用DataInputStream，这是一个面向字节的I/O类。因此我们要使用InputStream对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 格式化内存输入</span><br><span class="line"> * 要读取格式化数据，可以使用DataInputStream，它是一个字节流。</span><br><span class="line"> * 构造方法传递一个InputStream子类对象</span><br><span class="line"> * 这里传递的是ByteArrayInputStream对象</span><br><span class="line"> * 构造BytrArrayInputStream对象时传递一个字节数组，</span><br><span class="line"> * 该对象从字节数组中读取数据</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FormattedMemoryInput &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//同样的，BufferedInputFile.read()方法返回一个字符串</span><br><span class="line">        DataInputStream din = new DataInputStream(new ByteArrayInputStream(</span><br><span class="line">                BufferedInputFile.read(&quot;.\\src\\eighteenth\\formattedmemoryinput\\FormattedMemoryInput.java&quot;).getBytes()));</span><br><span class="line">//前面说过，DataInputStream的readByte()方法读取的每一个字节都是有效的</span><br><span class="line">//因此无法根据返回值来判断是否到达文件末尾，应该使用available()方法</span><br><span class="line">        while (din.available() != 0) &#123;</span><br><span class="line">            System.out.println((char) din.readByte());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a><font size="5">基本的文件输出</font></h2><p>FileWriter对象可以向文件写入数据。</p><ol><li>创建一个与指定文件绑定的FileWriter对象</li><li>为了将快速度，我们一般使用缓存，因此将该对象传递给BufferedWriter构造器，创建一个缓冲字符流对象</li><li>有时候为了提供格式化机制，还可以包装成PrintWriter。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static String filename = &quot;.\\src\\eighteenth\\basefileoutput\\BasicFileOutput.out&quot;;</span><br><span class="line">//创建缓冲字符流，传递一个Reader流对象，这里传递的是StringReader对象</span><br><span class="line">//创建StringReader对象时构造参数传递一个String，流从String中读取数据</span><br><span class="line">BufferedReader bin = new BufferedReader(new StringReader(</span><br><span class="line">BufferedInputFile.read(&quot;.\\src\\eighteenth\\basefileoutput\\BasicFileOutput.java&quot;)));</span><br><span class="line"></span><br><span class="line">//创建FilterWriter流对象，传递一个Writer流对象，向文件中写入数据</span><br><span class="line">PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));</span><br><span class="line">int linecount = 1;</span><br><span class="line">String s;</span><br><span class="line">//使用该方法像文件中写入数据时，每写入一行数据会自动写入一个换行符</span><br><span class="line">while ((s = bin.readLine()) != null) &#123;</span><br><span class="line">pw.println(linecount++ + &quot;: &quot; + s);</span><br><span class="line">&#125;</span><br><span class="line">pw.close();</span><br><span class="line">bin.close();</span><br></pre></td></tr></table></figure><h2 id="文件输出快捷方式"><a href="#文件输出快捷方式" class="headerlink" title="文件输出快捷方式"></a><font size="5">文件输出快捷方式</font></h2><p>在前面的示例中，为了使用带缓冲的PrintWriter，需要创建三各类来进行装饰，还有一种简单方法，直接给PrintWriter传递文件名或File对象，PrintWriter利用该构造器自己实现缓冲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bin = new BufferedReader(</span><br><span class="line">new StringReader(BufferedInputFile.read(srcfilename))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//直接传递文件名，船舰带缓存的打印流对象</span><br><span class="line">PrintWriter pou = new PrintWriter(desfilename);</span><br><span class="line">int linecount = 1;</span><br><span class="line">String res;</span><br><span class="line">while ((res = bin.readLine()) != null) &#123;</span><br><span class="line">pou.println(linecount++ + &quot;: &quot; + res);</span><br><span class="line">&#125;</span><br><span class="line">//使用完后关闭流</span><br><span class="line">pou.close();</span><br><span class="line">bin.close();</span><br><span class="line">System.out.println(BufferedInputFile.read(desfilename));</span><br></pre></td></tr></table></figure><h2 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a><font size="5">存储和恢复数据</font></h2><p>PrintWriter可以对数据进行格式化，以便我们阅读。但是为了输出可供另一个流恢复的数据，我们需要使用DataOutputStream写入数据，并用DataInputStream恢复数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建DataOutputStream对象，传递缓冲字节流</span><br><span class="line">DataOutputStream out = new DataOutputStream(</span><br><span class="line">new BufferedOutputStream(</span><br><span class="line">new FileOutputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line">out.writeDouble(3.1415926535);</span><br><span class="line">out.writeUTF(&quot;That was Pi&quot;);</span><br><span class="line">out.writeDouble(1.41413);</span><br><span class="line">out.writeUTF(&quot;Square root of 2&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">//创建DataInputStream对象，传递缓冲字节流</span><br><span class="line">DataInputStream in = new DataInputStream(</span><br><span class="line">new BufferedInputStream(</span><br><span class="line">new FileInputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line"></span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br></pre></td></tr></table></figure><p>使用这一对流，在一台机器上写入，无论在哪一台机器上读取写入的结果，都是准确的，因为它们以和机器无关的方式读写数据。</p><h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>按照标准I/O模型，Java提供了Syatem.in、System.out、System.err。</p><ol><li>System.out已经被事先包装成了PrintStream对象，可以进行格式化输出，将数据打印到控制台。</li><li>Systeam.err也是PrintStream对象</li><li>Syatem.in是一个未被包装过的未经加工的InputStream对象。</li></ol><p>这意味着我们可以直接使用前两个输出流，但是在使用System.in时必须对其进行包装。</p><h2 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a><font size="5">从标准输入中读取</font></h2><p>一般我们使用readLine()进行一行一行的读取，因此，我们将System.in包装成BufferedReader。由字节流转换为字符流，我们需要使用InputStreamReader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//利用System.in创建字符缓冲输入流对象</span><br><span class="line">BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line">//读取控制台输入的字符，并通过System.out回显到控制台中</span><br><span class="line">while ((s = stdin.readLine()) != null &amp;&amp; s.length() != 0) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=======================”</span><br><span class="line">Output：</span><br><span class="line">qwert</span><br><span class="line">qwert</span><br></pre></td></tr></table></figure><h2 id="将System-out转换为PrintWriter"><a href="#将System-out转换为PrintWriter" class="headerlink" title="将System.out转换为PrintWriter"></a><font size="5">将System.out转换为PrintWriter</font></h2><p>System.out是一个PrintStream，而PrintStream是一个OutputStream。PrintWriter有一个接收OutputStream对象的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用两个参数的构造器，并将第二个设置为true，一边开启自动刷新功能，否则会看不到输出</span><br><span class="line">PrintWriter pw = new PrintWriter(System.out, true);</span><br><span class="line">pw.println(&quot;hello,world&quot;);</span><br><span class="line">//如果采用一个参数的构造器，那么在之后要关闭流，才能将pw中的数据刷新到控制台</span><br><span class="line">//pw.close()</span><br></pre></td></tr></table></figure><h2 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a><font size="5">标准I/O重定向</font></h2><p>Java的System类提供了一些简单地静态方法，以支持我们对标准输入的、输出、错误I/O流进行重定向</p><ol><li>setIn(InputStream)</li><li>setOut(PrintStream)</li><li>setErr(PrintStream)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//保存控制台标准输出流的引用</span><br><span class="line">PrintStream console = System.out;</span><br><span class="line"></span><br><span class="line">//创建缓冲字节输入流</span><br><span class="line">BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;.\\src\\eighteenth\\redirecting\\Redirceting.java&quot;));</span><br><span class="line">//创建格式化流</span><br><span class="line">PrintStream out = new PrintStream(</span><br><span class="line">new BufferedOutputStream(</span><br><span class="line">new FileOutputStream(&quot;.\\src\\eighteenth\\redirecting\\test.out&quot;)));</span><br><span class="line"></span><br><span class="line">//经标准输入流重定向到Redirceting.java</span><br><span class="line">//将标准输出流重定向到test.out</span><br><span class="line">// 将错误流也重定向到test.out</span><br><span class="line">System.setIn(in);</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">//利用标准IO将一个文件的数据拷贝到另一个文件中</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line">while ((s = br.readLine()) != null) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">//关闭重定向的输出流</span><br><span class="line">out.close();</span><br><span class="line">//将标准输出流恢复到控制台</span><br><span class="line">System.setOut(console);</span><br></pre></td></tr></table></figure><p>I/O重定向操纵的是字节流，而不是字符流。</p><h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><p>见Java编程思想和API类库</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> I/O </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买股票的最佳时机</title>
      <link href="/2019/10/26/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2019/10/26/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百二十一、二十二题</b><br>难度：<font color="green">简单</font></p><hr><a id="more"></a><h1 id="第一百二十一题"><a href="#第一百二十一题" class="headerlink" title="第一百二十一题"></a>第一百二十一题</h1><p>题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>这道题用到了动态规划的思想，维护两个变量</p><ol><li>当前元素前的最小元素值minprice</li><li>当前利润res</li></ol><p>当遍历到当前节点时，判断当前元素值和minprice的差值是否大于当前利润，如果大于，更新利润。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public int maxProfit(int[] prices) &#123;</span><br><span class="line">     //首先考虑边界情况，当数组长度为0时</span><br><span class="line">     if(prices.length==0)&#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     //假设初始最小值是prices[0]</span><br><span class="line">     int minprice=prices[0];</span><br><span class="line">     //初始利润为0</span><br><span class="line">     int res=0;</span><br><span class="line">     for(int i=1;i&lt;prices.length;i++)&#123;</span><br><span class="line">//如果当前元素值小于最小值，更新最小值</span><br><span class="line">         if(minprice&gt;prices[i])</span><br><span class="line">             minprice=prices[i];</span><br><span class="line">//更新利润</span><br><span class="line">         else if(res&lt;prices[i]-minprice)</span><br><span class="line">             res=prices[i]-minprice;</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="第一百二十一题-1"><a href="#第一百二十一题-1" class="headerlink" title="第一百二十一题"></a>第一百二十一题</h1><p>题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h2 id="思想分析-1"><a href="#思想分析-1" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>这道题和前一道题不同，它可以多次买卖一只股票，要求所得利润的总和最大。这时候，我们应该想到使用贪心算法。<br>对于这道题，今天买，不管之后是否会赚的更多，只要明天能赚我就卖，这就是贪心。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">int res = 0;</span><br><span class="line">//记录差值</span><br><span class="line">int Dvalue = 0;</span><br><span class="line">for(int i = 0; i &lt; prices.length - 1; i++)&#123;</span><br><span class="line">Dvalue = prices[i+1] - prices[i];</span><br><span class="line">if (Dvalue &gt; 0)&#123;</span><br><span class="line">res += Dvalue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角问题</title>
      <link href="/2019/10/26/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/26/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百一十八、一十九题</b><br>难度：<font color="green">简单</font></p><hr><a id="more"></a><p><img src="/2019/10/26/杨辉三角问题/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.gif" alt>如图所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="第一百一十八题"><a href="#第一百一十八题" class="headerlink" title="第一百一十八题"></a>第一百一十八题</h1><p>题目(第一百一十八)：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>对于杨辉三角</p><ol><li>每一行的第一个元素和最后一个元素为1</li><li>剩下的每一个元素都是它上一行正对元素及其前一个元素之和，即有(i,j)=(i-1,j-1)+(i-1,j)。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(numRows);</span><br><span class="line"></span><br><span class="line">//先将数组里的空引用初始化</span><br><span class="line">for(int i=0;i&lt;numRows;i++)&#123;</span><br><span class="line">res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;numRows;i++)&#123;</span><br><span class="line"></span><br><span class="line">for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line"></span><br><span class="line">if(j==0||j==i)</span><br><span class="line">res.get(i).add(1);</span><br><span class="line">//(i,j)=(i-1,j-1)+(i-1,j);</span><br><span class="line">else</span><br><span class="line">res.get(i).add(res.get(i-1).get(j-1)+res.get(i-1).get(j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第一百一十九题"><a href="#第一百一十九题" class="headerlink" title="第一百一十九题"></a>第一百一十九题</h1><p>题目：给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行(行数从0开始)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><h2 id="思想分析-1"><a href="#思想分析-1" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>将每一行元素保存到集合中，求下一行元素时，利用集合中已有的元素求得当前行元素值，并存入集合中，覆盖上一行的元素。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; getRow(int rowIndex) &#123;</span><br><span class="line">List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();</span><br><span class="line">cur.add(1);</span><br><span class="line">for (int i = 0; i &lt; rowIndex; i++) &#123;</span><br><span class="line">for (int j = i; j &gt; 0; j--) &#123;</span><br><span class="line">cur.set(j, cur.get(j - 1) + cur.get(j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur.add(1);</span><br><span class="line">&#125;</span><br><span class="line">return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 杨辉三角 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径总和</title>
      <link href="/2019/10/25/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
      <url>/2019/10/25/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百一十二题</b><br>难度：<font color="green">简单</font><br>题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例: </span><br><span class="line">给定如下二叉树，以及目标和 sum = 22，</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>这道题思想比较简单，但是有两个点容易出错</p><ol><li>目标和是<font color="red">根节点到叶子节点的路径和</font>，一定是叶子节点。在递归的过程中如果到当前节点时路径和为sum，一定要判断当前节点是不是叶子节点</li><li>不能提前截断，如果遍历到当前节点时，路径和等于目标和，但是当前节点不是叶子节点，不要急着返回false，继续往下遍历。举个例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对于这样一颗二叉树，目标和为-1</span><br><span class="line">      1</span><br><span class="line">             / \</span><br><span class="line">            -2  8</span><br><span class="line">           /   / \</span><br><span class="line">          1   13  4</span><br><span class="line">         / \       \</span><br><span class="line">        -1  2       1</span><br><span class="line"></span><br><span class="line">当遍历到-2节点时，当前路径和为1-2=-1=sum，但是很明显，-2节点不是叶子节点，因此不能直接返回true</span><br><span class="line">但是也不能为了节省时间，直接返回false，因为从上面可以看到，继续往下遍历时，最终的路径和为1-2+1-1=-1=sum，仍然等于sum，因此返回true</span><br></pre></td></tr></table></figure></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">if(root==null)</span><br><span class="line">return false;</span><br><span class="line">sum-=root.val;</span><br><span class="line">if(sum==0&amp;&amp;root.left==null&amp;&amp;root.right==null)</span><br><span class="line">return true;</span><br><span class="line">//这里一定不能为了节省时间直接返回false</span><br><span class="line">// if(sum==0)</span><br><span class="line">//     return false;</span><br><span class="line">return hasPathSum(root.left,sum)||hasPathSum(root.right,sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最小深度</title>
      <link href="/2019/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百一十一题</b><br>难度：<font color="green">简单</font><br>题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。(叶子节点是指没有子节点的节点)</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最小深度  2.</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>前面做过了二叉树的最大深度题，这个会稍微难一点，对于当前节点，有三种情况</p><ol><li>当前节点为空<br>此时返回0</li><li>当前节点左右子树都不为空<br>此时说明当前节点是叶子节点，返回1</li><li><b>当前节点左子树或右子树有一个为空</b><br>此时，<font color="blue">当前节点的最小深度就是它不为空的子树的最小深度！！这点很重要</font></li><li>当前节点左右子树都不为空<br>当前节点的最小深度为它左右子树中较小的深度</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>有两种解法，一种是递归，一种类似于队列</p><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a><font size="5">递归解法</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int minDepth(TreeNode root) &#123;</span><br><span class="line">//如果为空，返回0</span><br><span class="line">if(root == null) return 0;</span><br><span class="line">//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span><br><span class="line">if(root.left == null &amp;&amp; root.right == null) return 1;</span><br><span class="line"></span><br><span class="line">//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span><br><span class="line">int m1 = minDepth(root.left);</span><br><span class="line">int m2 = minDepth(root.right);</span><br><span class="line"></span><br><span class="line">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span><br><span class="line">if(root.left == null || root.right == null) return m1 + m2 + 1;</span><br><span class="line"></span><br><span class="line">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span><br><span class="line">return Math.min(m1,m2) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的程序比较容易理解，最后测试时间1ms，内存消耗不太理想，为37.7M</p><h2 id="队列解法"><a href="#队列解法" class="headerlink" title="队列解法"></a><font size="5">队列解法</font></h2><p>将树节点和它的深度封装成一个类，当遇到叶子节点时，直接返回深度即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//将树节点和它的深度封装成一个类</span><br><span class="line">class Node&#123;</span><br><span class="line">    TreeNode t;</span><br><span class="line">    int deepth;</span><br><span class="line">    Node(TreeNode t,int deepth)&#123;</span><br><span class="line">        this.t=t;</span><br><span class="line">        this.deepth=deepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int minDepth(TreeNode root) &#123;</span><br><span class="line"> if(root == null) </span><br><span class="line"> return 0;</span><br><span class="line"> </span><br><span class="line">int deepth=1;</span><br><span class="line">//使用List集合模仿队列</span><br><span class="line">List&lt;Node&gt; list=new ArrayList();</span><br><span class="line">list.add(new Node(root,1));</span><br><span class="line"></span><br><span class="line">while(!list.isEmpty())&#123;</span><br><span class="line">Node DeepthNode=list.remove(0);</span><br><span class="line">TreeNode temp=DeepthNode.t;</span><br><span class="line">//如果当前节点为树节点，直接返回深度即可</span><br><span class="line">if(temp.left==null&amp;&amp;temp.right==null)&#123;</span><br><span class="line">return DeepthNode.deepth;</span><br><span class="line">&#125;</span><br><span class="line">//如果当前节点含有子节点，将子节点和当前节点深度+1封装后加入集合中。</span><br><span class="line">if(temp.left!=null)&#123;</span><br><span class="line">list.add(new Node(temp.left,DeepthNode.deepth+1));</span><br><span class="line">&#125;</span><br><span class="line">if(temp.right!=null)&#123;</span><br><span class="line">list.add(new Node(temp.right,DeepthNode.deepth+1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法算是宽度优先算法，按照层次遍历的方式，遍历每个节点并记录节点的深度，直到找到叶子节点为止。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断平衡二叉树</title>
      <link href="/2019/10/24/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/10/24/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百一十题</b><br>难度：<font color="green">简单</font><br>题目：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>这个题，和前面求二叉树最大深度有些相似，求出节点的左右子树高度，判断相差是否超过1，如果超过1，将标记设置为false。否则计算当前节点的深度，继续递归。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class BalancedBinaryTree &#123;</span><br><span class="line">    boolean res = true;</span><br><span class="line"></span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        helper(root);</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int helper(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">//左子树的高度</span><br><span class="line">        int left = helper(root.left) + 1;</span><br><span class="line">//右子树的高度</span><br><span class="line">        int right = helper(root.right) + 1;</span><br><span class="line">//在这里将res设置为false</span><br><span class="line">        if (Math.abs(right - left) &gt; 1) res = false;</span><br><span class="line">//当前节点的高度</span><br><span class="line">        return Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种实现方法较为巧妙，也贴一下吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">return downToTop(root)!=-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int downToTop(TreeNode t)&#123;</span><br><span class="line">if(t==null)</span><br><span class="line">return 0;</span><br><span class="line">//求左子树的高度</span><br><span class="line">int left=downToTop(t.left);</span><br><span class="line">//如果高度为-1，直接截断返回-1</span><br><span class="line">if(left==-1)</span><br><span class="line">return -1;</span><br><span class="line">//求右子树的高度</span><br><span class="line">int right=downToTop(t.right);</span><br><span class="line">//如果高度为-1，直接截断返回-1</span><br><span class="line">if(right==-1)</span><br><span class="line">return -1;</span><br><span class="line">//这里很是巧妙，如果左右子树高度相差超过2，说明该树已经不平衡了</span><br><span class="line">//将当前节点高度设为-1，否则说明当前节点仍然是平衡的，那就将当前节点</span><br><span class="line">//高度设为正常高度。</span><br><span class="line">return Math.abs(left-right)&lt;2?Math.max(left,right)+1:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法仔细想了想感觉很巧妙，很让人佩服。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组转AVL树</title>
      <link href="/2019/10/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%ACAVL%E6%A0%91/"/>
      <url>/2019/10/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%ACAVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百零八题</b><br>难度：<font color="green">简单</font><br>题目：将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树，本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例:</span><br><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>一开始看到这个题的时候，第一时间想到的是前面实现的一个AVL树，发现太麻烦了，每次插入一个数据要对节点进行平衡，而平衡又分为4种不同的情况….我的天，当时搞不懂为什么一个简单难度的题目会这么难。就想到可能是自己哪里思路有问题，一看解析才发现自己还是太年轻，居然完全没有利用(或者是忽略)有序数组这个性质。<br><font color="blue">对于一个查找树，它的中序遍历就是有序的，更近一步，对于一个AVL树，它的根节点总是位于两边子树节点的中间。</font>这就很明显了吧，对就是结合二分来实现就会变得异常简单。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>在代码的开始部分，老规矩，总是要检查参数的边界条件，这是最起码的保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">if(nums==null||nums.length==0)&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return toAVL(nums,0,nums.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode toAVL(int[] nums,int left,int right)&#123;</span><br><span class="line">if(left&gt;right)&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">int mid=(left+right)&gt;&gt;1;</span><br><span class="line">//将中间元素插入到根节点中。</span><br><span class="line">TreeNode t=new TreeNode(nums[mid]);</span><br><span class="line">t.left=toAVL(nums,left,mid-1);</span><br><span class="line">t.right=toAVL(nums,mid+1,right);</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有序数组转AVL树的实现到这里就结束了，发现自己还是需要多练习，太年轻了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树最大深度和层次遍历</title>
      <link href="/2019/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/2019/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百零四题/一百零七题</b><br>难度：<font color="green">简单</font><br>题目(一百零四)：给定一个二叉树，找出其最大深度，二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><hr><a id="more"></a><h1 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h1><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>对于一个二叉树中任意一个节点，它的最大深度等于它子树的最大深度+1。并且空节点的深度为0。也就是说，通过递归实现时，递归出口就是当节点为空时。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">return root==null?0:Math.max(maxDepth(root.left),maxDepth(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h1><p><b>题目(一百零七)：给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其自底向上的层次遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思想分析-1"><a href="#思想分析-1" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>可以使用List&lt; List&lt; Integer&gt;&gt;来实现，将相同层次的节点放到一个List集合中即可。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">int deepth=0;</span><br><span class="line">//得到的结果是自定向下的层次遍历</span><br><span class="line">levelOrderTree(root,res,deepth);</span><br><span class="line">//使用Collections工具类的reverse()方法</span><br><span class="line">//将List反转即得到自下而上的层次遍历</span><br><span class="line">Collections.reverse(res);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void levelOrderTree(TreeNode t,List&lt;List&lt;Integer&gt;&gt; list,int deepth)&#123;</span><br><span class="line">if(t!=null)&#123;</span><br><span class="line">if(deepth&gt;=list.size())&#123;</span><br><span class="line">list.add(deepth,new LinkedList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line">list.get(deepth).add(t.val);</span><br><span class="line">levelOrderTree(t.left,list,deepth+1);</span><br><span class="line">levelOrderTree(t.right,list,deepth+1);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相同的树和镜像树</title>
      <link href="/2019/10/23/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%E5%92%8C%E9%95%9C%E5%83%8F%E6%A0%91/"/>
      <url>/2019/10/23/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%E5%92%8C%E9%95%9C%E5%83%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第一百题/一百零一题</b><br>难度：<font color="green">简单</font><br>题目(一百)：给定两个二叉树，编写一个函数来检验它们是否相同，如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><hr><a id="more"></a><h1 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:      1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:     1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>对于树的问题，尤其是二叉树，几乎都可以用递归进行解决(换个角度也是锻炼了我们的递归能力)。对于递归，很重要的一方面就是要找到递归出口，否则容易栈溢出。<br>本题中，对于两个树的节点，有以下几种情况</p><ol><li>都为空，说明当前分支遍历结束并且相等，返回true</li><li>只有一个为空，那说明两棵树必定不相等，返回false</li><li>都不为空但是值不相等，同上，返回false</li><li>都不为空且值相等，说明到当前为止两树相等，继续往下遍历比较。<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">if(p==null&amp;&amp;q==null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else if(p==null||q==null)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else if(p.val!=q.val)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return isSameTree(p.right,q.right)&amp;&amp;isSameTree(p.left,q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><hr><h1 id="镜像树"><a href="#镜像树" class="headerlink" title="镜像树"></a>镜像树</h1><p><b>题目(一百零一)：给定一个二叉树，检查它是否是镜像对称的</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure><h2 id="思想分析-1"><a href="#思想分析-1" class="headerlink" title="思想分析"></a><font size="5">思想分析</font></h2><p>可以使用递归和迭代两种方法，如果使用递归，那么和上面的思路一摸一样，只不过细节稍微有改动。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">//边界条件</span><br><span class="line">if(root==null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return Judge(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean Judge(TreeNode p,TreeNode q)&#123;</span><br><span class="line">if(p==null&amp;&amp;q==null)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else if(p==null||q==null)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else if(p.val!=q.val)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">return Judge(p.left,q.right)&amp;&amp;Judge(p.right,q.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于递归问题，尤其是树的递归，可以将通过个例来推导(例如将两层二叉树带入方法进行测试)，由于递归的性质，如果层数比较小的各种个例能够满足，那么递归应该没有问题。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 镜像树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="/2019/10/23/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2019/10/23/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCoode第七十题</b><br>难度：<font color="green">简单</font><br>题目：假设你正在爬楼梯。需要 n (n为正整数)阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>对于这道题，理解了思想之后其实非常简单。假设现在你站在第x阶(1&lt;=x&lt;=n)台阶上，那么你用了多少种方法爬到这里呢？因为爬上第x阶台阶只有两种方法</p><ul><li>从第x-1阶台阶爬1个台阶上去</li><li>从第x-2个台阶爬2个台阶上去</li></ul><p>如果我们假设爬上x阶台阶用了f(x)种方法，那么f(x)=f(x-1)+f(x-2)。很明显了，这就是一个斐波那契数列。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">if(n==1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int f1=1;</span><br><span class="line">int f2=1;</span><br><span class="line">int sum=0;</span><br><span class="line">while(n--&gt;1)&#123;</span><br><span class="line">sum=f1+f2;</span><br><span class="line">f1=f2;</span><br><span class="line">f2=sum;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种题目，理解了以后就会很简单，否则很有可能会将问题复杂化。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X的平方根</title>
      <link href="/2019/10/23/X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2019/10/23/X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第六十九题</b><br>难度：<font color="green">简单</font><br>题目：实现 int sqrt(int x) 函数，计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>又是一道二分算法的题，对于递归实现的二分算法，总是容易陷入死循环最后导致栈溢出。今天做了这个题，有一点二分算法的心得。<br>二分算法，不管是左边二分还是右边二分，每一次二分后都要向递归出口逼近。根据题意，确定递归出口返回的值。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">if(x==0||x==1)</span><br><span class="line">return x;</span><br><span class="line">return getRes(1,x,x);</span><br><span class="line">&#125;</span><br><span class="line">public int getRes(int left,int right,int n)&#123;</span><br><span class="line">if(left&gt;right)&#123;</span><br><span class="line">return left-1;</span><br><span class="line">&#125;</span><br><span class="line">int mid=(right+left)/2;</span><br><span class="line">//左递归</span><br><span class="line">if(mid&gt;n/mid)</span><br><span class="line">return getRes(left,mid-1,n);</span><br><span class="line">//右递归</span><br><span class="line">else</span><br><span class="line">return getRes(mid+1,right,n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题不用递归也可以实现，但是为了熟悉，还是用了递归。主要的难点在于递归出口为什么是left&gt;right以及返回值为什么是left-1。<br>当递归过程中left==right时，只有三种情况。</p><ul><li>left* left==right*right==x<br>向右递归，递归后，left&gt;right。并且left=left+1。因此最后返回left-1</li><li>left* left==right*right&lt;x<br>向右递归，递归后，left&gt;right。并且left=left+1。因此最后返回left-1</li><li>left* left==right*right&gt;x<br>向左递归，递归后，left&gt;right。并且right=right-1。因此最后返回left-1<br>从两段向左向右递归的代码中可以发现，left最后的值一定是sqrt(x)+1。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报数</title>
      <link href="/2019/10/22/%E6%8A%A5%E6%95%B0/"/>
      <url>/2019/10/22/%E6%8A%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第三十八题</b><br>难度：<font color="green">简单</font><br>题目：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line"></span><br><span class="line">1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。</span><br><span class="line">11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。</span><br><span class="line">21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</span><br><span class="line">给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</span><br><span class="line">注意：整数顺序将表示为一个字符串。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>题目说的很清楚，根据前一个字符串的读法的到下一个字符串，利用递归实现，但要注意递归的次数。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">//如果n为1，直接返回”1“</span><br><span class="line">if(n==1)&#123;</span><br><span class="line">return &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//将”1“作为初始串，进行递归</span><br><span class="line">//这里要传递n-1而不是n，因为”1“也算进去了</span><br><span class="line">return getSeq(&quot;1&quot;,n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getSeq(String s,int n)&#123;</span><br><span class="line">//递归出口</span><br><span class="line">if(n==0)&#123;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">//用于拼接字符串</span><br><span class="line">StringBuilder sb=new StringBuilder();</span><br><span class="line">int i=0;</span><br><span class="line">//遍历当前字符串</span><br><span class="line">while(i&lt;s.length())&#123;</span><br><span class="line">//用于记录相同字符的个数</span><br><span class="line">int count=1;</span><br><span class="line">char ch=s.charAt(i++);</span><br><span class="line">while(i&lt;s.length()&amp;&amp;s.charAt(i)==ch)&#123;</span><br><span class="line">i++;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">//前一个字符串各个字符的个数+字符就是下一个字符串</span><br><span class="line">sb.append(count);</span><br><span class="line">sb.append(ch);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">return getSeq(sb.toString(),n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置</title>
      <link href="/2019/10/22/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/10/22/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第35题</b><br>难度：<font color="green">简单</font><br>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。(你可以假设数组中无重复元素)</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很明显，这是一道二分查找的题目，对于二分查找，思想比较简单，但是实现起来却并不是那么容易，要特别注意边界条件。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">return BinarySearch(nums,0,nums.length-1,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int BinarySearch(int[] nums,int left,int right,int target)&#123;</span><br><span class="line">if(left&gt;right)&#123;</span><br><span class="line">return left;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int mid=(right+left)/2;</span><br><span class="line">if(nums[mid]&lt;target)&#123;</span><br><span class="line">return BinarySearch(nums,mid+1,right,target);</span><br><span class="line">&#125;</span><br><span class="line">else if(nums[mid]&gt;target)&#123;</span><br><span class="line">return BinarySearch(nums,left,mid-1,target);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归出口<br>当left&gt;right时说明数组已经遍历完，没有找到目标值，此时应该将目标值插入合适的位置。通过代码可以发现，<font color="red">left指向的元素是第一个大于目标值的元素，因此目标值应该插入到left下标位置。</font></li><li>递归过程<br>在递归过程中，需要不断地逼近递归出口。这样mid+1和mid-1就很好理解了。<hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共前缀</title>
      <link href="/2019/10/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2019/10/21/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第十四题</b><br>难度：<font color="green">简单</font><br>题目：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。(只包含小写字母)</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>首先判断边界条件，根据题意，当数组长度为0时，返回空串””。如果数组中存在一个””，那么也返回空串。<br>解决了边界问题后，来看着这个题。解决方法有很多，介绍一种简单地，使用indexOf()方法来解决。</p><ol><li>先选定数组的一个元素作为基准(这里选的是arr[0])，</li><li>依次遍历数组剩下的元素，判断该基准是否是其他元素的前缀</li><li>如果不是，基准长度-1，继续判断，直到基准为空(返回”“)或是当前元素前缀为止。</li><li>重复2，3步，遍历数组所有元素。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">//注意边界条件，如果数组长度为0，直接返回</span><br><span class="line">if(strs.length==0)&#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String prefix=strs[0];</span><br><span class="line">for(int i=1;i&lt;strs.length;i++)&#123;</span><br><span class="line">//如果有任意元素为”“，直接返回</span><br><span class="line">if(strs[i].equals(&quot;&quot;))&#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(strs[i].indexOf(prefix)!=0)&#123;</span><br><span class="line">prefix=prefix.substring(0,prefix.length()-1);</span><br><span class="line">if(prefix.equals(&quot;&quot;))&#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="/2019/10/21/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2019/10/21/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第九题</b><br>难度：<font color="green">简单</font><br>题目：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例二：</span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><h1 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h1><p>这题思想很简单，一般的做法就是简单地将数字逆着算一遍然后比较是否相等。但这不是最优的解法，否则就没必要记录这一题了。其实，我们在将数字逆置到一半的时候就可以得到结论，并不需要完全逆置。<br>另外，示例已经提示的很清楚，对于负数和10的倍数可以直接返回false，但是0要返回true。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(int x) &#123;</span><br><span class="line">if(x&lt;0||x!=0&amp;&amp;x%10==0)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int res=0;</span><br><span class="line">while(x&gt;res)&#123;</span><br><span class="line">res=(res*10+x%10);</span><br><span class="line">x/=10;</span><br><span class="line">&#125;</span><br><span class="line">return x==res/10||x==res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>好的思想总是让人眼前一亮，忍不住要记录下来。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2019/10/21/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/10/21/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><b>LeetCode第三题</b><br>难度：<font color="yellow">中等</font><br>题目：给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><hr><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例二：</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li>定义一个HashMap&lt;K,V&gt;，其中key为字符，Value为字符的位置i+1；</li><li>定义不重复子串的开始位置为start，结束位置为end，长度为ans，并且都初始化为0</li><li>遍历字符串(end++)，随着end往后移动的过程中<ul><li>如果[start,end]区间内出现重复字符，更新start，将start移动到重复字符的后一个位置</li></ul></li><li>更新ans，将字符加入到HashMap中。</li><li>在整个过程中以[start,end]为边界的窗口在向后移动，最大子串的长度即为移动过程中窗口的最大长度</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">//记录子串的最大长度</span><br><span class="line">int ans=0;</span><br><span class="line">int length=s.length();</span><br><span class="line">Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">for(int start=0,end=0;end&lt;length;end++)&#123;</span><br><span class="line">char ch=s.charAt(end);</span><br><span class="line">//当[start,end]区间出现重复字符，</span><br><span class="line">//将start移到重复字符后一个位置</span><br><span class="line">if(map.containsKey(ch))&#123;</span><br><span class="line">start=Math.max(map.get(ch),start);</span><br><span class="line">&#125;</span><br><span class="line">ans=Math.max(ans,end-start+1);</span><br><span class="line">map.put(ch,end+1);</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-哈希表</title>
      <link href="/2019/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>哈希表又称为散列表。散列表的实现常常叫做散列，散列是一种以常数平均时间执行插入、删除和查找的技术。但是对于散列，不支持那些需要元素间任何排序信息的操作。</p><hr><a id="more"></a>对于散列的基础知识不做过多的介绍，主要介绍散列函数的选择以及解决冲突的方法，会以三个写的散列表作为演示。<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>如果输入的关键字是整数，则散列函数一般为<font color="red">f(Key)=Key mod TableSize</font>。其中Key为关键字(整数)，TableSize为表的大小。f(Key)为该关键字应该在表中的下标。如果表的大小为10而关键字都以0为个位，那么上面的散列函数就不是一个好的选择，因为会将很多关键字映射到一个位置。比较好的办法就是<font color="red">保证表的大小为素数，这样当输入关键字是随机整数时，散列函数不仅计算起来简单而且分配也很均匀。</font><br>在通常情况下，关键字是字符串，这时候散列函数就需要仔细地选择，这里提供两种方法</p><ol><li>将字符串中字符的ASCII码值加起来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int hash(String key, int TableSize) &#123;</span><br><span class="line">int hashVal = 0;</span><br><span class="line">for (int i = 0; i &lt; key.length(); i++) &#123;</span><br><span class="line">hashVal += key.charAt(i);</span><br><span class="line">&#125;</span><br><span class="line">return hashVal % TableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这种方法实现起来简单并且能够很快的计算出答案。不过缺点在于如果表很大，函数不会很好的分配关键字。例如设TableSize=10007(素数)，并假设所有关键字至多8个字符长，由于ASCII字符最大值为127，因此散列函数只能将关键字映射到127*8=1016以内，这显然不是一个好选择。</p><ol start="2"><li>下面给出第二种尝试方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int hash(String key, int TableSize) &#123;</span><br><span class="line">int hashVal = 0;</span><br><span class="line">for (int i = 0; i &lt; key.length(); i++) &#123;</span><br><span class="line">hashVal += 37 * hashVal + key.charAt(i);</span><br><span class="line">&#125;</span><br><span class="line">hashVal %= TableSize;</span><br><span class="line">//溢出时进行补偿</span><br><span class="line">if (hashVal &lt; 0) &#123;</span><br><span class="line">hashVal += TableSize;</span><br><span class="line">&#125;</span><br><span class="line">return hashVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该散列函数能够使得关键字分布的较好。并且允许溢出。当溢出时hashVal %= TableSize得到一个绝对值小于TableSize的负数，因此后面进行补偿。这种散列函数就表的分布而言不一定是最好的，但确实具有极其简单的优点而且速度也很快(书上原话)。</p><h1 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h1><p>解决的散列函数的选择，剩下的问题就是如何解决哈希冲突，即当一个元素被插入时，与另一个已经插入的元素散列到相同的值，就会产生冲突，这个冲突需要消除。解决冲突的方法有很多种，这里介绍两种：分离链接法和开放定址法。</p><h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a><font size="5">分离链接法</font></h2><p>解决冲突的第一种方法通常叫做分离链接法(也是HashMap和Set使用的方法)，其做法是将散列到同一个值的所有元素保留到一个表中。如图所示<br><img src="/2019/10/20/数据结构-哈希表/1.png" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用分离链接法构造哈希表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class SeparateChainingHashTable&lt;T&gt; &#123;</span><br><span class="line">    //默认数组的长度</span><br><span class="line">    private static final int DEFAULT_TABLE_SIZE = 101;</span><br><span class="line">//记录元素个数</span><br><span class="line">    private int currentSize;</span><br><span class="line">//用于存储数据</span><br><span class="line">    private List&lt;T&gt;[] theList;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认构造方法</span><br><span class="line">     */</span><br><span class="line">    public SeparateChainingHashTable() &#123;</span><br><span class="line">        this(DEFAULT_TABLE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定初始大小</span><br><span class="line">     * @param size 初始值</span><br><span class="line">     */</span><br><span class="line">    public SeparateChainingHashTable(int size) &#123;</span><br><span class="line">        theList = new LinkedList[nextPrime(size)];</span><br><span class="line">        for (int i = 0; i &lt; theList.length; i++) &#123;</span><br><span class="line">            theList[i] = new LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空表</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        for (int i = 0; i &lt; theList.length; i++) &#123;</span><br><span class="line">            theList[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        currentSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断表中是否包含指定值</span><br><span class="line">     * @param ele 元素的值</span><br><span class="line">     * @return 包含返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(T ele) &#123;</span><br><span class="line">        List&lt;T&gt; whichList = theList[myhash(ele)];</span><br><span class="line">        return whichList.contains(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入方法</span><br><span class="line">     * @param ele 要插入的元素</span><br><span class="line">     */</span><br><span class="line">    public void insert(T ele) &#123;</span><br><span class="line">        List&lt;T&gt; whichList = theList[myhash(ele)];</span><br><span class="line"></span><br><span class="line">        //如果链表中不包含要插入元素，则将元素插入，否则不做任何操作</span><br><span class="line">        if (!whichList.contains(ele))</span><br><span class="line">            whichList.add(ele);</span><br><span class="line">        /**</span><br><span class="line">         * 定义散列表的装填因子Lambda为散列表中元素个数比该表的大小</span><br><span class="line">         * 在这里，如果Lambda超过1，那么就调用rehash方法扩大散列表的大小</span><br><span class="line">         */</span><br><span class="line">        if (++currentSize &gt; theList.length)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除方法</span><br><span class="line">     * @param ele 要删除的节点</span><br><span class="line">     */</span><br><span class="line">    public void remove(T ele) &#123;</span><br><span class="line">        List&lt;T&gt; whichList = theList[myhash(ele)];</span><br><span class="line">        if (whichList.contains(ele)) &#123;</span><br><span class="line">            whichList.remove(ele);</span><br><span class="line">            currentSize--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新散列方法</span><br><span class="line">     */</span><br><span class="line">    private void rehash() &#123;</span><br><span class="line">        List&lt;T&gt;[] oldlist = theList;</span><br><span class="line">        theList = new List[nextPrime(2 * theList.length)];</span><br><span class="line">        for (int i = 0; i &lt; theList.length; i++) &#123;</span><br><span class="line">            theList[i] = new LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; oldlist.length; i++) &#123;</span><br><span class="line">            for (T t : oldlist[i]) &#123;</span><br><span class="line">                insert(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * hash函数，将元素映射到指定链表上</span><br><span class="line">     * @param x 传入参数</span><br><span class="line">     * @return 参数应该映射的下标</span><br><span class="line">     */</span><br><span class="line">    private int myhash(T x) &#123;</span><br><span class="line">        int hashVal = x.hashCode();</span><br><span class="line">        hashVal %= theList.length;</span><br><span class="line">        if (hashVal &lt; 0)</span><br><span class="line">            hashVal += theList.length;</span><br><span class="line">        return hashVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前值的下一个素数</span><br><span class="line">     * @param n 当前值</span><br><span class="line">     * @return 当前值的下一个参数</span><br><span class="line">     */</span><br><span class="line">    private int nextPrime(int n) &#123;</span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; !isPrime(n); n += 2);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断由nextPrime()方法传递的参数是否为素数</span><br><span class="line">     * @param n 由nextPrime()方法传递的参数</span><br><span class="line">     * @return 是素数返回true，不是返回false</span><br><span class="line">     */</span><br><span class="line">    private boolean isPrime(int n) &#123;</span><br><span class="line">        if (n == 2 || n == 3)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        if (n == 1 || n % 2 == 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (int i = 3; i * i &lt;= n; i += 2)</span><br><span class="line">            if (n % i == 0)</span><br><span class="line">                return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离链接法思想不是很难，主要说一下insert()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入方法</span><br><span class="line"> * @param ele 要插入的元素</span><br><span class="line"> */</span><br><span class="line">public void insert(T ele) &#123;</span><br><span class="line">List&lt;T&gt; whichList = theList[myhash(ele)];</span><br><span class="line"></span><br><span class="line">//如果链表中不包含要插入元素，则将元素插入，否则不做任何操作</span><br><span class="line">if (!whichList.contains(ele))</span><br><span class="line">whichList.add(ele);</span><br><span class="line">/**</span><br><span class="line"> * 定义散列表的装填因子Lambda为散列表中元素个数比该表的大小</span><br><span class="line"> * 在这里，如果Lambda超过1，那么就调用rehash方法扩大散列表的大小</span><br><span class="line"> */</span><br><span class="line">if (++currentSize &gt; theList.length)</span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义<font color="red"><b>散列表的装填因子Lambda为散列表中元素个数于该表大小的比值</b></font>。在上面的代码中，Lambda=1。当Lambda=1时，如果链表的长度为Lambda，执行查找工作大概需要1+(Lambda)/2个节点的查找代价。<br><font color="red">散列表的大小实际上并不重要，装填因子才是最重要的。分离链接法的一般法则是使得表的大小与预料元素的个数大致相等(即让Lambda=1)。</font>如果Lambda &gt; 1，那么用rehash()方法扩大散列表的大小。</p><h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a><font size="5">线性探测法</font></h2><p>分离链接法的缺点是使用一些链表，由于给新单元分配地址需要时间，因此这就导致算法的速度有些缓慢，同时算法实际上还要求对第二种数据结构的实现。下面介绍探测散列表，它的装填因子约为0.5。<br>对于线性探测法，解决冲突的方法一般为f(i)=i。如图所示，将关键字{89，18，49，58，69}一次插入到一个散列表中，此时解决冲突的方法就是f(i)=i。<br><img src="/2019/10/20/数据结构-哈希表/2.png" alt><br>第一个冲突在插入关键字49时产生，它被放到下一个空闲地址，即0地址。关键字58先与18冲突，再与89冲突，然后又和49冲突，试选三次后才找到空闲单元。69同样也是这样解决冲突。<br>这样一来，<font color="blue">只要表足够大，总能找到一个自由单元，但是花费的事件也是相当多的。更不幸的是，即使表相对较空，这样占据的单元也会形成一些区块，其结果称为一次聚集，也就是说，散列到区块的任何关键字都需要多次试选单元才能够解决冲突。</font><br>线性探测法代码就不上了，下面介绍一种能够解决线性探测法中一次聚集问题的探测方法–平方探测法</p><h2 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a><font size="5">平方探测法</font></h2><p>平方探测法，就是冲突函数为二次的探测方法，流行的选择是f(i)=i*i。如图，同样使用关键字{89，18，49，58，69}插入链表中<br><img src="/2019/10/20/数据结构-哈希表/3.png" alt>当插入49时发生冲突，f(i)=f(1)=1；并且下一个位置是空的，因此49就放到0位置。<font color="red">插入58是第一次和18发生冲突，f(i)=f(1)=1，但是下一个位置不为空，因此进行第二次探测，f(2)=4，下一个单元在距位置8为4的地方也就是2。因此58就放在2处。</font><br>对于线性探测，让当散列表几乎填满元素时性能会降低。对于<font color="blue">平方探测更为严重，一旦表被填充超过一半，当表的大小不是素数时甚至在表被填充一半之前就不能保证一次找到空的单元了。</font>可以证明，<font color="red"><b>如果表有一半是空的，并且表的大小是素数，那么就能保证总能插入一个新的元素。</b></font>即使表被填充的位置仅比一半多一个，那么插入都有可能失败。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">package 哈希表结构;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平方探测法</span><br><span class="line"> * 冲突解决方法：f(i)=i*i</span><br><span class="line"> * 即 f(i)=f(i-1)+2*i-1=f(i-1)+2*(i-1)+1</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class QuadraticProbingHashTable&lt;T&gt; &#123;</span><br><span class="line">    private static final int DEFAULT_TABLE_SIZE = 101;</span><br><span class="line">    private int currentSize;</span><br><span class="line">    private HashEntry&lt;T&gt;[] array;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public QuadraticProbingHashTable1() &#123;</span><br><span class="line">        this(DEFAULT_TABLE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 私有嵌套类作为节点存储数据和记录存活状态</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    private static class HashEntry&lt;T&gt;&#123;</span><br><span class="line">        private T ele;</span><br><span class="line">        private boolean isAlive;</span><br><span class="line"></span><br><span class="line">        public HashEntry(T ele) &#123;</span><br><span class="line">            this(ele, true);</span><br><span class="line">        &#125;</span><br><span class="line">        public HashEntry(T ele, boolean isAlive) &#123;</span><br><span class="line">            this.ele = ele;</span><br><span class="line">            this.isAlive = isAlive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除表中所有数据项</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        currentSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QuadraticProbingHashTable1(int size) &#123;</span><br><span class="line">        allocateArray(size);</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在表中查找指定元素</span><br><span class="line">     * @param ele 要查找的元素</span><br><span class="line">     * @return 找到返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(T ele) &#123;</span><br><span class="line">        int currentPos = findPos(ele);</span><br><span class="line">        return isAlive(currentPos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入方法</span><br><span class="line">     * @param ele</span><br><span class="line">     */</span><br><span class="line">    public boolean insert(T ele) &#123;</span><br><span class="line">        int currentPos = findPos(ele);</span><br><span class="line">        //说明当前表中已有该元素并且并没有被删除，不做操作</span><br><span class="line">        if (isAlive(currentPos)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //将元素插入</span><br><span class="line">        array[currentPos] = new HashEntry&lt;&gt;(ele, true);</span><br><span class="line">        //表中元素数+1并判断是否超过数组长度一半</span><br><span class="line">        if (++currentSize &gt; array.length / 2) &#123;</span><br><span class="line">            rehash();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除方法</span><br><span class="line">     * @param ele</span><br><span class="line">     */</span><br><span class="line">    public boolean remove(T ele) &#123;</span><br><span class="line">        int currentPose = findPos(ele);</span><br><span class="line">        if (isAlive(currentPose)) &#123;</span><br><span class="line">            array[currentPose].isAlive = false;</span><br><span class="line">            currentSize--;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return currentSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 再散列方法</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    private void rehash() &#123;</span><br><span class="line">        HashEntry&lt;T&gt;[] oldarray = array;</span><br><span class="line">        //创建一个新数组</span><br><span class="line">        allocateArray(2 * array.length);</span><br><span class="line">        //将占有数和存活数都初始化0值</span><br><span class="line">        currentSize = 0;</span><br><span class="line">        //将原数组元素拷贝到新数组上</span><br><span class="line">        for (HashEntry&lt;T&gt; hashEntry : oldarray) &#123;</span><br><span class="line">            //只拷贝存活的元素</span><br><span class="line">            if (hashEntry != null &amp;&amp; hashEntry.isAlive) &#123;</span><br><span class="line">                insert(hashEntry.ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断给定数组下标中是否存在元素，如果存在是否被删除</span><br><span class="line">     * @param currentPos</span><br><span class="line">     * @return 如果存在且未被删除，返回true</span><br><span class="line">     */</span><br><span class="line">    private boolean isAlive(int currentPos) &#123;</span><br><span class="line">        return array[currentPos] != null &amp;&amp; array[currentPos].isAlive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找到一个合适的位置</span><br><span class="line">     * @param ele 传入参数</span><br><span class="line">     * @return 返回数组下标元素要么值等于ele，要么为空</span><br><span class="line">     */</span><br><span class="line">    private int findPos(T ele) &#123;</span><br><span class="line">        int offest = 1;</span><br><span class="line">        int currentPos = myhash(ele);</span><br><span class="line">        while (array[currentPos] != null &amp;&amp; !array[currentPos].ele.equals(ele)) &#123;</span><br><span class="line">            currentPos += offest;</span><br><span class="line">            offest += 2;</span><br><span class="line">            if (currentPos &gt;= array.length) &#123;</span><br><span class="line">                currentPos -= array.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return currentPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 散列函数，将元素映射到指定数组下标中</span><br><span class="line">     * @param ele</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private int myhash(T ele) &#123;</span><br><span class="line">        int hashVal = ele.hashCode();</span><br><span class="line">        hashVal %= array.length;</span><br><span class="line">        if (hashVal &lt; 0) &#123;</span><br><span class="line">            hashVal += array.length;</span><br><span class="line">        &#125;</span><br><span class="line">        return hashVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个指定大小的数组用来存储数据</span><br><span class="line">     * @param arraySize</span><br><span class="line">     */</span><br><span class="line">    private void allocateArray(int arraySize) &#123;</span><br><span class="line">        array = new HashEntry[nextPrime(arraySize)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找到n后面的素数</span><br><span class="line">     * @param n</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private int nextPrime(int n) &#123;</span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; !isPrime(n); n += 2) ;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断素数</span><br><span class="line">     * @param n</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean isPrime(int n) &#123;</span><br><span class="line">        if (n == 1 || n % 2 == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2 || n == 3) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 3; i * i &lt; n; i += 2) &#123;</span><br><span class="line">            if (n % i == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在探测散列表中不能使用真正的删除操作，因为相应的单元可能已经引起过冲突，元素绕过它存在了别处。例如，如果我们删89，那么实际上剩下的contains操作都将失败。所以我们使用惰性删除，即将要删除的元素做一个标记而不是真的删除它。<br>在本例中，没有使用链表数组，而是使用散列表项单元的数组，定义了一个HashEntry类用于存储数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 私有嵌套类作为节点存储数据和记录存活状态</span><br><span class="line"> * @param &lt;T&gt;</span><br><span class="line"> */</span><br><span class="line">private static class HashEntry&lt;T&gt;&#123;</span><br><span class="line">//保存数据</span><br><span class="line">private T ele;</span><br><span class="line">//记录元素状态，如果已被删除该boolean值为false</span><br><span class="line">private boolean isAlive;</span><br><span class="line"></span><br><span class="line">public HashEntry(T ele) &#123;</span><br><span class="line">this(ele, true);</span><br><span class="line">&#125;</span><br><span class="line">public HashEntry(T ele, boolean isAlive) &#123;</span><br><span class="line">this.ele = ele;</span><br><span class="line">this.isAlive = isAlive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了上面的类作为节点，那么一个HashEntry引用数组的每一项是下面三种情况之一</p><ol><li><b>null，说明当前单元为空，可以直接插入</b></li><li><b>非null，并且isAlive为true，当前单元存在数据且未被删除，不能直接插入，需要使用冲突函数绕过该节点</b></li><li><b>非null，但是isAlive为false，当前单元存在数据但是已经被删除(懒惰删除)，可以直接插入覆盖</b></li></ol><h1 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h1><p>前面无论是线性探测法还是平方探测法都是用到了rehash()方法，即再散列。下面就来介绍一下再散列<br>前面说过，对于平方探测法，如果元素散列表太满，那么操作的运行时间会变长，并且插入操作可能失败。为了解决这种问题，我们建立一个另外约大两倍的表(且使用一个新的散列函数)，扫描整个原始散列表，计算每个(未删除)元素的新散列值并将其插入到新散列表中。这就是再散列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 平方探测法的</span><br><span class="line"> * 再散列方法</span><br><span class="line"> */</span><br><span class="line">private void rehash() &#123;</span><br><span class="line">HashEntry&lt;T&gt;[] oldarray = array;</span><br><span class="line">//创建一个新数组</span><br><span class="line">allocateArray(2 * array.length);</span><br><span class="line">//将占有数和存活数都初始化0值</span><br><span class="line">currentSize = 0;</span><br><span class="line">//将原数组元素拷贝到新数组上</span><br><span class="line">for (HashEntry&lt;T&gt; hashEntry : oldarray) &#123;</span><br><span class="line">//只拷贝存活的元素</span><br><span class="line">if (hashEntry != null &amp;&amp; hashEntry.isAlive) &#123;</span><br><span class="line">insert(hashEntry.ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“====================================================================================”</span><br><span class="line">对于前面说的使用一个新的散列表并且使用新的散列函数，这里使用的是hashVal mod array.length。</span><br><span class="line">因此当新的表建立时，array.length也会改变，自动得就会使用新的散列函数</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 散列函数，将元素映射到指定数组下标中</span><br><span class="line"> * @param ele</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int myhash(T ele) &#123;</span><br><span class="line">int hashVal = ele.hashCode();</span><br><span class="line">hashVal %= array.length;</span><br><span class="line">if (hashVal &lt; 0) &#123;</span><br><span class="line">hashVal += array.length;</span><br><span class="line">&#125;</span><br><span class="line">return hashVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>关于散列表的部分就介绍到这里，可以看到散列表主要解决的就是散列函数和冲突解决方法两大问题。]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 分离链接法 </tag>
            
            <tag> 开放定址法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想之浅谈反射机制</title>
      <link href="/2019/10/20/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/20/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>运行时类型信息使得你可以在程序运行时发现和使用类型信息。在Java中，有两种方式让我们在运行时识别对象和类的信息。</p><ol><li>传统的“RTTI”(运行时，识别一个对象的类型)<br>它假定我们在编译时已经知道了所有的类型</li><li>反射机制<br>它允许我们在运行时发现和使用类的信息<hr><a id="more"></a></li></ol><h1 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h1><p>运行时类型信息使得我们可以在程序运行时发现和使用类型信息。RTTI的含义：在运行时，识别一个对象的类型。</p><h2 id="关于Class类对象"><a href="#关于Class类对象" class="headerlink" title="关于Class类对象"></a><font size="5">关于Class类对象</font></h2><p>Java中有一个特殊的对象–Class对象，该对象包含了与类有关的信息。事实上，Class对象就是用来创建类的所有“常规”对象的。Java中使用Class对象来执行RTTI。每当编写并且编译了一个新类，就会产生一个Class对象(被保存在同名的.class文件中)。<br>主要有三种RTTI形式</p><ol><li><b>传统的类型转换，由RTTI来确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常</b></li><li><b>代表对象类型的Class对象，通过查询Class对象可以获取运行时所需的信息</b></li><li><b>关键字instanceof，告诉我们对象是不是某个特定类型的实例</b></li></ol><p>但是无论是三种方法中的哪一种，<font color="red">在使用RTTI时都要求这个类型在编译时必须已知。也就是说，在编译时，编译器必须知道所有要通过RTTI来处理的类(类名)。</font><br>但是现在，假设运行期间你获取了一个不在你程序空间中的对象的引用，通过RTTI是没有办法知道这个对象到底是属于哪个类，因为编译器根本就不知道这个类的名字。<br>假设你从磁盘或者网络中获取了一串字节，并且被告知这是一个类(假设该类名为A)。那你要怎样使用这个类呢？正常情况下是没办法使用的，就比如你要产生这个类的对象，是做不到的。因为你的代码中根本就没有A a=new A()这样的代码，<br>那你说我提前在写一个A a=new A()，这样也不行，代码是通不过编译的，因为编译器检查这段代码发现程序空间中根本就没有A这个类，因为这个类是你运行时候从别的地方加载进来的，编译器根本就不知道会有A这个类，同样的你要调用类的字段方法统统都做不到。对于这种类似的情况，就要用到反射。</p><h2 id="四种获取Class对象的方法"><a href="#四种获取Class对象的方法" class="headerlink" title="四种获取Class对象的方法"></a><font size="5">四种获取Class对象的方法</font></h2><p>既然说到Class类对象，就来谈一谈如何获取该对象吧</p><ol><li>Class.forName(String name)<br>通过Class类的静态方法获取，传递参数为<font color="blue"><b>类的全限定名(包名.类名)</b></font>。</li><li>通过类字面常量.class获取<br>使用<font color="blue"><b>类名.class</b></font>来获取Class类对象，当使用这种方法时，<font color="red">不会引发类的初始化(通俗的说，类的静态代码块不会被执行)。</font></li><li>通过类对象来获取<br>如果你已经有了一个对象，那么可以使用<font color="blue"><b>对象名.getClass()</b></font>来获取该对象的Class对象</li><li>通过类加载器获取<br>如果有了一个类加载器对象classLoader，那么可以使用classLoader.loadclass(String name)方法获取指定名称的Class对象，参数类的全限定名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//通过一个Class对象获取类加载器</span><br><span class="line">ClassLoader classLoader = son2Class.getClassLoader();</span><br><span class="line">//通过类加载器获取另一个类的Class对象</span><br><span class="line">Class&lt;?&gt; cl = classLoader.loadClass(&quot;想要获取哪个类的Class对象，就传递该类的全限定名&quot;);</span><br></pre></td></tr></table></figure></li></ol><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><font color="blue">Class类和java.lang.reflect类库一起对反射机制进行了支持</font>，该类库包含Field、Method以及Constructor(这些类都实现了Member接口)。这些类型的对象是由JVM在运行时创建的，用来表示未知类里对应的成员。<br>这样你就可以用Constructor创建对象(而不必使用对象名)，用get()和set()方法读写与Field对象相关联的字段，使用invoke()方法调用与Method对象相关联的方法……这样以来，未知对象的类信息就完全确定了，即使在编译时根本不知道这个类。<br>或者在运行期间从网路中获取了一个类，可以使用反射来创建该类的对象，调用对象的方法，即使根本不知道类的名字，没有也不可能在代码中使用new，来创建对象。</p><p>当<font color="red">通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看他属于哪一个特定的类(就像传统的RTTI那样)。在用它做其他事情之前必须先加载那个类的Class对象(加载类的.class文件)，因此这个类的.class文件对于JVM来说必须是可以获得的(要么在本地机器，要么从网络中获取)。</font><br>所以RTTI与反射之间真正的区别只在于</p><ul><li><b>对于RTTI，编译器在编译时打开和检查.class文件。(我们知道类的名字，在代码中使用普通的方式创建对象，调用对象的方法)</b></li><li><b>对于反射机制，.class文件在编译时是不可获取的，是在运行期间(程序运行到代码的某个部分)获取到的。所以在运行时打开和检查.class文件。</b></li></ul><p>总结一下Java反射机制<br><font color="red">在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它任意的方法。这种动态获取类的内容以及动态调用对象的方法称为反射机制。</font></p><h1 id="Java反射API"><a href="#Java反射API" class="headerlink" title="Java反射API"></a>Java反射API</h1><h2 id="Class对象相关方法"><a href="#Class对象相关方法" class="headerlink" title="Class对象相关方法"></a><font size="5">Class对象相关方法</font></h2><p>Class对象的方法有很多，这里只介绍获取类的字段、方法、构造器三类</p><h3 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a><font size="5">获取字段</font></h3><ul><li><p><font color="blue"><b>getField(String name)</b></font><br>获取指定名称的字段，只能是public的字段</p></li><li><p><font color="blue"><b>getFields()</b></font><br>获取所有的public修饰的字段，包括从父类继承得到的public字段和接口定义的常量。前面说过字段是不存在多态的，让我们来测试一下下面这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//子类中有字段value，父类中也有字段value，并且接口中也有字段value，那么子类的Class对象到底能获取几个字段呢？</span><br><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line">    public int value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father implements Inter &#123;</span><br><span class="line">    public int value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Inter&#123;</span><br><span class="line">    int value = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class getFieldTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Class&lt;?&gt; cl = Class.forName(&quot;fourteen.reflectTest.Son&quot;);</span><br><span class="line">        Field[] fields = cl.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“============================”</span><br><span class="line">Output：</span><br><span class="line">public int Son.value</span><br><span class="line">public static final int Inter.value</span><br><span class="line">public int Father.value</span><br><span class="line"></span><br><span class="line">通过测试我们发现，子类中包含了从接口和父类继承的同名字段，</span><br><span class="line">并且接口中字段默认为常量，并不会发生多态行为</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>getDeclaredField(String name)</b></font><br>获取指定字段，只能是本类定义的字段</p></li><li><p><font color="blue"><b>getDeclaredFields()</b></font><br>获取类自身定义的所有权限的字段，但是不会获取父类或者接口的任何字段。</p></li></ul><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a><font size="5">获取方法</font></h3><ul><li><p><font color="blue"><b>getMethod(String name,Class<t>…args)</t></b></font><br>获取指定名称方法的指定重载形式，只能获取public修饰的方法<br>参数</p><ul><li>String name方法名称</li><li>Class<t>…args方法参数的Class对象(因为方法的重载，所以仅凭方法名无法确定一个方法)</t></li></ul></li><li><p><font color="blue"><b>getMethods()</b></font><br>获取所有public修饰的方法，包括从父类继承的方法。如果发生重写，那么只获取子类的方法。如果发生重载那么父类和子类的方法都会被获取</p></li><li><p><font color="blue"><b>getDeclaredMethod(String name,Class<t>…args)</t></b></font><br>获取指定名称方法的指定重载形式，能获取本类定义的任何权限的方法，无法获取任何父类或接口的方法</p></li><li><p><font color="blue"><b>getDeclaredMethods()</b></font><br>获取本类定义的所有方法，无法获取父类继承的方法。</p></li></ul><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a><font size="5">获取构造器</font></h3><ul><li><p><font color="blue"><b>getConstructor(Class<t>…args)</t></b></font><br>获取指定重载形式的public修饰的构造器，因为构造器和类同名因此无需name参数<br>参数</p><ul><li>Class<t>…args方法参数的Class对象(因为方法的重载，所以仅凭方法名无法确定一个方法)</t></li></ul></li><li><p><font color="blue"><b>getConstructors()</b></font><br>获取所有public修饰的构造器。不会获取父类构造器</p></li><li><p><font color="blue"><b>getDeclaredConstructor(Class<t>…args)</t></b></font><br>获取指定重载形式的构造器，能够类任何权限的构造器。</p></li><li><p><font color="blue"><b>getDeclaredConstructor()</b></font><br>获取类所有权限的构造器</p></li></ul><h2 id="reflect类库对象方法"><a href="#reflect类库对象方法" class="headerlink" title="reflect类库对象方法"></a><font size="5">reflect类库对象方法</font></h2><p>前面的Class对象的三类方法主要是获取reflect类库的三个类对象，分别是Field对象，Method对象以及Constructor类对象</p><h3 id="Field对象方法"><a href="#Field对象方法" class="headerlink" title="Field对象方法"></a><font size="5">Field对象方法</font></h3><ul><li><font color="blue"><b>get()</b></font><br>获取字段的值</li><li><font color="blue"><b>set()</b></font><br>设置字段的值</li></ul><h3 id="Method对象方法"><a href="#Method对象方法" class="headerlink" title="Method对象方法"></a><font size="5">Method对象方法</font></h3><ul><li><font color="blue"><b>Object invoke(Object obj，Object…args)</b></font><br>参数：<ul><li>Object obj:方法所属的类对象</li><li>Object…args:方法所需要的参数<br>返回值：方法如果不为void，那么返回方法执行的结果<br>传入指定参数，执行获取的方法。</li></ul></li></ul><h3 id="Constructor对象方法"><a href="#Constructor对象方法" class="headerlink" title="Constructor对象方法"></a><font size="5">Constructor对象方法</font></h3><ul><li><font color="blue"><b>T newInstance(Object…args)</b></font><br>参数：<ul><li>构造方法需要的参数<br>返回值：执行构造方法创建出来的对象</li></ul></li></ul><hr>对于一些getName()类似的方法没有介绍，但是查看API文档可以很轻易地学习到。另外，如果想要对获取到的私有的(或者是本来权限不够无法操作的)字段、方法或者构造器进行操作，要先调用setAccessible(true)方法。]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 反射机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树</title>
      <link href="/2019/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2019/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>前面说过，数组查询快而增删满，链表增删快而查询慢，那么有没有一种查询和增删修改都比较快的数据结构呢？这里主要介绍两种树，即二叉查找树和AVL树。值得一提的是，二叉查找树对于大部分操作的运行时间平均为O(logN)。</p><hr><a id="more"></a><p>对于树的基本知识就不做赘述，这里主要通过手写一个二叉查找树和AVL树并实现其一些必要功能来学习这两种数据结构。</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先上代码，然后再对每一个方法的实现进行介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt;&#123;</span><br><span class="line">    //私有嵌套类表示树节点</span><br><span class="line">    private static class BinaryNode&lt;T&gt; &#123;</span><br><span class="line">        T ele;</span><br><span class="line">        BinaryNode&lt;T&gt; left;</span><br><span class="line">        BinaryNode&lt;T&gt; right;</span><br><span class="line">        BinaryNode(T ele) &#123;</span><br><span class="line">            this(ele, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryNode(T ele, BinaryNode&lt;T&gt; left, BinaryNode&lt;T&gt; right) &#123;</span><br><span class="line">            this.ele = ele;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BinarySearchTree成员属性，表示树的根节点</span><br><span class="line">    private BinaryNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    //无参构造方法</span><br><span class="line">    public BinarySearchTree() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断树空</span><br><span class="line">     * @return 为空返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return root == null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断树中是否含有指定元素</span><br><span class="line">     * @param ele 指定元素</span><br><span class="line">     * @return 包含返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(T ele) &#123;</span><br><span class="line">        return contains(ele, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取树中节点的最小值</span><br><span class="line">     * @return 最小节点值</span><br><span class="line">     */</span><br><span class="line">    public T findMin() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        return findMin(root).ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取树中最大节点的值</span><br><span class="line">     * @return 最大节点值</span><br><span class="line">     */</span><br><span class="line">    public T findMax() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        return findMax(root).ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向树种插入节点</span><br><span class="line">     * @param ele 插入元素的值</span><br><span class="line">     */</span><br><span class="line">    public void insert(T ele) &#123;</span><br><span class="line">        root = insert(ele, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除指定节点</span><br><span class="line">     * @param ele 删除节点值</span><br><span class="line">     */</span><br><span class="line">    public void remove(T ele) &#123;</span><br><span class="line">        root = remove(ele, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先序遍历树并打印</span><br><span class="line">     */</span><br><span class="line">    public void infixPrintTree() &#123;</span><br><span class="line">        infixPrintTree(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 中序遍历树并打印</span><br><span class="line">     */</span><br><span class="line">    public void InOrderPrintTree() &#123;</span><br><span class="line">        InOrderPrintTree(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后序遍历树并打印</span><br><span class="line">     */</span><br><span class="line">    public void SufixPrintTree() &#123;</span><br><span class="line">        SufixPrintTree(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SufixPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            SufixPrintTree(t.left);</span><br><span class="line">            SufixPrintTree(t.right);</span><br><span class="line">            System.out.println(t.ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InOrderPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            System.out.println(t.ele);</span><br><span class="line">            InOrderPrintTree(t.left);</span><br><span class="line">            InOrderPrintTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void infixPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            infixPrintTree(t.left);</span><br><span class="line">            System.out.println(t.ele);</span><br><span class="line">            infixPrintTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BinaryNode&lt;T&gt; remove(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = ele.compareTo(t.ele);</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            t.left = remove(ele, t.left);</span><br><span class="line">        &#125; else if (res &gt; 0) &#123;</span><br><span class="line">            t.right = remove(ele, t.right);</span><br><span class="line">        &#125; else if (t.left != null &amp;&amp; t.right != null) &#123;</span><br><span class="line">            t.ele = findMin(t.right).ele;</span><br><span class="line">            t.right = remove(t.ele, t.right);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            t = (t.left != null) ? t.left : t.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BinaryNode&lt;T&gt; insert(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return new BinaryNode&lt;&gt;(ele, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = ele.compareTo(t.ele);</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            t.left = insert(ele, t.left);</span><br><span class="line">        &#125; else if (res &gt; 0) &#123;</span><br><span class="line">            t.right = insert(ele, t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        else;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t.right == null) &#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        return findMax(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">       if (t.left == null) &#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        return findMin(t.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean contains(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = ele.compareTo(t.ele);</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            return contains(ele, t.left);</span><br><span class="line">        &#125; else if (res &gt; 0) &#123;</span><br><span class="line">            return contains(ele, t.right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ol><li><font color="blue"><b>节点类</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static class BinaryNode&lt;T&gt; &#123;</span><br><span class="line">//节点值</span><br><span class="line">T ele;</span><br><span class="line">//指向该节点的左子树</span><br><span class="line">BinaryNode&lt;T&gt; left;</span><br><span class="line">//指向该节点的右子树</span><br><span class="line">BinaryNode&lt;T&gt; right;</span><br><span class="line">//无参构造方法</span><br><span class="line">BinaryNode(T ele) &#123;</span><br><span class="line">this(ele, null, null);</span><br><span class="line">&#125;</span><br><span class="line">BinaryNode(T ele, BinaryNode&lt;T&gt; left, BinaryNode&lt;T&gt; right) &#123;</span><br><span class="line">this.ele = ele;</span><br><span class="line">this.left = left;</span><br><span class="line">this.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>就像前面的链表结构、哈希表结构，它们的每一个节点也都是一个类，这里定义了一个树节点类，使用了泛型。<br>节点类类有三个属性、一个无参构造方法和一个含餐构造方法。实现比较简单，就不多说</p><ol start="2"><li><font color="blue"><b>contains(T ele)方法</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断树中是否含有指定元素</span><br><span class="line"> * @param ele 指定元素</span><br><span class="line"> * @return 包含返回true，否则返回false</span><br><span class="line"> */</span><br><span class="line">public boolean contains(T ele) &#123;</span><br><span class="line">return contains(ele, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=================================================”</span><br><span class="line"></span><br><span class="line">private boolean contains(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t == null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int res = ele.compareTo(t.ele);</span><br><span class="line">if (res &lt; 0) &#123;</span><br><span class="line">return contains(ele, t.left);</span><br><span class="line">&#125; else if (res &gt; 0) &#123;</span><br><span class="line">return contains(ele, t.right);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>调用的是contains(T ele)的重载方法contains(T ele,BinaryNode<t> t)，将根节点root作为参数传递进去。<br>该方法使用递归查询</t></p><ol><li><p>将待查找值和当前节点值进行比较</p><ol><li>如果大于当前节点值，递归查询当前节点的右子树</li><li>如果小于当前节点值，递归查询当前节点的左子树</li><li>如果等于当前节点值，说明树中包含该节点，返回true</li></ol></li><li><p>递归出口：当前节点为空时，说明树中不包含查找值，返回false</p></li><li><p><font color="blue"><b>findMax()和findMin()</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取树中节点的最小值</span><br><span class="line"> * @return 最小节点值</span><br><span class="line"> */</span><br><span class="line">public T findMin() &#123;</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line">return findMin(root).ele;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">   if (t.left == null) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">return findMin(t.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line">“================================================”</span><br><span class="line">/**</span><br><span class="line"> * 获取树中最大节点的值</span><br><span class="line"> * @return 最大节点值</span><br><span class="line"> */</span><br><span class="line">public T findMax() &#123;</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line">return findMax(root).ele;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t.right == null) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">return findMax(t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>分别获取树中节点最大值和最小值。思想很简单，对于二叉查找树的每一个节点，其左子树一定小于右子树。因此该树的最右叶子节点就是最大节点，同样的，最左叶子节点即为最小节点。</p><ol start="4"><li><font color="blue"><b>insert(T ele)</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向树种插入节点</span><br><span class="line"> * @param ele 插入元素的值</span><br><span class="line"> */</span><br><span class="line">public void insert(T ele) &#123;</span><br><span class="line">root = insert(ele, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line">private BinaryNode&lt;T&gt; insert(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t == null) &#123;</span><br><span class="line">return new BinaryNode&lt;&gt;(ele, null, null);</span><br><span class="line">&#125;</span><br><span class="line">int res = ele.compareTo(t.ele);</span><br><span class="line">if (res &lt; 0) &#123;</span><br><span class="line">t.left = insert(ele, t.left);</span><br><span class="line">&#125; else if (res &gt; 0) &#123;</span><br><span class="line">t.right = insert(ele, t.right);</span><br><span class="line">&#125;</span><br><span class="line">else;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>向树中插入节点，要保证插入后仍是二叉查找树。使用递归实现比较简单。</p><ol><li><p>比较待插入值和当前节点值大小</p><ol><li>如果待插入值大于当前节点值，说明该值应该插入在当前节点的右子树中</li><li>如果待插入值小于当前节点值，说明该值应该插入在当前节点的左子树中</li><li>如果待插入值等于当前节点值，由二叉查找树的定义可知节点值不能重复，因此不做插入操作</li></ol></li><li><p>递归出口，有两个递归出口</p><ol><li>找到合适的插入位置，插入后return</li><li>待插入值等于当前节点值，递归结束。返回当前节点</li></ol></li><li><p><font color="blue"><b>树的前中后序遍历</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先序遍历树并打印</span><br><span class="line"> */</span><br><span class="line">public void infixPrintTree() &#123;</span><br><span class="line">infixPrintTree(this.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 中序遍历树并打印</span><br><span class="line"> */</span><br><span class="line">public void InOrderPrintTree() &#123;</span><br><span class="line">InOrderPrintTree(this.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 后序遍历树并打印</span><br><span class="line"> */</span><br><span class="line">public void SufixPrintTree() &#123;</span><br><span class="line">SufixPrintTree(this.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line">private void SufixPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t != null) &#123;</span><br><span class="line">SufixPrintTree(t.left);</span><br><span class="line">SufixPrintTree(t.right);</span><br><span class="line">System.out.println(t.ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void InOrderPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t != null) &#123;</span><br><span class="line">System.out.println(t.ele);</span><br><span class="line">InOrderPrintTree(t.left);</span><br><span class="line">InOrderPrintTree(t.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void infixPrintTree(BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t != null) &#123;</span><br><span class="line">infixPrintTree(t.left);</span><br><span class="line">System.out.println(t.ele);</span><br><span class="line">infixPrintTree(t.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>思想较为简单，算是树的基础操作，不多说</p><ol start="6"><li><font color="blue"><b>remove(T ele)</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定节点</span><br><span class="line"> * @param ele 删除节点值</span><br><span class="line"> */</span><br><span class="line">public void remove(T ele) &#123;</span><br><span class="line">root = remove(ele, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“================================================”</span><br><span class="line"></span><br><span class="line">private BinaryNode&lt;T&gt; remove(T ele, BinaryNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t == null) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">int res = ele.compareTo(t.ele);</span><br><span class="line">if (res &lt; 0) &#123;</span><br><span class="line">t.left = remove(ele, t.left);</span><br><span class="line">&#125; else if (res &gt; 0) &#123;</span><br><span class="line">t.right = remove(ele, t.right);</span><br><span class="line">&#125; else if (t.left != null &amp;&amp; t.right != null) &#123;</span><br><span class="line">t.ele = findMin(t.right).ele;</span><br><span class="line">t.right = remove(t.ele, t.right);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">t = (t.left != null) ? t.left : t.right;</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>删除操作是二叉查找树最困难的操作，对于以恶搞要删除的节点，需要考虑几种可能的情况<br>    1. 如果节点是一个叶子节点，那么可以直接删除<br>    2. 如果节点有一个子节点(左右都可以)，那么可以可以将该节点的父节点指向它的子节点来达到删除该节点的目的，如图<br>    <img src="/2019/10/18/数据结构-树/1.png" alt><br>    3. 比较复杂的是，待删除节点具有两个孩子节点，一般的策略是<font color="red">用待删除节点的右子树中最小的子节点代替该节点的数据并递归的删除那个最小的节点。</font>因为右子树中最小的节点不可能有左儿子，因此第二次remove时要容易。如图<br>    <img src="/2019/10/18/数据结构-树/2.png" alt></p><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>二叉查找树在大多数情况下能够提高我们的访问速度，但是对于下面这样已经退化为链表的二叉排序树，并不能提高我们的访问速度。因此在二叉查找树的基础上又引进了AVL树<br><img src="/2019/10/18/数据结构-树/3.png" alt><font color="red">对于AVL树结构，要求它的每一个节点的左右子树的高度最多相差1。</font></p><h2 id="平衡调整策略"><a href="#平衡调整策略" class="headerlink" title="平衡调整策略"></a>平衡调整策略</h2><p>当执行插入操作时，我们需要更新通向根节点路径上的哪些节点的所有平衡信息。但是，插入一个节点可能会破坏AVL树的特性。如图<br><img src="/2019/10/18/数据结构-树/4.png" alt>破坏平衡的插入情况一共有4种，下面将对这四种情况进行分别说明</p><ol><li><font color="blue"><b>LL形调整</b></font><br><img src="/2019/10/18/数据结构-树/5.png" alt>如图所示</li><li><font color="blue"><b>RR形调整</b></font><br>和LL形类似，可以推导一下</li><li><font color="blue"><b>LR形调整</b></font><br><img src="/2019/10/18/数据结构-树/6.png" alt>如图所示</li><li><font color="blue"><b>RL形调整</b></font><br>同样的，和LR形类似，可以推导一下</li></ol><p>以上就是四种破坏平衡的情况对应的调整策略，下面来看一下代码实现</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AVLtree&lt;T extends Comparable&lt;? super T&gt;&gt;&#123;</span><br><span class="line">    private static final int ALLOW_IMBALANCE = 1;</span><br><span class="line">    private AvlNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    public AVLtree() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //私有嵌套类，树节点类</span><br><span class="line">    private static class AvlNode&lt;T&gt; &#123;</span><br><span class="line">        T ele;</span><br><span class="line">        AvlNode&lt;T&gt; left;</span><br><span class="line">        AvlNode&lt;T&gt; right;</span><br><span class="line">        int height;</span><br><span class="line"></span><br><span class="line">        public AvlNode(T ele) &#123;</span><br><span class="line">            this(ele, null, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private AvlNode(T ele, AvlNode&lt;T&gt; lt, AvlNode&lt;T&gt; rt) &#123;</span><br><span class="line">            this.ele = ele;</span><br><span class="line">            right = left;</span><br><span class="line">            left = lt;</span><br><span class="line">            height = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向AVL树中插入节点</span><br><span class="line">     * @param x 插入的节点值</span><br><span class="line">     */</span><br><span class="line">    public void insert(T x) &#123;</span><br><span class="line">        root=insert(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从AVL树中删除节点</span><br><span class="line">     * @param x 删除的节点值</span><br><span class="line">     */</span><br><span class="line">    public void remove(T x) &#123;</span><br><span class="line">        root = remove(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AvlNode&lt;T&gt; remove(T ele,AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        //如果当前节点为空，说明树中不存在要删除的节点值，直接返回</span><br><span class="line">        if (t == null)</span><br><span class="line">            return t;</span><br><span class="line">        //将当前节点值和删除值比较</span><br><span class="line">        int res = ele.compareTo(t.ele);</span><br><span class="line">        //删除值大于当前节点值，向节点的右子树查询</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            t.left = remove(ele, t.left);</span><br><span class="line">        &#125;</span><br><span class="line">        //删除值小于当前节点值，向节点的左子树查询</span><br><span class="line">        else if (res &gt; 0) &#123;</span><br><span class="line">            t.right= remove(ele, t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    //找到要删除的节点</span><br><span class="line">        //如果要删除的节点左右子树都不为空，</span><br><span class="line">        //那么就将该节点右子树中最小的值代替当前节点的值并递归删除右子树中最小的值</span><br><span class="line">        else if (t.left != null &amp;&amp; t.right != null) &#123;</span><br><span class="line">            t.ele = finMin(t.right).ele;</span><br><span class="line">            t.right = remove(t.ele, t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果要删除的节点左右子树有一个或两个不存在，直接删除</span><br><span class="line">        else</span><br><span class="line">            t = (t.left != null) ? t.left : t.right;</span><br><span class="line">        //每次删除后重新对AVL树进行调整</span><br><span class="line">        return balance(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AvlNode&lt;T&gt; finMin(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t.left == null) &#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        return finMin(t.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先序遍历AVL树</span><br><span class="line">     */</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        preOrder(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 中序遍历AVL树</span><br><span class="line">     */</span><br><span class="line">    public void InOrder() &#123;</span><br><span class="line">        InOrder(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InOrder(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            InOrder(t.left);</span><br><span class="line">            System.out.println(t.ele);</span><br><span class="line">            InOrder(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void preOrder(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            System.out.println(t.ele);</span><br><span class="line">            preOrder(t.left);</span><br><span class="line">            preOrder(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取节点高度</span><br><span class="line">    private int height(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        return t == null ? -1 : t.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AvlNode&lt;T&gt; insert(T x, AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t == null)</span><br><span class="line">            return new AvlNode&lt;T&gt;(x, null, null);</span><br><span class="line">        int CompareResult = x.compareTo(t.ele);</span><br><span class="line">        if (CompareResult &lt; 0 ) &#123;</span><br><span class="line">            t.left = insert(x, t.left);</span><br><span class="line">        &#125; else if (CompareResult &gt; 0) &#123;</span><br><span class="line">            t.right = insert(x, t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return balance(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AvlNode&lt;T&gt; balance(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果节点左子树的高度高于右子树的高度</span><br><span class="line">        if (height(t.left) - height(t.right) &gt; ALLOW_IMBALANCE) &#123;</span><br><span class="line">            //当前节点t左子树的左子树高度大于左子树的右子树的高度</span><br><span class="line">            //属于LL形，需要一次单旋转</span><br><span class="line">            if (height(t.left.left) &gt;= height(t.left.right)) &#123;</span><br><span class="line">                //LL形调整</span><br><span class="line">                t=rotateWithLeftChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //LR形，需要一次双旋转</span><br><span class="line">            else &#123;</span><br><span class="line">                t=doubleWithLeftChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (height(t.right) - height(t.left) &gt; ALLOW_IMBALANCE) &#123;</span><br><span class="line">            //RR形</span><br><span class="line">            if (height(t.right.right) &gt;= height(t.right.left)) &#123;</span><br><span class="line">                //RR形式调整</span><br><span class="line">                t=rotateWithRightChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //RL形</span><br><span class="line">            else &#123;</span><br><span class="line">                t=doubleWithRightChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RL调整</span><br><span class="line">     * @param k3 不平衡的节点</span><br><span class="line">     * @return 调整后的新节点</span><br><span class="line">     */</span><br><span class="line">    private AvlNode&lt;T&gt; doubleWithRightChild(AvlNode&lt;T&gt; k3) &#123;</span><br><span class="line">        AvlNode&lt;T&gt; k1 = k3.right;</span><br><span class="line">        AvlNode&lt;T&gt; k2 = k1.left;</span><br><span class="line">        k3.right = k2.left;</span><br><span class="line">        k1.left = k2.right;</span><br><span class="line">        k2.left = k3;</span><br><span class="line">        k2.right = k1;</span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">        k3.height = Math.max(height(k3.left), height(k3.right)) + 1;</span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">        return k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * LR调整</span><br><span class="line">     * @param k3 不平衡的节点</span><br><span class="line">     * @return 调整后的新节点</span><br><span class="line">     */</span><br><span class="line">    private AvlNode&lt;T&gt; doubleWithLeftChild(AvlNode&lt;T&gt; k3) &#123;</span><br><span class="line">        AvlNode&lt;T&gt; k1 = k3.left;</span><br><span class="line">        AvlNode&lt;T&gt; k2 = k1.right;</span><br><span class="line">        k1.right = k2.left;</span><br><span class="line">        k3.left = k2.right;</span><br><span class="line">        k2.left = k1;</span><br><span class="line">        k2.right = k3;</span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">        k3.height = Math.max(height(k3.left), height(k3.right)) + 1;</span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">        return k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RR调整</span><br><span class="line">     * @param k2 不平衡的节点</span><br><span class="line">     * @return 调整后新的节点</span><br><span class="line">     */</span><br><span class="line">    private AvlNode&lt;T&gt; rotateWithRightChild(AvlNode&lt;T&gt; k2) &#123;</span><br><span class="line">        AvlNode&lt;T&gt; k1 = k2.right;</span><br><span class="line">        k2.right = k1.left;</span><br><span class="line">        k1.left = k2;</span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">        return k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * LL调整</span><br><span class="line">     * @param k2 不平衡的节点</span><br><span class="line">     * @return 调整后新的节点</span><br><span class="line">     */</span><br><span class="line">    private AvlNode&lt;T&gt; rotateWithLeftChild(AvlNode&lt;T&gt; k2) &#123;</span><br><span class="line">        AvlNode&lt;T&gt; k1 = k2.left;</span><br><span class="line">        k2.left = k1.right;</span><br><span class="line">        k1.right = k2;</span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">        return k1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h2><ol><li><font color="blue"><b>节点类</b></font><br>对于二叉查找树中的简单方法入isEmpty等这里就不实现了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//私有嵌套类，树节点类</span><br><span class="line">private static class AvlNode&lt;T&gt; &#123;</span><br><span class="line">//节点值</span><br><span class="line">T ele;</span><br><span class="line">//指向节点左子树</span><br><span class="line">AvlNode&lt;T&gt; left;</span><br><span class="line">//指向节点右子树</span><br><span class="line">AvlNode&lt;T&gt; right;</span><br><span class="line">//记录节点的高度</span><br><span class="line">int height;</span><br><span class="line"></span><br><span class="line">//空参数构造方法</span><br><span class="line">public AvlNode(T ele) &#123;</span><br><span class="line">this(ele, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private AvlNode(T ele, AvlNode&lt;T&gt; lt, AvlNode&lt;T&gt; rt) &#123;</span><br><span class="line">this.ele = ele;</span><br><span class="line">right = left;</span><br><span class="line">left = lt;</span><br><span class="line">height = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于AVL树要求节点的左右子树高度最多相差1，因此就需要<font color="red">每一个节点记录自身的高度，如果是叶子节点，那么高度为0，空节点高度为-1。</font></p><ol start="2"><li><font color="blue"><b>height(AvlNode<t> t)</t></b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取节点高度</span><br><span class="line">private int height(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">return t == null ? -1 : t.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在介绍插入删除操作之前，先介绍两个方法，这是其中一个。思想很简单，如果当前节点不为空，就返回节点的高度，如果为空，返回-1。</p><ol start="3"><li><font color="blue"><b>balance(AvlNode<t> t)</t></b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">private AvlNode&lt;T&gt; balance(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t == null) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">//如果节点左子树的高度和右子树的高度相差超过1</span><br><span class="line">if (height(t.left) - height(t.right) &gt; ALLOW_IMBALANCE) &#123;</span><br><span class="line">//当前节点t左子树的左子树高度大于等于左子树的右子树的高度</span><br><span class="line">//属于LL形，需要一次单旋转</span><br><span class="line">if (height(t.left.left) &gt;= height(t.left.right)) &#123;</span><br><span class="line">//LL形调整</span><br><span class="line">t=rotateWithLeftChild(t);</span><br><span class="line">&#125;</span><br><span class="line">//LR形，需要一次双旋转</span><br><span class="line">else &#123;</span><br><span class="line">t=doubleWithLeftChild(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果右子树的高度和左子树的高度相差超过1</span><br><span class="line">if (height(t.right) - height(t.left) &gt; ALLOW_IMBALANCE) &#123;</span><br><span class="line">//RR形</span><br><span class="line">if (height(t.right.right) &gt;= height(t.right.left)) &#123;</span><br><span class="line">//RR形式调整</span><br><span class="line">t=rotateWithRightChild(t);</span><br><span class="line">&#125;</span><br><span class="line">//RL形</span><br><span class="line">else &#123;</span><br><span class="line">t=doubleWithRightChild(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=================================================================”</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RL调整</span><br><span class="line"> * @param k3 不平衡的节点</span><br><span class="line"> * @return 调整后的新节点</span><br><span class="line"> */</span><br><span class="line">private AvlNode&lt;T&gt; doubleWithRightChild(AvlNode&lt;T&gt; k3) &#123;</span><br><span class="line">AvlNode&lt;T&gt; k1 = k3.right;</span><br><span class="line">AvlNode&lt;T&gt; k2 = k1.left;</span><br><span class="line">k3.right = k2.left;</span><br><span class="line">k1.left = k2.right;</span><br><span class="line">k2.left = k3;</span><br><span class="line">k2.right = k1;</span><br><span class="line">//先重新确定子树的高度，最后确定k2的高度，k2一定在最后确定</span><br><span class="line">k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">k3.height = Math.max(height(k3.left), height(k3.right)) + 1;</span><br><span class="line">k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">return k2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LR调整</span><br><span class="line"> * @param k3 不平衡的节点</span><br><span class="line"> * @return 调整后的新节点</span><br><span class="line"> */</span><br><span class="line">private AvlNode&lt;T&gt; doubleWithLeftChild(AvlNode&lt;T&gt; k3) &#123;</span><br><span class="line">AvlNode&lt;T&gt; k1 = k3.left;</span><br><span class="line">AvlNode&lt;T&gt; k2 = k1.right;</span><br><span class="line">k1.right = k2.left;</span><br><span class="line">k3.left = k2.right;</span><br><span class="line">k2.left = k1;</span><br><span class="line">k2.right = k3;</span><br><span class="line">//先重新确定子树的高度，最后确定k2的高度，k2一定在最后确定</span><br><span class="line">k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">k3.height = Math.max(height(k3.left), height(k3.right)) + 1;</span><br><span class="line">k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">return k2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RR调整</span><br><span class="line"> * @param k2 不平衡的节点</span><br><span class="line"> * @return 调整后新的节点</span><br><span class="line"> */</span><br><span class="line">private AvlNode&lt;T&gt; rotateWithRightChild(AvlNode&lt;T&gt; k2) &#123;</span><br><span class="line">AvlNode&lt;T&gt; k1 = k2.right;</span><br><span class="line">k2.right = k1.left;</span><br><span class="line">k1.left = k2;</span><br><span class="line">//先确定子树k2的高度，后确定k1的高度</span><br><span class="line">k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">return k1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LL调整</span><br><span class="line"> * @param k2 不平衡的节点</span><br><span class="line"> * @return 调整后新的节点</span><br><span class="line"> */</span><br><span class="line">private AvlNode&lt;T&gt; rotateWithLeftChild(AvlNode&lt;T&gt; k2) &#123;</span><br><span class="line">AvlNode&lt;T&gt; k1 = k2.left;</span><br><span class="line">k2.left = k1.right;</span><br><span class="line">k1.right = k2;</span><br><span class="line">//先确定子树k2的高度，后确定k1的高度</span><br><span class="line">k2.height = Math.max(height(k2.left), height(k2.right)) + 1;</span><br><span class="line">k1.height = Math.max(height(k1.left), height(k1.right)) + 1;</span><br><span class="line">return k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上balance()平衡方法和平衡被破坏后四种调整策略的代码是AVL树中的核心部分。<font color="red">对于LR调整和RL调整最后重新确定高度的时候，由于将k2作为根节点，所以一定要注意确定的顺序。先确定k2的左右子树高度，最后确定k2高度。</font>LL调整和RR调整同理，最后确定调整后根节点的高度。</p><ol start="4"><li><font color="blue"><b>insert(T x)</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向AVL树中插入节点</span><br><span class="line"> * @param x 插入的节点值</span><br><span class="line"> */</span><br><span class="line">public void insert(T x) &#123;</span><br><span class="line">root=insert(x, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=============================================”</span><br><span class="line"></span><br><span class="line">private AvlNode&lt;T&gt; insert(T x, AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t == null)</span><br><span class="line">return new AvlNode&lt;T&gt;(x, null, null);</span><br><span class="line">int CompareResult = x.compareTo(t.ele);</span><br><span class="line">if (CompareResult &lt; 0 ) &#123;</span><br><span class="line">t.left = insert(x, t.left);</span><br><span class="line">&#125; else if (CompareResult &gt; 0) &#123;</span><br><span class="line">t.right = insert(x, t.right);</span><br><span class="line">&#125;</span><br><span class="line">return balance(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>对于AVL树的插入，和二叉查找树的插入过程一摸一样，只是每插入一个节点，要<font color="red">对插入节点到根节点路径上的所有节点进行平衡调整。</font></p><ol start="5"><li><font color="blue"><b>remove(T x)</b></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从AVL树中删除节点</span><br><span class="line"> * @param x 删除的节点值</span><br><span class="line"> */</span><br><span class="line">public void remove(T x) &#123;</span><br><span class="line">root = remove(x, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;==============================================================&quot;</span><br><span class="line"></span><br><span class="line">private AvlNode&lt;T&gt; remove(T ele,AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">//如果当前节点为空，说明树中不存在要删除的节点值，直接返回</span><br><span class="line">if (t == null)</span><br><span class="line">return t;</span><br><span class="line">//将当前节点值和删除值比较</span><br><span class="line">int res = ele.compareTo(t.ele);</span><br><span class="line">//删除值大于当前节点值，向节点的右子树查询</span><br><span class="line">if (res &lt; 0) &#123;</span><br><span class="line">t.left = remove(ele, t.left);</span><br><span class="line">&#125;</span><br><span class="line">//删除值小于当前节点值，向节点的左子树查询</span><br><span class="line">else if (res &gt; 0) &#123;</span><br><span class="line">t.right= remove(ele, t.right);</span><br><span class="line">&#125;</span><br><span class="line">//找到要删除的节点</span><br><span class="line">//如果要删除的节点左右子树都不为空，</span><br><span class="line">//那么就将该节点右子树中最小的值代替当前节点的值并递归删除右子树中最小的值</span><br><span class="line">else if (t.left != null &amp;&amp; t.right != null) &#123;</span><br><span class="line">t.ele = finMin(t.right).ele;</span><br><span class="line">t.right = remove(t.ele, t.right);</span><br><span class="line">&#125;</span><br><span class="line">//如果要删除的节点左右子树有一个或两个不存在，直接删除</span><br><span class="line">else</span><br><span class="line">t = (t.left != null) ? t.left : t.right;</span><br><span class="line">//每次删除后重新对AVL树进行调整</span><br><span class="line"></span><br><span class="line">return balance(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“===========================================================”</span><br><span class="line"></span><br><span class="line">private AvlNode&lt;T&gt; finMin(AvlNode&lt;T&gt; t) &#123;</span><br><span class="line">if (t.left == null) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">return finMin(t.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>对于删除节点，无疑更为麻烦。但是就像插入方法一样。我们<font color="red">使用二叉查找树的删除方法，最后不直接返回t，而是对删除节点到根节点上的每一个节点进行平衡调整后再返回，即返回balance(t)</font>，这是可行的！<br>为了证明可行，下面推导一种删除后需要LL调整的情形：<br><img src="/2019/10/18/数据结构-树/7.png" alt>对于需要RR调整和另外两种调整的情形类似。</p><hr>二叉查找树和AVL树介绍告一段落，对于树要学的还有很多。另外可以发现，树相关的问题大多可以用递归来解决，因此能够理解并运用递归非常重要。(参考书籍：数据结构和算法分析(Java语言描述)》)]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 递归 </tag>
            
            <tag> AVL树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉查找树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想之内部类</title>
      <link href="/2019/10/14/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/10/14/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>可以将一个类的定义放在另一个类的定义内部，这就是内部类，Java的内部类用者很多妙用和特性。但对于内部类，总是有一些不明白的地方，最近看了书，算是有所收获，来记录一下内部类相关知识。</p><hr><a id="more"></a><p>内部类主要分为一下几种(还有一些接口内部类省略)</p><ol><li><b>非静态内部类</b><ol><li>普通内部类</li><li>局部内部类</li><li>匿名内部类(前面介绍工厂模式用过，这里不赘述)</li></ol></li><li><b>静态内部类(嵌套类)</b></li></ol><h1 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h1><ul><li><p><font color="blue"><b>非静态内部类的创建</b></font><br>非静态内部类的创建必须依赖于其外部类(稍后会说到为什么)，对于非静态内部类而言，在拥有外部类对象之前是不可能创建内部类对象的。</p></li><li><p><font color="blue"><b>创建内部类对象格式</b></font><br><font color="red"><b>外部类名.内部类名 内部类对象名=外部类对象.new 内部类名()</b></font></p></li><li><p><font color="blue"><b>指向外部类的引用</b></font><br>在内部类中，使用<font color="blue"><b>外部类.this</b></font>可以获取对外部类对象的引用。直接使用this就是对自身的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//外部类</span><br><span class="line">public class DoThis &#123;</span><br><span class="line">    void f() &#123;</span><br><span class="line">        System.out.println(&quot;DoThis.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//DoThis类的内部类</span><br><span class="line">    public class Inner&#123;</span><br><span class="line">//返回对外部类对象的引用</span><br><span class="line">        public DoThis outer() &#123;</span><br><span class="line">            //通过外部类名.this获取外部类对象的引用</span><br><span class="line">            return DoThis.this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//先创建外部类对象</span><br><span class="line">        DoThis dt=new DoThis();</span><br><span class="line">通过外部类对象创建内部类对象</span><br><span class="line">        DoThis.Inner inner = dt.new Inner();</span><br><span class="line">        DoThis outer = inner.outer();</span><br><span class="line">        System.out.println(outer == dt);      //两个引用指向同一个对象，因此返回true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>内部类对象和外部类对象的关系</b></font><br>当生成一个内部类对象时，该对象与制造它的外部类对象之间存在着一种联系，它能够无条件的访问其外部类对象的所有成员。内部类自动拥有对其外围类所有成员的访问权，这是如何做到的呢？<br><font color="red">当某个外部类对象创建了一个内部类对象时，该内部类对象会自动获取一个指向该外部类对象的引用。然后在使用内部类来访问外部类的成员时，就会使用那个引用来操作。</font><br>因为内部类中会有一个指向外部类对象的引用，因此内部类对象的创建必须依靠外部类对象，否则无法获取到该引用。</p></li><li><p><font color="blue"><b>局部内部类</b></font><br>在一个方法的作用域内(而不是在类内)创建一个完整的类，这被称为局部内部类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel6 &#123;</span><br><span class="line">    private void inter(boolean b) &#123;</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            //该类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实和别的类一起编译过了，</span><br><span class="line">            // 然而在定义该类的作用域之外，他是不可用的。除此之外，它与普通的类一样</span><br><span class="line">            class Tracking&#123;</span><br><span class="line">                private String id;</span><br><span class="line"></span><br><span class="line">                Tracking(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String get() &#123;</span><br><span class="line">                    return id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Tracking t = new Tracking(&quot;局部内部类&quot;);</span><br><span class="line">            System.out.println(t.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//在方法之外无法访问Tracking类</span><br><span class="line">//Tracking t = new Tracking(&quot;局部内部类&quot;);</span><br><span class="line"></span><br><span class="line">    public void track() &#123;</span><br><span class="line">        inter(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel6 p=new Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意，<font color="blue">上面代码中Tracking类是一个局部内部类，它是inter(boolean b)方法的一部分，而不是Parcel6类的一部分。所以，在方法之外不能访问该内部类。</font></p><h1 id="静态内部类-嵌套类"><a href="#静态内部类-嵌套类" class="headerlink" title="静态内部类(嵌套类)"></a>静态内部类(嵌套类)</h1><p>如果不需要内部类对象和其外部类对象之间的引用关系，可以将类声明为static，这通常称为嵌套类。需要牢记：普通内部类(包括局部内部类)对象隐式的保存了一个引用，指向创建它的外部类对象，而static不存在这个引用。<br>这也就是说，嵌套类的创建不需要依赖于外部类的对象。</p><ul><li><p><font color="blue"><b>嵌套类创建</b></font><br><font color="red">外部类名.内部类名 对象名=new 内部类名()</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//外部类</span><br><span class="line">public class Practice18 &#123;</span><br><span class="line">//内部类</span><br><span class="line">    protected static class Inner&#123;</span><br><span class="line">        public void show() &#123;</span><br><span class="line">            System.out.println(&quot;你好，嵌套类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //对于嵌套类(静态内部类)，不需要创建其外围类对象啊，通过外围类名可以直接调用</span><br><span class="line">        Practice18.Inner inner = new Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>多层类的嵌套</b></font><br>一个内部类被嵌套多少层并不重要，他能透明的访问所有它嵌入的外围类的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//最外围类</span><br><span class="line">public class Practice20 &#123;</span><br><span class="line">    //创建内部类对象</span><br><span class="line">    Practice20.Innerclass1 innerclass1=new Innerclass1();</span><br><span class="line"></span><br><span class="line">    //创建内部类的内部类对象</span><br><span class="line">    Practice20.Innerclass1.Innerclass2 innerclass2=innerclass1.new Innerclass2();</span><br><span class="line"></span><br><span class="line">    private void show() &#123;</span><br><span class="line">        System.out.println(&quot;Practice20.show()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //内部类</span><br><span class="line">    private class Innerclass1&#123;</span><br><span class="line">        //创建内部类对象</span><br><span class="line">        Innerclass1.Innerclass2 innerclass2 = new Innerclass2();</span><br><span class="line"></span><br><span class="line">        private void show() &#123;</span><br><span class="line"></span><br><span class="line">            //对外围类的引用</span><br><span class="line">            Practice20.this.show();</span><br><span class="line">            System.out.println(&quot;Innerclass1.show()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //内部类的内部类</span><br><span class="line">        private class Innerclass2&#123;</span><br><span class="line">            private void show() &#123;</span><br><span class="line"></span><br><span class="line">                //对最外围类的引用</span><br><span class="line">                Practice20.this.show();</span><br><span class="line"></span><br><span class="line">                //对外围类的引用</span><br><span class="line">                Innerclass1.this.show();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;Innerclass2.show()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//创建最外部类对象</span><br><span class="line">        Practice20 p=new Practice20();</span><br><span class="line">        p.show();</span><br><span class="line">        System.out.println(&quot;===============&quot;);</span><br><span class="line">//通过最外部类对象创建其内部类对象</span><br><span class="line">        Practice20.Innerclass1 innerclass1 = p.new Innerclass1();</span><br><span class="line">        innerclass1.show();</span><br><span class="line">        System.out.println(&quot;===============&quot;);</span><br><span class="line">//通过内部类对象创建内部类的内部类对象</span><br><span class="line">        Practice20.Innerclass1.Innerclass2 innerclass2=innerclass1.new Innerclass2();</span><br><span class="line">        innerclass2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当出现下列情况，即<font color="red"><b>子类和父类不在一个包下时，子类如果想创建父类内部类的对象，那么父类的内部类构造器必须为public，否则子类无法访问到父类内部类的构造器。</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Pricitice6有一个protected修饰的内部类，如果不显式指明，其构造方法也是protected的</span><br><span class="line">public class Pricitice6 &#123;</span><br><span class="line">    protected class Inner implements inter&#123;</span><br><span class="line">//显式指明public构造方法</span><br><span class="line">public Inner() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void show() &#123;</span><br><span class="line">            System.out.println(&quot;内部类实现的接口&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================================================</span><br><span class="line">//在另一个包下，有Pricitice6的一个子类Pricitice6Test</span><br><span class="line">public class Pricitice6Test extends Pricitice6 &#123;</span><br><span class="line">    public inter geta() &#123;</span><br><span class="line">//在另一个包下，如果想要创建其父类的内部类对象，那么要求该内部类的构造方法必须是public</span><br><span class="line">//否则子类无法访问到其父类内部类的构造器(因为不在一个包下)</span><br><span class="line">        return new Inner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pricitice6Test p=new Pricitice6Test();</span><br><span class="line">        Pricitice6Test.Inner inner=p.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2019/10/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍工厂模式的两种实现方式：即接口实现和匿名内部类实现。在介绍工厂模式之前，会先对接口的一些细节性知识做一个记录和小结。</p><hr><a id="more"></a><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li><p><font color="blue"><b>接口的访问权限</b></font></p><ul><li><b>public</b><br>公共接口，所有类都能访问</li><li><b>default</b><br>包访问权限，只有同一个包内的类可以访问</li></ul></li><li><p><font color="blue"><b>接口的变量</b></font><br>可以含有变量，但是接口中的变量默认都是sttaic final public修饰，即接口中只有常量。</p></li><li><p><font color="blue"><b>接口的方法</b></font><br>对于接口中的方法可以显式的声明为public，也可以不声明，接口中的方法默认是public的。因此当实现一个接口时，在接口中被定义的方法必须为public，否则会报错。接口中可以有三种方法</p><ul><li><p><b>默认方法(default修饰)</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 接口方法和父类方法参数列表和返回值一样，那么&quot;类优先原则&quot;，使用父类方法</span><br><span class="line">interface inter3&#123;</span><br><span class="line">default void show() &#123;</span><br><span class="line">System.out.println(&quot;接口方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class sub extends classDefault implements inter3 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class classDefault &#123;</span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;父类方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">sub s=new sub();</span><br><span class="line">s.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Output：</span><br><span class="line">父类方法</span><br><span class="line"></span><br><span class="line">2. 接口方法和父类方法参数列表不同时，构成重载</span><br><span class="line">3. 接口方法和父类方法参数列表一样，返回值不一样时，报错，因为返回值不同不构成重载。</span><br></pre></td></tr></table></figure></li><li><p><b>抽象方法(没有方法体)</b></p></li><li><p><b>静态方法</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JDK8中，添加了静态方法</span><br><span class="line">interface inter3&#123;</span><br><span class="line">static void show() &#123;</span><br><span class="line">System.out.println(&quot;接口方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class sub extends classDefault implements inter3 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class classDefault &#123;</span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;父类方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">sub s=new sub();</span><br><span class="line">s.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">同样的，也是类优先原则。不同的是，接口中的静态方法和类一样，可以使用接口直接调用。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="工厂模式-接口"><a href="#工厂模式-接口" class="headerlink" title="工厂模式(接口)"></a>工厂模式(接口)</h1><ol><li>需要两个接口，一个是工厂接口，一个是想要的实现类接口(比如这里最后想要得到Animal对象，那就创建一个Animal接口)</li><li>创建不同的类来实现Animal。这里我想要一个狗和一个猫，那我就分别创建两个类来实现Animal接口。<br>如果还想要别的动物，那就创建再创建类来实现Animal接口。</li><li>为每一个实现类创建一个单独的工厂类，每一个工厂类都实现工厂接口。这样通过不同的工厂类就能够得到不同的动物实现类。</li><li>最后只需要传入相应的工厂类即可得到不同的Animal实现类，即得到不同的动物。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Animal接口</span><br><span class="line">interface Animal&#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂接口</span><br><span class="line">interface AnimalFactory&#123;</span><br><span class="line">    Animal getAnimal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Animal接口实现类--Dog</span><br><span class="line">class Dog implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(this.getClass().getSimpleName() + &quot; eat meet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Animal接口实现类--Cat</span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(this.getClass().getSimpleName() + &quot; eat fish&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相应实现类的工厂实现类</span><br><span class="line">class DogFactory implements AnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Animal getAnimal() &#123;</span><br><span class="line">        return new Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相应实现类的工厂实现类</span><br><span class="line">class CatFactory implements AnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Animal getAnimal() &#123;</span><br><span class="line">        return new Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Factories &#123;</span><br><span class="line">    //静态方法，返回Animal接口的实现类(多态)</span><br><span class="line">    public static Animal CreateAnimal(AnimalFactory factory) &#123;</span><br><span class="line">        return factory.getAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Factories.CreateAnimal(new DogFactory()).eat();</span><br><span class="line">        Factories.CreateAnimal(new CatFactory()).eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Output：</span><br><span class="line">Dog eat meet</span><br><span class="line">Cat eat fish</span><br></pre></td></tr></table></figure></li></ol><h1 id="工厂模式-匿名内部类-Lambda表达式"><a href="#工厂模式-匿名内部类-Lambda表达式" class="headerlink" title="工厂模式(匿名内部类+Lambda表达式)"></a>工厂模式(匿名内部类+Lambda表达式)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//Animal接口</span><br><span class="line">interface Animal&#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂接口</span><br><span class="line">interface AnimalFactory&#123;</span><br><span class="line">    Animal getAnimal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Animal接口实现类--Dog</span><br><span class="line">class Dog implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(this.getClass().getSimpleName() + &quot; eat meet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">//使用匿名内部类实现工厂接口</span><br><span class="line">    public static AnimalFactory factory = () -&gt; new Dog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Animal接口实现类--Cat</span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(this.getClass().getSimpleName() + &quot; eat fish&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">//使用匿名内部类实现工厂接口</span><br><span class="line">    public static AnimalFactory factory = () -&gt; new Cat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Factories &#123;</span><br><span class="line">    //静态方法，返回Animal接口的实现类(多态)</span><br><span class="line">    public static Animal CreateAnimal(AnimalFactory factory) &#123;</span><br><span class="line">        return factory.getAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//调用不同Animal实现类的类变量作为参数传入</span><br><span class="line">        Factories.CreateAnimal(Dog.factory).eat();</span><br><span class="line">        Factories.CreateAnimal(Dog.factory).eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">Dog eat meet</span><br><span class="line">Cat eat fish</span><br></pre></td></tr></table></figure><p>这种方式不同为每一个Animal实现类单独创建一个工厂实现类，而是以匿名内部类的方式实现工厂接口并作为相应动物类的静态变量，看起来更为优雅简单。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 接口 </tag>
            
            <tag> 匿名内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简单的LinkedList集合</title>
      <link href="/2019/10/13/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84LinkedList%E9%9B%86%E5%90%88/"/>
      <url>/2019/10/13/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84LinkedList%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>前面介绍了一个简单了AyyayList集合，现在来继续整个复杂一点的，那就是双向链表组成的LinkedList集合。</p><hr><a id="more"></a><h1 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h1><p>集合底层是一个带头节点和尾节点的双向链表，主要步骤和完成的功能</p><ol><li>创建一个节点类，可以是一个私有的嵌套类</li><li>创建一个链表类</li><li>一个私有的内部类实现了Iterator接口，作为迭代器</li><li>实现的接口方法<ol><li>isEmpty()、clear()、size()等基础方法</li><li>add()方法几种重载形式、get()方法</li><li>set()方法、remove()方法</li></ol></li><li>内部方法<br>我们知道，当我们在使用链表进行操作的时候，输入的总是值或者是index位置，但是实际上我们需要通过位置来定位到链表中具体的节点从而对链表进行操作。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ConcurrentModificationException;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line">public class MyLinkedList&lt;T&gt; implements Iterable&lt;T&gt; &#123;</span><br><span class="line">    //记录元素个数</span><br><span class="line">    private int size = 0;</span><br><span class="line">    //分为指向头节点和为尾节点</span><br><span class="line">    private Node&lt;T&gt; first;</span><br><span class="line">    private Node&lt;T&gt; last;</span><br><span class="line">    //用于判断迭代器是否过时</span><br><span class="line">    private int modeCount = 0;</span><br><span class="line"></span><br><span class="line">    //节点类</span><br><span class="line">    private static class Node&lt;T&gt;&#123;</span><br><span class="line">        private Node&lt;T&gt; pre;</span><br><span class="line">        private Node&lt;T&gt; next;</span><br><span class="line">        private T d;</span><br><span class="line">        //构造方法</span><br><span class="line">        public Node(T ele, Node p, Node n) &#123;</span><br><span class="line">            d = ele;</span><br><span class="line">            this.pre = p;</span><br><span class="line">            this.next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //以下为接口方法</span><br><span class="line">    /*=========================================*/</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     */</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        doclear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空集合</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        doclear();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建带头节点的链表</span><br><span class="line">     */</span><br><span class="line">    public void doclear() &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        first = new Node&lt;&gt;(null, null, null);</span><br><span class="line">        last = new Node&lt;&gt;(null, first, null);</span><br><span class="line">        first.next = last;</span><br><span class="line">        modeCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为空</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size() == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回集合元素个数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return this.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除指定位置元素</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public T remove(int index) &#123;</span><br><span class="line">        return remove(getNode(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改指定位置元素的值</span><br><span class="line">     * @param index</span><br><span class="line">     * @param val</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public T set(int index, T val) &#123;</span><br><span class="line">        Node&lt;T&gt; p = getNode(index);</span><br><span class="line">        T oldValue = p.d;</span><br><span class="line">        p.d = val;</span><br><span class="line">        return oldValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定位置添加元素</span><br><span class="line">     * @param index</span><br><span class="line">     * @param x</span><br><span class="line">     */</span><br><span class="line">    public void add(int index, T x) &#123;</span><br><span class="line">        addBefore(getNode(index, 0, size()), x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认尾添加</span><br><span class="line">     * @param ele</span><br><span class="line">     */</span><br><span class="line">    public void add(T ele) &#123;</span><br><span class="line">        add(size(), ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定位置的元素</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line">        return getNode(index).d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个迭代器，用于遍历链表</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        return new LinkedListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以下为内部方法</span><br><span class="line">    /*===========================================*/</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 内部方法</span><br><span class="line">     * @param p</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private T remove(Node&lt;T&gt; p) &#123;</span><br><span class="line">        T ele = p.d;</span><br><span class="line">        p.pre.next = p.next;</span><br><span class="line">        p.next.pre = p.pre;</span><br><span class="line">        size--;</span><br><span class="line">        modeCount++;</span><br><span class="line">        return ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定索引元素值</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node&lt;T&gt; getNode(int index) &#123;</span><br><span class="line">        return getNode(index, 0, size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回指定索引元素节点</span><br><span class="line">     * @param index</span><br><span class="line">     * @param lower</span><br><span class="line">     * @param upper</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node&lt;T&gt; getNode(int index, int lower, int upper) &#123;</span><br><span class="line">        Node&lt;T&gt; p;</span><br><span class="line">        if (index &lt; lower || index &gt; upper) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; size() / 2) &#123;</span><br><span class="line">            p = first.next;</span><br><span class="line">            for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            p = last;</span><br><span class="line">            for (int i = size(); i &gt; index; i--) &#123;</span><br><span class="line">                p = p.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入到指定节点前面</span><br><span class="line">     * @param p</span><br><span class="line">     * @param ele</span><br><span class="line">     */</span><br><span class="line">    private void addBefore(Node&lt;T&gt; p, T ele) &#123;</span><br><span class="line">        p.pre = p.pre.next = new Node(ele, p.pre, p);</span><br><span class="line">        size++;</span><br><span class="line">        modeCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //私有内部类，实现Iterator接口，用作迭代器</span><br><span class="line">    private class LinkedListIterator implements Iterator&lt;T&gt; &#123;</span><br><span class="line">        private Node&lt;T&gt; current = first.next;</span><br><span class="line">        private int expCount = modeCount;</span><br><span class="line">        private boolean canRemove = false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return current!=last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public T next() &#123;</span><br><span class="line">            if (modeCount != expCount) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            if (!hasNext()) &#123;</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            T ele = current.d;</span><br><span class="line">            current = current.next;</span><br><span class="line">            canRemove = true;</span><br><span class="line">            return ele;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (expCount != modeCount) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            if (!canRemove) &#123;</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            MyLinkedList.this.remove(current.pre);</span><br><span class="line">            expCount++;</span><br><span class="line">            canRemove = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>一个简单地双向链表实现的LinkedList集合就完成了，其实难度并不高，但是在上手之前，最好先明确自己要实现什么功能(也就是实现几个接口方法)，有了大方向之后在动手实现就会事半功倍。]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想之final和多态</title>
      <link href="/2019/10/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8Bfinal%E5%92%8C%E5%A4%9A%E6%80%81/"/>
      <url>/2019/10/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8Bfinal%E5%92%8C%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>多态是Java语言面向对象的三大特征之一，也是Java很有特色的部分。这里对于多态的基本知识不做赘述，主要关注多态的一些细节知识。</p><hr><a id="more"></a><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final通常指的是”这是不可变的”，它可以用来修饰数据、方法、类，下面就分别谈谈这三种用法</p><ul><li><p><font color="blue">final数据<b></b></font></p><ul><li><b>final修饰基本数据类型</b><br>表示该变量不可改变，在对这个常量定义的时候，必须对其进行赋值。一个既是final又是static的字段只占据一块不可改变的空间，通常被称为编译期常量。</li><li><b>final修饰对象引用</b><br>表示该对象引用不能再指向其他的对象，即引用指向不可变，但是对象自身数据却是可以改变的。</li><li><b>final数据的初始化</b><br>对于final字段(成员变量)，<font color="red">要么在定义时初始化，要么在构造器中对其进行初始化</font>。这保证了final字段在使用前总被初始化</li><li><b>final参数</b><br>Java允许在方法的参数列表中以声明的方式将参数指明为final，这就表示无法在方法中改变参数的值或参数引用所指向的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void f(final int i) &#123;</span><br><span class="line">//无法对i重新赋值</span><br><span class="line">       //i = 0;</span><br><span class="line">       System.out.println(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><font color="blue">final方法<b></b></font><br>使用final方法主要是为了把方法锁定，以防止任何继承类修改它的含义，即确保在继承中使方法的行为保持不变，且不会被覆盖</p><ul><li><b>final和private关键字</b><br><font color="blue">类中所有的private关键字都隐式的指定为final</font>。因为你无法取用private方法，自然也就无法覆盖它。<br>对于final和private，稍后会在多态提到</li></ul></li><li><p><font color="blue">final类<b></b></font><br>当一个类整体定义为final时，该类就不可被继承，但是final类的字段可以不是final。对于final类中的方法，因为final类是不可被继承的，因此final类的所有方法都不能被覆盖，因此这些方法都隐式的被指定为final。</p></li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>Java中除了static和final方法(private属于final方法)，其他所有方法都是后期绑定。由于static和final方法在编译期进行了解析，那么也就不存在多态，因此可以得出结论：static、private、final修饰的方法不存在多态。</p><ol><li>static方法是属于类的方法，对于所有的对象不会有不同的行为</li><li>final方法和private方法不能被重写覆盖，自然也就不会产生多态了</li></ol><ul><li><font color="blue"><b>不能覆盖私有方法</b></font><br>下面一段代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BB extends PrivateTest&#123;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;privateOverride&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PrivateTest &#123;</span><br><span class="line">    private void show() &#123;</span><br><span class="line">        System.out.println(&quot;private f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PrivateTest p = new BB();</span><br><span class="line">        p.show();</span><br><span class="line">        BB b=new BB();</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">Output：</span><br><span class="line">private f()</span><br><span class="line">privateOverride</span><br></pre></td></tr></table></figure></li></ul><p>测试可以看出，private方法并没有被覆盖，即<font color="red">父类的private修饰的show()方法对子类是屏蔽的，子类的show()方法相当于是一个全新的方法。</font></p><ul><li><font color="blue"><b>不能覆盖字段</b></font><br>下面一段代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Div extends FinalField&#123;</span><br><span class="line">    public int field = 1;</span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FinalField &#123;</span><br><span class="line">    public int field = 0;</span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FinalField f = new Div();</span><br><span class="line">        //父类的field字段</span><br><span class="line">        System.out.println(f.field);</span><br><span class="line">        //子类的getField方法，返回子类的field字段</span><br><span class="line">        System.out.println(f.getField());</span><br><span class="line">        Div d=new Div();</span><br><span class="line">        //子类的field字段</span><br><span class="line">        System.out.println(d.field);</span><br><span class="line">        //子类的getField方法</span><br><span class="line">        System.out.println(d.getField());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">Output：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li></ul><p><font color="red">当Div对象(子类对象)向上转型为父类对象时，任何字段访问操作都将由编译器解析，因此不是多态的</font>。可以这么理解，在子类对象中，为父类和子类的field字段分配了两块不同的空间。所以在使用时，不建议给父类和子类字段取相同的名字。</p><ul><li><font color="blue"><b>构造器内部的多态</b></font><br>下面一段代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class AAA &#123;</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        System.out.println(&quot;father.draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AAA() &#123;</span><br><span class="line">        System.out.println(&quot;father.draw() before&quot;);</span><br><span class="line">//父类构造器调用了draw()方法</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(&quot;father.draw() after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBB extends AAA&#123;</span><br><span class="line">    private int i = 1;</span><br><span class="line"></span><br><span class="line">    BBB(int i) &#123;</span><br><span class="line">//子类构造器首先执行父类构造器</span><br><span class="line">        this.i = i;</span><br><span class="line">        System.out.println(&quot;BBB+&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void draw() &#123;</span><br><span class="line">        System.out.println(&quot;son.draw():&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PolyConstructors &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BBB b = new BBB(5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============</span><br><span class="line">Output：</span><br><span class="line">father.draw() before</span><br><span class="line">son.draw():0</span><br><span class="line">father.draw() after</span><br><span class="line">BBB+5</span><br></pre></td></tr></table></figure></li></ul><p>在上面这段测试中，子类BBB重写了父类的draw方法。在创建子类对象时，会先执行父类的构造器。那么在父类构造器中调用的肯定是子类的draw方法(多态)，这没有问题。但是我们在创建子类对象时期望的是son.draw():5而不是son.draw():0，因为我们传递的i的参数为i=5，这就出现了错误。<br>这是因为，<font color="red">在所有代码执行之前，虚拟机会将分配给对象的空间初始化成二进制0(JVM虚拟机中讲到过)，而父类构造器中执行draw方法时，子类对i的赋值还没有进行，此时i仍是初始化的0，这样就出现了问题。</font></p>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想之复用类</title>
      <link href="/2019/10/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2019/10/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>这次主要介绍一下访问权限修饰符的一些细节和复用类的几种方法</p><hr><a id="more"></a><h1 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h1><p>我们都知道，Java中有四种访问权限修饰符，它们从大到小依次为<font color="red">public-&gt;protected-&gt;包访问权限(没有关键字)-&gt;private</font>。</p><ol><li>为什么要设置访问权限控制？<br>当你编写一个代码给别人用的时候(例如写一个类库，后面假设就是类库)，你可能会发现类库中的某些代码或者方法有更好的实现方式，因此你可能需要对代码进行反复修改。举个例子，JDK7中的HashMap使用的是数据+链表实现，后来发现链表较长时效率不高，因此就改成了数组+链表+红黑树实现。<br>但是你在修改代码的过程中，你需要确保使用你类库的人不会因为你改动的这些代码而受到影响。这很容易理解，别人可能正在用你的一些方法，而你把这个方法删掉了，那么别人的代码就用不了了。这时候，你就需要确认那些地方是类库使用者用不到的，那些地方是使用者正在使用的。因此Java就提供了访问权限控制，供类库开发人员向使用者指明哪些是可用的，哪些是不可用的。这样就很容易的知道你能够改动哪些部分而不会影响别人的使用。</li></ol><p>总的来说，控制对成员的访问权想有两个原因<br>    1. 为了使用户不要触碰那些它们不该触碰的部分，这些部分对类的内部操作是必要的，但是并不属于使用者所需要接口的一部分<br>    2. 也是最重要的，<font color="blue">为了让类库设计者可以更改类的内部工作方式而不必担心这样会对使用者产生重大影响</font></p><h1 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h1><ul><li><p><font color="bllue"><b>组合语法(has-a关系)</b></font><br>实现很简单，只需要在新的类中产生现有类的对象，由于新的类是由现有类的对象组成，所以这种方法成为组合。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ClassTest&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class combimation &#123;</span><br><span class="line">    //在新类中产生ClassTest类对象和String类对象</span><br><span class="line">    private ClassTest c = new ClassTest();</span><br><span class="line">    private String s = &quot;abc&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="bllue"><b>继承语法(is-a关系)</b></font><br><font color="blue">子类继承父类时，会自动得到<b>父类所有的字段和方法</b>(即得到父类所有的部分)，这里也包括private修饰的字段和方法，只是子类不能够直接访问这些private字段和方法。但是可以通过反射来访问。</font></p><ul><li>初始化父类<br>当创建一个子类对象时，该子类对象包含了一个父类的子对象，这个子对象和你直接用父类创建的对象是一摸一样的。两者的区别在于直接用父类创建的对象在外部，而子对象被包裹在子类对象的内部。<br>因此，在初始化子类对象时，对子类对象中的父类子对象的初始化是至关重要的。即<font color="red">在子类构造器中调用基类构造器来执行对子对象的初始化，如果没有写，编译器会自动在<b>子类构造器第一行</b>加上对父类无参构造器的调用(super())。</font></li></ul></li></ul><p>注意：在构造器中，<font color="red">super和this关键字不能同时使用，因为两者都必须位于第一行</font>。但是如果只写this来调用子类其他构造方法，编译器会自动添加对父类无参构造方法的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ClassTest&#123;</span><br><span class="line">    ClassTest() &#123;</span><br><span class="line">        System.out.println(&quot;父类构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassSon extends ClassTest&#123;</span><br><span class="line">    ClassSon() &#123;</span><br><span class="line">        System.out.println(&quot;子类构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassSon(int i) &#123;</span><br><span class="line">//      super();同时写super和this会编译报错</span><br><span class="line">        this();//只写一个this，编译器会隐式的添加对父类无参构造方法的调用</span><br><span class="line">//      super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Output：</span><br><span class="line">父类构造器</span><br><span class="line">子类构造器</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想之初始化与清理</title>
      <link href="/2019/10/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2019/10/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>为了巩固基础，特意找来了”Java圣经”之称的《Java编程思想》(第四版)来看，准备一边学习一边做笔记，虽然会慢一点，但是感觉会扎实一点。</p><hr><a id="more"></a><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>方法重载以及其底层原理在前面已经介绍过，就不多说。只需要记住，区分重载方法的规则很简单：<font color="red">每个重载方法都必须有一个独一无二的参数类型列表</font>。</p><ul><li><font color="bllue"><b>涉及基本类型的重载</b></font><br>基本类型能从一个”较小”的类型自动提升至一个”较大的类型”。即<br><font color="red">byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</font>。<br><b>对于char类型，会自动提升至int类型而不是short类型</b><br>如果传递的实际参数大于方法要求的参数，就必须进行显式类型转换，否则编译不通过。</li></ul><h1 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h1><p>一个类有多个不同的构造器，如果想要在一个构造器中调用另外一个构造器，可以使用this(通过传递参数调用不同的构造器)。但是，<font color="blue">this()部分必须位于构造器的第一行，这也就意味着尽管可以用this调用以恶搞构造器，但是只能调用一个。</font><br>并且，除了构造器外，不能在任何其他方法中调用构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class initTest &#123;</span><br><span class="line">    public initTest() &#123;</span><br><span class="line">        this(10);//this代码必须位于第一行</span><br><span class="line">        this(1, 9); //只能调用一次</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public initTest(int i) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public initTest(int a, int b) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h1><p>初始化顺序：</p><ol><li>父类静态部分(静态代码块和静态成员变量初始化顺序取决于代码上的顺序)</li><li>子类静态部分(静态代码块和静态成员变量初始化顺序取决于代码上的顺序)</li><li>父类非静态代码块和父类成员变量(初始化顺序取决于代码上的顺序)</li><li>父类构造方法</li><li>子类非静态代码块和子类成员变量(初始化顺序取决于代码上的顺序)</li><li>子类构造方法</li></ol><p><font color="red">类是在其任何static成员被访问时加载的(构造器是隐式的static)，静态变量和静态代码块只有在第一次创建对象时初始化一次。</font>这是因为静态部分在类加载过程中进行初始化(前面介绍过)，而类只加载一次，因此静态部分也就只初始化一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class staticfield&#123;</span><br><span class="line">    public staticfield(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Father&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;父类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static staticfield s=new staticfield(&quot;父类静态变量&quot;);</span><br><span class="line"></span><br><span class="line">    public Father() &#123;</span><br><span class="line">        System.out.println(&quot;Father 构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Father 普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private staticfield f=new staticfield(&quot;父类成员变量&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    private static staticfield s=new staticfield(&quot;子类静态变量&quot;);</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;子类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Son() &#123;</span><br><span class="line">        System.out.println(&quot;Son 构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private staticfield f=new staticfield(&quot;子类成员变量&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Son 普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class staticinit &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s=new Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================</span><br><span class="line">Output：</span><br><span class="line">父类静态代码块</span><br><span class="line">父类静态变量</span><br><span class="line"></span><br><span class="line">子类静态变量</span><br><span class="line">子类静态代码块</span><br><span class="line"></span><br><span class="line">Father 普通代码块</span><br><span class="line">父类成员变量</span><br><span class="line">Father 构造方法</span><br><span class="line"></span><br><span class="line">子类成员变量</span><br><span class="line">Son 普通代码块</span><br><span class="line">Son 构造方法</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简单ArrayList集合</title>
      <link href="/2019/10/11/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95ArrayList%E9%9B%86%E5%90%88/"/>
      <url>/2019/10/11/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95ArrayList%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>ArrayList集合是Java中最常用的集合类之一，是一个能够扩容的集合，它的底层维护的是一个数组。闲来无事，今天就手写一个简单地ArrayList集合吧。</p><hr><a id="more"></a><h1 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h1><ol><li>可以自动进行扩容，并允许回收老数组</li><li>实现get()和set方法</li><li>提供size()、isEmpty()和clear()方法以及remove()方法、两种不同的add()方法</li><li>能够使用迭代器Iterator</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">public class MyArrayList&lt;T&gt; implements Iterable&lt;T&gt;&#123;</span><br><span class="line">//初始容量，默认为10</span><br><span class="line">    private final int DEFAYLT_VALUE = 10;</span><br><span class="line">//集合中元素个数</span><br><span class="line">    private int size;</span><br><span class="line">//底层数组</span><br><span class="line">    private T[] Array;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     */</span><br><span class="line">    public MyArrayList() &#123;</span><br><span class="line">//无参构造方法，默认创建大小为10的集合</span><br><span class="line">        grow(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空集合</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        size=0;</span><br><span class="line">        grow(DEFAYLT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取元素个数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为空</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定元素</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line">//判断参数正确性</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        return Array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改指定元素</span><br><span class="line">     * @param index</span><br><span class="line">     * @param newValue</span><br><span class="line">     */</span><br><span class="line">    public void set(int index, T newValue) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        Array[index] = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加方法</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void add(T value) &#123;</span><br><span class="line">//默认将元素添加到末尾</span><br><span class="line">        add(size, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加方法</span><br><span class="line">     * @param index</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void add(int index, T value) &#123;</span><br><span class="line">//如果参数小于0，默认插到头部</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">//如果参数大于当前集合中元素个数，默认插到尾部</span><br><span class="line">        if (index &gt;= size) &#123;</span><br><span class="line">            index = size;</span><br><span class="line">        &#125;</span><br><span class="line">//如果集合满，那么就以2倍扩容</span><br><span class="line">//+1是为了防止出现0*2==0的情况</span><br><span class="line">        if (size == Array.length) &#123;</span><br><span class="line">            grow(Array.length * 2 + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = size; i &gt; index; i--) &#123;</span><br><span class="line">            Array[i] = Array[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        Array[index] = value;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T remove(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        T removeEle = Array[index];</span><br><span class="line">        for (int i = index; i &lt; size; i++) &#123;</span><br><span class="line">            Array[i] = Array[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        return removeEle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数组扩容</span><br><span class="line">     * @param newSize</span><br><span class="line">     */</span><br><span class="line">    private void grow(int newSize) &#123;</span><br><span class="line">        if (newSize &lt; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        T[] oldArr = Array;</span><br><span class="line">        Array = (T[]) new Object[newSize];</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            Array[i] = oldArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//由于容器实现了Iterable接口，所以要重写该方法，返回一个迭代器</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        return new ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//该类实现了Iterator接口，重写hasNext()、next()、remove()方法</span><br><span class="line">    private class ArrayListIterator implements Iterator&lt;T&gt; &#123;</span><br><span class="line">        private int cur=0;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cur &lt; size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public T next() &#123;</span><br><span class="line">            if (!hasNext()) &#123;</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            return Array[cur++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            MyArrayList.this.remove(--cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>这样，一个极其简化的ArrayList集合就写出来了。]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子序列和问题</title>
      <link href="/2019/10/11/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/11/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目：给定一个数组，在数组所有的子序列中找到和最大的子序列。我将用4中解法来对该题进行求解</p><hr><a id="more"></a><h1 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h1><ul><li><p><font color="blue"><b>算法思想</b></font><br>思路很简单，遍历数组所有的子序列，对每个子序列进行求和，找到最大的和并返回</p></li><li><p><font color="blue"><b>代码实现</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 暴力求解</span><br><span class="line"> * @param arr </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int maxSubSum(int[] arr) &#123;</span><br><span class="line">int maxsum=0;</span><br><span class="line">//遍历以数组中所有元素开头的子序列</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">//对于每个元素，以该元素开头的所有长度序列都要计算一次</span><br><span class="line">for (int j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">int thissum = 0;</span><br><span class="line">//计算序列和</span><br><span class="line">for (int k = i; k &lt;= j; k++) &#123;</span><br><span class="line">thissum += arr[k];</span><br><span class="line">&#125;</span><br><span class="line">if (maxsum &lt; thissum) &#123;</span><br><span class="line">maxsum = thissum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>时间复杂度</b></font><br>三重循环，所以时间复杂度为O(N3)</p></li></ul><h1 id="优化暴力求解"><a href="#优化暴力求解" class="headerlink" title="优化暴力求解"></a>优化暴力求解</h1><ul><li><p><font color="blue"><b>算法思想</b></font><br>我们需要知道，f(k+1)=k+f(k)，即对于一个子序列，该子序列的和，等于它前一个子序列的和加上一个元素得到。借此可以消除一层循环</p></li><li><p><font color="blue"><b>代码实现</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 优化暴力解法</span><br><span class="line"> * @param arr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int maxSubSum1(int[] arr) &#123;</span><br><span class="line">int maxsum=0;</span><br><span class="line">//同样的，遍历以每个元素开头的序列</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">int thissum = 0;</span><br><span class="line">//找到以arr[i]开头的所有序列中最大和序列</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">thissum += arr[j];</span><br><span class="line">if (maxsum &lt; thissum) &#123;</span><br><span class="line">maxsum = thissum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>时间复杂度</b></font><br>双重循环，时间复杂度为O(N2)</p></li></ul><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><ul><li><font color="blue"><b>算法思想</b></font><br>分治的思想就是把问题分成两个大致相等的子问题，然后递归对它们进行求解这就是”分”；”治”阶段将两个子问题的解修补到一起并可能再做一些少量步骤的附加工作，最后得到整个问题的解。<br>对于这个题，最大子序列可能在三处出现</li></ul><ol><li>该子序列全部位于数组的左边</li><li>改子序列全部位于数组的右边</li><li>该子序列跨越数组中部，即一部分在左边一部分在右边</li></ol><p>因此我们可以进行分治递归求解</p><ul><li><p><font color="blue"><b>代码实现</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分治算法</span><br><span class="line"> * @param arr</span><br><span class="line"> * @param left 初始值为0</span><br><span class="line"> * @param right 初始值为arr.length-1</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int maxSubRec(int[] arr, int left, int right) &#123;</span><br><span class="line">//递归出口，当左边界等于右边界时只有一个数，直接返回</span><br><span class="line">if (left == right) &#123;</span><br><span class="line">return arr[left];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int center = (left + right) / 2;</span><br><span class="line">//左递归，求出数组左边部分最大子序列</span><br><span class="line">int leftsum = maxSubRec(arr, left, center);</span><br><span class="line">//右递归，求出数组右边部分最大子序列</span><br><span class="line">int rightsum = maxSubRec(arr, center + 1, right);</span><br><span class="line"></span><br><span class="line">//求出跨越数组中部的子序列左边部分的最大值</span><br><span class="line">int leftbordersum = arr[center];</span><br><span class="line">int maxleftborder = arr[center];</span><br><span class="line">for (int i = center - 1; i &gt;= left; i--) &#123;</span><br><span class="line">maxleftborder += arr[i];</span><br><span class="line">if (leftbordersum &lt; maxleftborder) &#123;</span><br><span class="line">leftbordersum = maxleftborder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求出跨越数组中部的子序列右边部分的最大值</span><br><span class="line">int rightbordersum = arr[center + 1];</span><br><span class="line">int maxrightborder = arr[center + 1];</span><br><span class="line">for (int i = center +2; i &lt;= right; i++) &#123;</span><br><span class="line">maxrightborder += arr[i];</span><br><span class="line">if (rightbordersum &lt; maxrightborder) &#123;</span><br><span class="line">rightbordersum = maxrightborder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//leftbordersum+rightbordersum即为数组中间部分的最大值</span><br><span class="line"></span><br><span class="line">//返回三者最大值，即为最大子序列和</span><br><span class="line">return Math.max(Math.max(leftsum, rightsum), leftbordersum + rightbordersum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color="blue"><b>时间复杂度</b></font><br>O(NlogN)</p></li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>我们需要知道，负数不可能是最大子序列的前缀，这不难理解，因为一个负数对于序列和没有任何增益效果反而会使得序列和变小。那么可以推广的到任何负序列也不可能是最大子序列的前缀。由此可以得到动态规划解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态规划</span><br><span class="line"> * 时间复杂度：O(n)</span><br><span class="line"> * @param arr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int maxSubSumdyn(int[] arr) &#123;</span><br><span class="line">int maxsum=0;</span><br><span class="line">int thissum = 0;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">thissum += arr[i];</span><br><span class="line">//当前最大子序列和小于当先序列和时，更新最大子序列和</span><br><span class="line">if (maxsum &lt; thissum) &#123;</span><br><span class="line">maxsum = thissum;</span><br><span class="line">&#125;</span><br><span class="line">//当thissum&lt;0时，说明当前子序列和为负，丢弃该子序列</span><br><span class="line">else if (thissum &lt; 0) &#123;</span><br><span class="line">thissum = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该算法中加了一个可以得到最大子序列左右边界的实现</span><br></pre></td></tr></table></figure><ul><li><font color="blue"><b>时间复杂度</b></font><br>很明显的。只有一重循环，复杂度为O(N)，是线性的</li></ul><hr>四种解法，动态规划法最优，个人感觉分治算法较为考验细节部分]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自顶向下之计算机网络和因特网-运输层</title>
      <link href="/2019/10/09/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2019/10/09/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层位于应用层和网络层之间，是分层网络体系结构的重要部分。该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。其中两个运输层协议TCP和UDP是本次介绍的重点。</p><hr><a id="more"></a><h1 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h1><h2 id="运输层介绍"><a href="#运输层介绍" class="headerlink" title="运输层介绍"></a><font size="5">运输层介绍</font></h2><p>运输层协议为运行在不同主机上的应用进程提供了<font color="blue">逻辑通信</font>功能。运输层协议是在端系统中而不是在路由器中实现的。</p><ul><li>在发送端，运输层将从应用程序接收到的报文转换成运输层分组(报文段)<ul><li>实现的方法是<font color="blue">将应用报文划分为较小的块，并为每块加上一个运输层首部从而生成运输层报文段</font></li><li>然后，在发送端系统中，<font color="blue">运输层将这些报文段传递到网络层，网络层将其封装为网络层分组(数据报)并向目的地发送</font></li></ul></li><li>在接收端，<font color="bllue">网络层从数据报中提取运输层报文段，并将该报文段上交给运输层</font><ul><li><font color="bllue">运输层则处理接收到的报文段，最后将其中的数据交给应用程序</font></li></ul></li></ul><p>通过上述过程可以明确：<font color="blue">网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的运输层报文段的字段。</font>事实上网络路由器并没有实现运输层协议。</p><h2 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a><font size="5">运输层和网络层的关系</font></h2><ul><li>在协议栈中，运输层位于网络层上面，网络层提供了<font color="red">主机之间的逻辑通信</font>，而运输层为运行在不同主机上的<font color="red">进程之间提供了逻辑通信</font></li><li>在端系统中，运输层协议将来自应用进程的报文移动到网络边缘(网络层)，反之亦然。但对有关这些报文在网络核心如何移动不做任何规定。中间路由器既不处理也不识别运输层加载应用层报文上的任何信息。</li><li><font color="blue">运输层能够提供的服务常常受制于网络层协议的服务模型。</font>如果网络层协议无法为主机之间发送的运输层报文段提供延时或带宽保证的话，那么运输层协议也就无法为进程之间发送的应用程序提供延时和带宽保证。</li><li>然而，即使底层网络协议不能再网络层提供相应的服务，运输层协议也能提供某些服务。例如，网络层IP协议是不可靠的，然而应用层协议TCP却是可靠的传输协议。</li></ul><h2 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a><font size="5">因特网运输层概述</font></h2><p>因特网运输层为应用层提供两种不同的运输层协议</p><ol><li>UDP协议，它提供了一种无连接的、不可靠的的服务</li><li>TCP协议，提供了一种可靠的、面向连接的服务</li></ol><p>在对UDP和TCP进行介绍之前，先简要介绍一下因特网网络层，因特网网络层协议中有一个IP协议(网际协议)，IP协议为主机提供了逻辑通信。<font color="red">IP协议的服务模型是尽力而为交付服务</font>。<br>也就是说，IP尽它最大的努力在通信主机之间交付数据，但它并不做任何保证。他不确保报文段的交付、不保证报文段的按序交付，不保证报文段中数据的完整性(可以理解为三无产品…)。<font color="blue">即IP为不可靠服务。</font><br>初步了解了IP服务模型之后，来总结一下TCP和UDP所提供的服务模型</p><ol><li>TCP和UDP最基本的责任是，<font color="red">将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。</font><ul><li>将主机间的交付扩展到进程间的交付被称为运输层的<font color="blue">多路复用和多路分解</font></li></ul></li><li>UDP和TCP还可以通过在其报文段首部中包括差错检查字段来<font color="bllue">提供完整性检查</font></li></ol><p>以上两种服务是最低限度的运输层服务，同时也是UDP仅能提供的两种服务。</p><ul><li>UDP<br>和IP一样，UDP提供了是一种不可靠服务(不止一次提到过)，它不能保证数据能够完整的从一个进程发送到另外一个进程。</li><li>TCP<br>TCP为应用程序提供了几种附加服务<ul><li>可靠数据传输<br>通过使用流量控制、序号、确认和定时器TCP能够确保正确的、有序的将数据交付给接收进程(后面将会具体说到)</li><li>拥塞控制服务<br>前面说到过，该服务是一种提供给因特网的服务，它防止任何一条TCP连接用过多的流量来淹没通信主机之间的链路和交换设备。(后面会着重介绍)</li></ul></li></ul><h1 id="多路分解和多路复用"><a href="#多路分解和多路复用" class="headerlink" title="多路分解和多路复用"></a>多路分解和多路复用</h1><p>多路复用和多路分解，即将网络层提供的主机间的交付服务扩展到运行在主机上的进程间的交付服务。在发送主机中，<font color="blue">发送主机将应用层报文推进套接字，在套接字中为应用层报文加上运输层报文首部字段形成运输层报文段，然后将报文段交付给运输层。</font>同样的在接收主机中，<font color="bllue">运输层实际上并没有直接将数据交付给进程，而是将数据交付给中间的套接字。</font></p><ul><li><font color="bllue"><b>多路分解</b></font><br>将运输层报文段中的数据交付到正确的套接字</li><li><font color="bllue"><b>多路复用</b></font><br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(用于后面的多路分解)从而生成报文段，然后将报文段传递到网络层。</li></ul><h2 id="无连接的多路复用和多路分解"><a href="#无连接的多路复用和多路分解" class="headerlink" title="无连接的多路复用和多路分解"></a><font size="5">无连接的多路复用和多路分解</font></h2><p>如下图<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/1.png" alt><br>在主机A(客户主机)和主机B(服务主机)中各有3个进程，假设每个进程分配了一个套接字(实际上一个进程可能分配多个)。<br>现在<font color="blue">A主机的进程1(端口号为7777)，要向B主机上的进程1(端口号为4567)发送一个应用层报文</font></p><ol><li>将应用层报文推进进程1对应的套接字中，形成如图所示的应用层报文段，该报文段中有这样两个字段。然后将该报文段交付给运输层<ul><li><b>目的端口号</b><br>发送进程的端口号</li><li><b>源端口号</b><br>接受进程的端口号</li></ul></li><li>运输层将接收到的报文段传递给网络层</li><li>网络层将接收到的报文段封装为IP数据报，并尽力的交付给B主机(目的主机)。</li><li>主机B有多个进程，每个进程都有一个UDP套接字和端口号，<font color="red">当报文段从应用层到达时，主机B通过检查该报文段中的目的端口号，将报文段定向(分解)到对应的套接字中。</font><br>在本例中，报文段的目的端口号为4567，那么最终会被交付给B主机的进程1套接字</li><li>套接字将报文段数据取出并交付给B中的接收进程1。</li></ol><p>以上就是无连接的多路分解和多路复用</p><p><b>注意：</b><br><font color="red">一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。</font>因此，<font color="red">如果两个UDP报文段有不同的源IP地址或源端口号，但是具有相同的目的IP地址和目的端口号，那么这两个报文段会被定向到同一个目的套接字(目的进程)</font><br>如下图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/2.png" alt></p><h2 id="面向连接的多路复用和多路分解"><a href="#面向连接的多路复用和多路分解" class="headerlink" title="面向连接的多路复用和多路分解"></a><font size="5">面向连接的多路复用和多路分解</font></h2><p>前面说过，UDP的套接字是由一个二元组标识，而<font color="red">TCP的套接字是由一个<b>四元组标识(源IP地址，源端口号，目的IP地址，目的端口号)</b>来标识的</font>。<br>因此，当一个TCP报文段到达一台主机时，该主机使用4个值来将报文段定向(分解)到相应的套接字。和UDP不同的是，<font color="blue">两个具有不同的源IP地址或源端口号的TCP报文段将被定向到两个不同的套接字。</font>如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/3.png" alt></p><ul><li><font color="blue"><b>报文段中源端口号的作用：</b></font><br>假设A向B发送数据，报文段中的源端口号就是运行在A上的进程的端口号。当B要向A发送数据时，B发送的报文段的目的端口号就从这里取值。</li></ul><h1 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h1><p>UDP做了运输协议能够做的最少工作。<font color="blue">UDP从应用进程得到数据，附上用于多路复用/分解的源和目的端口号，以及两个其他的小字段形成了UDP报文段。</font>然后将报文段交付给网络层。其中，使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有进行握手，正因为如此，UDP被称为无连接运输协议。<br>我们前面说过的<font color="red">DNS应用层协议就是基于UDP运输协议的。</font>当一台主机的DNS应用程序想要进行以恶搞查询时，它构造一个DNS查询报文并将其交给UDP。UDP为此报文添加首部字段封装为UDP报文段并交付给网络层。</p><h2 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a><font size="5">UDP的优点</font></h2><ul><li>采用UDP时，只要应用进程将数据传递给UDP，UDP就会将数据封装成UDP报文段并立即交付给网络层。而TCP并非如此，TCP有一个拥塞控制机制，当源和目的主机间的一条或多条通信链路变得极为拥塞时来遏制TCP发送方。这样会导致报文段的延时发送。</li><li><b>无需建立连接</b>：TCP在开始数据传输之前会经历三次握手。而UDP却并不需要任何准备即可进行数据传输。因此UDP不会引入建立连接的时延。这也是DNS建立在UDP而非TCP上的原因</li><li><b>无连接状态</b>：TCP需要在端系统中维护连接状态。该连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号参数。而对于UDP而言，不需要维护连接状态，也不需要跟踪这些参数</li><li><b>分组首部开销小</b>：每个TCP报文段首部为20字节，而UDP报文段首部只有8个字节。</li></ul><p>另外，<font color="red">虽然UDP是不可靠的数据传输协议，但这并不意味着使用UDP的应用不能实现可靠数据传输，可以通过在应用程序自身建立可靠性机制来完成。</font>例如谷歌的Chrome浏览器使用的QUIC协议在UDP之上的应用层协议中是西安了可靠性。</p><h2 id="UDP报文段的结构"><a href="#UDP报文段的结构" class="headerlink" title="UDP报文段的结构"></a><font size="5">UDP报文段的结构</font></h2><p>如图，一个UDP报文段的结构及其首部字段的作用：<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/4.png" alt></p><h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a><font size="5">UDP检验和</font></h2><p>UDP提供了差错检验功能。它的检验和字段用于确定当UDP报文段从源到目的地移动时，其中的bit是否发生了变化。<br><font color="blue">发送方的UDP对报文段中所有16bit字的和进行反码运算，<b>求和时遇到的任何溢出都被回卷</b>。得到的结果放在UDP报文段中的检验和字段中。</font>例如<br>假定有3个16bit的字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0110 0110 0110 0000</span><br><span class="line">0101 0101 0101 0101 </span><br><span class="line">1000 1111 0000 1100</span><br><span class="line"></span><br><span class="line">前两个16bit字的和：</span><br><span class="line">0110 0110 0110 0000</span><br><span class="line">0101 0101 0101 0101 </span><br><span class="line">————————————————————</span><br><span class="line">1011 1011 1011 0101</span><br><span class="line"></span><br><span class="line">再加上第三个16bit字</span><br><span class="line">1011 1011 1011 0101</span><br><span class="line">1000 1111 0000 1100</span><br><span class="line">————————————————————(在这次加法中有溢出，它要被回卷)</span><br><span class="line">0100 1010 1100 0010</span><br><span class="line"></span><br><span class="line">将该结果进行反码运算得到</span><br><span class="line">1011 0101 0011 1101==&gt;这就是检验和</span><br></pre></td></tr></table></figure><p>在接收方，<font color="red">将全部的4个16bit字(包括检验和)加在一起。</font>如果该UDP报文段没有差错，那么在接收方的和应该是<b>1111 1111 1111 1111</b>。</p><h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>《计算机网络自顶向下方法》p134-144，转换图很多很详细，就不赘述了。归纳一下可靠数据传输协议的要点</p><ul><li><b>检验和</b><br>用于判断报文段是否有差错，如果有差错则重传</li><li><b>序号</b></li><li><b>定时器</b><br>当发生丢包或者接收方确认超时时进行重传</li><li><b>肯定和否定确认分组</b><br>对检验和无误的分组返回肯定ACK确认，对有误的分组返回否定NAK确认。</li></ul><h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a><font size="5">流水线可靠数据传输协议</font></h2><p>rdt3.0是一个正确的可靠数据传输协议(见书p141)，但是由于他是一个停等协议，所以性能不能够令人满意。停等协议，即发送方发送一个分组后，只有等到接收方的肯定确认才能发送下一个分组，性能较低。<font color="blue">解决的方法就是不以停等方式运行，允许发送方发送多个分组而无需等待确认。即流水线技术</font><br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/5.png" alt><br>如图，如果要使用流水线技术，那么就不得不考虑：</p><ol><li><font color="blue">每个输送中的分组(不包括重传的)必须有一个唯一的序号。</font></li><li><font color="blue">协议的发送方和接收方两端不得不缓存多个分组</font>，对于接收方，至少应该缓存哪些已发送但没有收到接收方确认的分组，接收方也需要缓存正确接收的分组(后面会说到)。</li><li><font color="blue">怎样处理丢失、损坏以及延时过大(超时)的分组</font></li></ol><h2 id="回退N步-Go-Back-N，GBN"><a href="#回退N步-Go-Back-N，GBN" class="headerlink" title="回退N步(Go-Back-N，GBN)"></a><font size="5">回退N步(Go-Back-N，GBN)</font></h2><p>解决流水线的差错回复有两种基本方法是：<font color="blue">回退N步和选择重传</font>。现在就介绍一下回退N步。<br>在回退N步协议中，允许发送发发送多个分组而不需等待确认。但是在流水线中未确认的分组数不能超过某个最大允许数N。<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/6.png" alt>如图，显示了发送方看到的GBK协议的序号范围。可以将分组序号范围分成4段</p><ol><li><b>[0，base-1]</b>段内的序号对应已经发送并被确认的分组(收到接收方的ACK)。</li><li><b>[base，nextseqnum-1]</b>段内的序号对应已经发送但没有被确认的分组(没有收到接收方的ACK)</li><li><b>[nextseqnum，base+N-1]</b>段内的序号能用于立即要被发送的分组。</li><li><b>[base+N，~]</b>的序号处于窗口外面，不能被分组使用</li></ol><p>随着协议的运行，分组被确认后base向前移动，该窗口在<font color="red">序号空间</font>向前滑动。因此N被称为窗口长度，GBN协议也被称为<font color="red"><b>滑动窗口协议</b></font>。<br>那么问题来了，为什么要限制这些已发送但未被确认的分组数目为N而不允许这些分组无限制数目(即N无穷大)呢？后面会说到<font color="blue">TCP的流量控制和拥塞控制机制是限制窗口长度不能为无限大的的原因。</font></p><p><font color="bllue"><b>对于GBN协议，GBN发送方必须响应三种类型的事件</b></font></p><ul><li><font color="blue"><b>上层的调用</b></font><br>当上层调用rdt_send()时(可以理解为应用层将数据交付给GBN协议)，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。<ul><li>如果窗口未满，则产生一个分组并将其发送，相应的更新变量</li><li>如果窗口已满，将数据返回上层，隐式的指示上层该窗口已满，上层可能过会儿再试。</li></ul></li><li><font color="blue"><b>收到一个ACK</b></font><br>在GBN协议中，对序号n的分组采取<font color="red">累计确认</font>的方式。表明接收方以正确接收序号在n之前(包括n)的所有分组。</li><li><font color="blue"><b>超时事件</b></font><br>协议的名字”回退N步”来源于出现丢失和延时过长分组时发送方的行为。当发送分组时，定时器开始计时，如果超时，则<font color="red">发送方重传所有已发送但还没确认的分组</font>。</li></ul><p><font color="bllue"><b>对于GBN协议，GBN接收方的动作</b></font></p><ul><li>如果一个序号为n的分组被正确接收到，并且按序(即上一次收到的分许序号为n-1)，则接收方为分组n发送一个ACK分组，并将分组中的数据交付给上层。</li><li>在其他情况下，<font color="blue">接收方丢弃该分组，并为最近按序接收的分组重新发送ACK</font>。</li></ul><p>从接收方的动作可以发现，<font color="red">当分组k已接收并被交付时，所有序号比k小的分组必然已经接收并交付。因此说GBK使用累计确认。</font><br>如图给出一个长度为4的GBN协议运行情况<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/7.png" alt></p><p>向上面给出的运行情况一样，<font color="blue">GBN协议中，接收方丢弃所有失序的分组</font>。</p><ul><li><b>优点：</b>接收方不缓存任何失序的分组，需要维护的唯一信息就是下一个按序接收分组的序号。</li><li><b>缺点：</b>丢弃一个正确分组，后续对该分组的重传可能会丢失或出错，从而导致更多的重传。</li></ul><h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a><font size="5">选择重传</font></h2><p>对于GBN协议，当窗口长度和带宽延时较大时，单个分组的差错会引起大量分组的重传，但是许多分组并没有重传的必要。这样会导致更大的时延。顾名思义，<font color="blue">选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</font><br><font color="blue">SR接收方将确认一个正确接受的分组而不管其是否按序。失序的分组n将被缓存，直到n之前的所有分组都被收到。这时才可以将这一批分组按序交付给上层。</font><br><font color="bllue"><b>SR发送方事件和动作</b></font></p><ol><li><b>从上层收到数据</b>。从上层收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方窗口内，则将该数据打包并发送；否则和GBN一样，返回给上层。</li><li><b>超时</b>。每个分组都有自己的逻辑定时器，和GBN不同(GBN公用一个定时器)，因为超时后只能发送一个分组。</li><li>收到ACK。<ul><li>如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。</li><li>如果该分组序号等于send_base(发送方基序号)，则窗口向前移动到最小的已发送但未确认分组序号处。</li><li>如果窗口移动了并且有未发送的分组序号位于窗口内，则发送这些分组。</li></ul></li></ol><p><font color="bllue"><b>SR接收方事件和动作</b></font></p><ol><li><b>序号在[rec_base，rec_base+N-1]内的分组被正确接收</b>。此时，收到的分组落在接收方窗口内，给发送方回一个ACK。<ul><li>如果该分组以前没有收到过，缓存该分组。</li><li>如果该分组序号等于接收窗口的基序号(rec_base)，则将从该分组开始(包括该分组)的连续的缓存的分组交付给上层(例如之前收到了3，4，5，这一次收到了2，那么就将2，3，4，5一起交付给上层，并将rec_base移动到6)。</li></ul></li><li><b>序号在[rec_base-N,rec_base+N-1]内的分组被正确收到</b>。此时，必须产生一个ACK，即使该分组是接受方以前已经确认过的分组。因为可能虽然接收方确认了该分组，但是发送方并没有收到(ACK丢失)，如果不再次确认，这就导致发送方的send_base一直停在该分组序号处，窗口无法移动</li><li>其他情况，忽略该分组。</li></ol><p>另外，由于分组的序号取模运算。<font color="red">因此窗口的长度必须小于序号空间的一半。</font><br>假设序号空间为[0~3]，窗口长度为3(大于序号空间的一半)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//有可能会出现这种情况：当收到分组0时，无法判断该分组是新的分组还是重传的分组。</span><br><span class="line">0，1，2，3，0，1，2，3</span><br><span class="line">如图8所示</span><br></pre></td></tr></table></figure><p><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/8.png" alt></p><h1 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h1><p>前面已经介绍了可靠数据传输的基本原理，现在就可以学习TCP了</p><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a><font size="5">TCP连接</font></h2><p>TCP在两个进程发送数据之前，这两个进程必须先相互”握手”，即它们必须相互发送一些预备报文段，以建立确保数据传输的参数。</p><ul><li><font color="bllue"><b>双全工服务</b></font><br>如果一台主机中的进程A和另一台主机上的进程B存在一条TCP连接，那么<font color="blue">应用层数据就可在从A流向B的同时，也从B流向A</font>。</li><li><font color="bllue"><b>点对点</b></font><br>TCP连接是点对点的，即在单个接收方和单个发送方之间的连接。对于TCP而言，两个主机是一对。</li></ul><p>TCP连接建立的大致过程</p><ol><li>客户端首先发送一个特殊的TCP报文段，该报文段不承载数据</li><li>服务器用另一个特殊的TCP报文段来响应，该报文段不承载数据</li><li>客户端再用第三个特殊报文段作为响应，该报文段可以承载数据</li></ol><p>建立起TCP连接后，两进程就能够互相发送数据。如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/9.png" alt>发送进程将数据推进套接字，TCP将数据导入TCP的发送缓存，发送缓存是三次握手期间设置的缓存之一。接下类TCP就会不时的从发送缓存中取出一块数据，并传递到网络层。<br>TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(MSS)，MSS通常根据本地发送主机发送的最大链路层帧长度(最大传输单元，MTU)来设置。<font color="red">设置该MSS要保证一个TCP报文段加上TCP/IP首部长度(通常40字节)将适合单个链路层帧。</font><br>注意，<font color="blue">MSS是指报文段里应用层数据的最大长度，而不是包括首部的TCP报文段的最大长度。</font></p><h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a><font size="5">TCP报文段结构</font></h2><p>TCP报文段结构如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/10.png" alt></p><ul><li><b>目的端口号和源端口号</b><br>用于多路复用和多路分解</li><li><b>检验和字段</b><br>用于报文段的差错检验</li><li><b>序号字段和确认号字段</b><br>被TCP发送方和接收方用来实现可靠数据传输</li><li><b>接收窗口字段</b><br>用于流量控制，指示接收方愿意接受的字节数量</li><li><b>首部长度</b><br>以32bit的字为单位，一般为10个字(20字节)</li><li><b>标志字段</b><ul><li>ACK<br>用于指示确认字段中的值是有效的，即该报文包含一个对已被成功接收报文段的确认</li><li>RST\SYN\FIN<br>用于连接的建立和拆除</li><li>CWR\ECE<br>明确拥塞通告中用到这两个字段</li></ul></li></ul><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a><font size="5">序号和确认号</font></h3><ul><li><font color="bllue"><b>序号</b></font><br>TCP首部字段中最重要的两个字段。TCP把数据看成是一个有序的字节流。<font color="blue">一个报文段的序号就是该报文段首字节的字节流编号。</font>如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/11.png" alt></li><li><font color="bllue"><b>确认号</b></font><br>前面说过，TCP是双全工的，因此A在向B发送数据的同时，也许在接收B的数据。从B到达的每一个报文段中都有一个序号用于从B流向A的数据。<font color="blue">主机A发送的报文中的确认号就是主机A期望从主机B接收到的下一个字节的序号(也就是下一个报文段的序号)。</font><br>假设A已经收到了来自B的编号为0-535的所有字节，同时它打算给B发送一个报文段。那么该报文段的确认号就是A期望从B接收到的下一个字节的序号，也就是536。<br>此外如果TCP收到了来自B的数据流0-535和900-1000。此时A到B的下一个报文段的确认号仍然是536而不是1001。<font color="red">即TCP只确认该流中第一个丢失的字节，所以TCP被称为提供累计确认。</font><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a><font size="5">可靠数据传输</font></h2>前面说过，IP是不可靠的，TCP在IP不可靠的尽力而为服务上创建了一种可靠数据传输服务。TCP的可靠数据传输服务保证一个进程从其接收缓存中接收到的数据和发送进程发送的数据一模一样。<br><font color="blue"><b>为了简化讨论，先假设数据只从A到B，TCP发送方的动作</b></font></li></ul><ol><li>从应用程序接收数据<br>从应用程序接收数据，生成具有序号seq的TCP报文段，如果定时器没有运行那么启动定时器</li><li>定时器超时<br>重传序号最小的未收到确认的报文，重启定时器</li><li>收到ACK<br>收到ACK，ACK的确认号为y，如果y&gt;sendBase，那么sendBase==y。其中sendBase为发送方为最早未被确认的字节序号。如果仍有未被确认的报文段，TCP还要重启定时器<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/12.png" alt><br>以上是TCP过程中两种特殊情况，还有一种情况和第二种类似，<font color="blue">如果主机B的ACK=100和ACK=120没有超时，但是ACK=100丢失，即只有ACK=120按时到达了主机A，那么主机A不会重传任何报文，因此TCP的累计确认机制，发送方收到ACK=120后，就能够知道B已经收到了119以及之前的所有字节。</font></li></ol><ul><li><font color="bllue"><b>超时间隔加倍</b></font><br>这是大多TCP实现中的一种改进，每当超时事件发生时，就像前面提到的，TCP发送方重传具有最小序号但还未被确认的报文段。但是<font color="blue">每次TCP重传时都会将下次的超时间隔设为先前值得两倍。</font>例如假设初始的TCP超时间隔为0.75s，那么第一次超时事件发生后，TCP重传报文段，并将超时间隔设置为1.5秒，以此类推……<br>这样修改是因为，<b>定时器过时很可能是因为网络拥塞引起的，分组并没有真的丢失。在拥塞的时候，如果发送方持续的重传分组，会导致拥塞更为严重</b>，所以TCP采用超时间隔加倍的方式使延时的分组尽可能少的被重传。</li><li><font color="bllue"><b>快速重传</b></font><br>前面说到的超时间隔加倍也可能存在一个问题，<b>当一个分组真的丢失时，超时间隔过长就会导致端到端的时延，因此TCP设计了快速重传机制。</b><br>TCP发送方通常可在超时事件发生之前通过冗余ACK来较好的检测到丢包的情况。冗余ACK就是对同一个报文段重复确认的ACK。<br><font color="blue">如果TCP发送方接收到对相同数据的3个冗余ACK(即一共接收到4个ACK)，它就认为跟在这个已经被确认3次之后的报文段之后的报文段已经丢失(即序号为冗余ACK报文段确认号的报文段)。此时TCP进行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</font></li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><font size="5">流量控制</font></h2><p>前面提到过，TCP连接的两侧主机都为该连接设置了一个缓存，当TCP接收到正确按序的字节后，就将数据放入缓存，相应的进程会从缓存中读取数据。事实上，接收方应用也许正忙于其他任务，甚至要很长时间后才去读取该数据，<font color="blue">如果某些应用程序读取数据时相对缓慢，而发送方发送的太多太快，发送的数据很容易使得接收缓存溢出而导致数据丢失。</font><br><font color="red">流量控制服务就是用来消除发送方使接收方缓存溢出得可能性。</font><br>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制(<b>即TCP报文段中接收窗口字段</b>)。通俗的说，<font color="blue">接收窗口是一个变量，用于给发送方一个指示–该接收方还有多少可用的缓存空间。</font>由于TCP是双全工通信，因此连接连端各有一个接收窗口。<br>现假设A通过TCP连接向B发送一个大文件。主机B为该连接分配了一个TCP接收缓存(用RcvBuffer表示其大小)。主机B上的进程不断地从该缓存中读取数据。我们定义一下变量</p><ul><li><b>LastByteRead</b><br>主机B上的进程从缓存中读取的最后一个字节的编号</li><li><b>LastByteRcvd</b><br>从网络到达并放入B接收缓存中的数据流最后一个字节的编号。</li></ul><p>由于TCP不允许缓存溢出，因此必须有<br><font color="red"><b>(LastByteRcvd-LastByteRead)&lt;=RcvBuffer</b></font><br>接收窗口用rwnd表示，根据缓存可用空间来设置：<br><font color="red"><b>rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)</b></font><br>如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/13.png" alt><font color="blue">主机B通过把当前的rwnd的值放入它发给主机A的报文段接收窗口字段中，通知A它在该连接的接收缓存中还有多少可用空间，开始时rwnd=RcvBuffer</font><br>在主机A中，主机A跟踪两个变量，LastByteSent和LastByteAcked，这两个变量的差LastByteSent-LastByteAcked就是A发送到连接中但未被确认的数据量，通过将该差值控制在rwnd以内，就可以保证B中接收缓存不会溢出。<br>因此，主机A在该连接的整个生命周期保证<font color="red"><b>LastByteSent-LastByteAcked&lt;=rwnd</b></font>。</p><p>以上的流量控制还存在一个小问题：<b>即当主机B的接收缓存已满，使得rwnd为0。再将rwnd=0发送给A之后，假设B没有任何数据要发送给主机A，那么当B的应用进程将接收缓存中的数据读取完之后，主机A并不知道B的接收缓存已经有新空间了。即主机A被阻塞而不能在发送数据。</b>为了解决这个问题，TCP规范中要求：<br><font color="bllue">当主机B的接收窗口rwnd=0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文中将包含一个非0的rwnd值。</font>这样主机A就能够知道B的接收窗口有空闲空间从而继续发送数据。</p><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a><font size="5">TCP连接管理</font></h2><p>下面主要介绍TCP连接是如何建立和拆除的，即<b>三次握手、四次挥手</b>是如何进行的。</p><ul><li><font color="bllue"><b>三次握手</b></font></li></ul><ol><li>客户端TCP首先向服务器发送一个特殊的TCP报文段。该报文段<b>不包含数据内容</b>，但是<b>报文段首部的SYN字段(回顾TCP报文段结构)被置1</b>，因此该报文段又被称为<font color="red">SYN报文段</font>。另外，<b>客户端会随机选择一个初始序号(client_isn)，放在SYN报文段的序号字段中</b></li><li>服务器接收到客户端的SYN报文段后，就<b>为该TCP连接分配TCP缓存和变量</b>，并向客户端TCP发送允许连接的报文段。这个报文段也<b>不包含应用层数据，SYN字段也被置为1(该报文段被称为font color=red&gt;SYNACK报文段)</b>。服务器也会选择一个<b>初始序号sever_isn，放在该SYNACK报文段的序号字段中</b>。另外，<font color="red">该SYNACK报文段的确认号字段放的是client_isn+1。</font><br><font color="blue">这个报文段实际上表明了：我收到了你的SYN分组，该分组的初始序号为client_isn，我同意建立连接。我的序号为sever_isn。</font></li><li>在收到SYNACK报文段后，<b>客户端给该TCP连接分配缓存和变量</b>。并且向服务器发送另外一个报文段；该报文段对服务器的SYNACK报文段进行了确认(<font color="red">将sever_isn+1放到确认号字段中</font>)，因为连接已经建立，因此<b>该报文段SYN置0，并且该报文段可以携带应用层数据。</b></li></ol><ul><li><font color="bllue"><b>四次挥手</b></font><br>当TCP连接结束后，主机中的资源(缓存和变量)将被释放<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/14.jpg" alt>(来自网络)</li></ul><ol><li>客户的应用进程要关闭此连接，那么<b>客户TCP发送一个FIN标志位置1的FIN报文段，并<font color="red">进入FIN_WAIT_1状态</font></b>。等待一个来自服务器对FIN报文段的ACK报文段</li><li>服务器<b>接收到来自客户端的FIN报文段，发出确认报文段ACK，<font color="red">进入CLOSE_WAIT状态</font></b>。此时客户端向服务器方向的连接就释放了。该连接处于半关闭状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。</li><li>客户端<b>收到来自服务器的ACK报文段后<font color="red">进入FIN_WAIT_2状态</font>，等待来自服务器的FIN报文段</b></li><li>处于CLOSE_WAIT状态服务器如果仍有数据要发送，就继续发送数据。当<b>服务器将该发送的数据发送完后，发送一个FIN报文段并<font color="red">进入LAST_ACK状态</font></b></li><li>处于FIN_WAIT_2状态的客户端<b>收到来自服务器的FIN报文段后，发送一个ACK报文段进行确认并<font color="red">进入TIME_WAIT状态</font></b>，该状态持续一段时间后自动退出，之后客户端释放资源</li><li>服务器收到来自客户端的ACK之后，直接释放资源。从图上可以看出，服务器释放资源要比客户端早一些</li></ol><p>以上就是四次挥手的过程(由于书上描述的不够详细，从网上查阅资料结合书本得出)</p><p><font color="bllue"><b>关于”三次握手、四次挥手”的一些问题</b></font></p><ol><li><p><b>为什么连接时三次握手，而关闭时却需要四次回收？</b></p><ul><li>在建立连接时，服务器收到客户端的SYN报文段时，发送的是SYNACK报文段，即SYN+ACK，该报文段即包含了对客户端SYN报文段的应答也包含了自己的连接请求SYN。</li><li>在关闭连接时，当服务器收到客户端的FIN报文段后，可能还有数据没有发送完毕仍然需要发送，并不能立刻关闭。因此并不会发送一个类似于SYNACK的FINACK，而是先发送ACK报文段对客户端的FIN报文段进行确认(告诉客户端你的FIN我收到了，此时客户端到服务器方向连接关闭)，然后发送需要发送的数据，等到数据发送完毕之后，再发送自己的FIN报文段(请求关闭到客户端方向的连接)。</li></ul></li><li><p><b>为什么客户端在发送完对服务器的FIN报文段的ACK后需要一个TIME_WAIT状态而不能直接关闭？</b><br>这是因为，有可能该ACK在网络中丢失，而服务器没有收到来自客户端的ACK报文段，那么服务器将重新发送FIN报文段，客户端需要对该重传的FIN再次进行ACK确认。</p></li><li><p><b>为什么不能用两次握手？</b><br>这是为了防止已失效的连接请求报文段突然又到达了服务器。</p><ol><li><b>客户端向服务器发送一个请求连接的SYN报文段1，但是该报文段由于网络延时较长，导致客户端认为该报文段丢失，然后重新发送SYN报文段2</b></li><li>SYN报文段2成功到达了服务器，最后成功的建立了TCP连接</li><li>客户端和服务器在完成数据传输后关闭了该TCP连接。</li><li>但是问题来了，<font color="blue">前面延时的SYN报文段1经过较长一段时间后又到达了服务器。服务器会认为这是客户端新发起的TCP连接，因此向客户端发送一个ACK报文段，如果没有第三次握手，那么连接就已经建立了，但是事实上客户端并没有任何数据要发送给服务器，因为SYN报文段1对于客户端来说是一个过期的报文段。这样就白白浪费了资源。</font></li></ol></li></ol><h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><p>在介绍拥塞控制原理之前，先简要介绍一下拥塞的原因和代价</p><h2 id="拥塞的代价"><a href="#拥塞的代价" class="headerlink" title="拥塞的代价"></a><font size="5">拥塞的代价</font></h2><ol><li>如果网络中发生拥塞，那么路由器中会形成分组队列，首先会导致延时。</li><li>当分组队列过长时，由于路由器缓存有限，进而会造成分组丢失。</li><li>由于TCP是可靠数据传输服务，因此必须对丢失的分组进行重传。</li><li>当分组在路由器中延时过长导致超时，即使分组没有丢失那么TCP发送方也会重传分组，这就会导致路由器转发不必要的重复分组。</li><li>如果一个分组经过了很多个路由器后，在之后的路由器中因为超时或者路由器缓存溢出而丢失导致发送方对该分组进行重传，那么这就意味着该分组经过的每个上游路由器所用的资源都浪费了。</li></ol><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><font size="5">TCP拥塞控制</font></h2><p>TCP使用的是端到端的拥塞控制，这是因为IP层不向端系统提供显式的网络拥塞反馈。TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其向连接发送流量的速率。如果发送方感知到从它到目的地之间没什么拥塞，就加快发送速率，反之，就抑制发送速率。<br>那么问题来了</p><ol><li>TCP发送方如何限制它向连接发送数据的速率呢？</li><li>TCP发送方如何感知从他到目的地之间的路径上存在拥塞呢？</li><li>当发送方感知到拥塞时，采用什么算法来改变发送速率呢？</li></ol><ul><li><font color="bllue"><b>TCP限制向其连接发送流量的方式</b></font><br>在前面提到过，<font color="red">TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。</font><b>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口(cwnd)，它对一个TCP发送方能像网络中发送流量的速率进行了限制。</b><br>一个发送方中未被确认的数据量不会超过cnwd和rnwd中的最小值，即<br><font color="red"><b>(LastByteSent-LastByteAcked)&lt;=min{cwnd，rndw}</b></font><br>在这里为了和流量控制区分开，我们假设接收窗口无限大(这样就不存在缓存溢出，也就不存在流量控制了)，因此在发送方未被确认的数据量就受限于cwnd，还假设发送方总是有数据要发送。这样的约束控制了发送方未被确认的数据量，间接的控制了发送方的发送速率。</li><li><font color="bllue"><b>TCP发送方感知网络拥塞的方式</b></font><br>我们将TCP丢包事件定义为：要么出现超时，要么收到来自接收方的三个冗余ACK。</li></ul><ol><li>当出现过度拥塞时，在沿着这条路径上的一台或多台路由器缓存溢出，引发一个数据报(网络层分组，包含TCP报文段)丢失。丢失的分组接着会引起<font color="red">丢包事件</font>，<b>发送方就认为在网络中(发送方到接收方的网络路径)出现了拥塞。</b></li><li>当网络没有拥塞时，即没有出现丢包事件。在此情况下，TCP发送方将收到对未确认报文段的ACK。<font color="red">TCP将这些确认的到达作为网络正常的指示，并使用确认来增加窗口长度(发送速率)</font>，(这不难理解，当发送方觉得网络很好的时候，理所当然的就会尝试提高发送速率)。注意，窗口增大的速率取决于ACK确认报文到达的速率。TCP使用确认来触发增大它拥塞窗口长度的被称为自计时方式。</li></ol><p>那么TCP又是怎样确定发送速率呢？如果发送速率太快，会导致拥塞，太慢又导致带宽不能充分得到利用。<font color="blue">TCP使用下列三种指导性原则</font></p><ol><li><b>一个丢失的报文段意味着拥塞，因此当丢包事件发生时应当降低TCP发送方的速率</b></li><li><b>一个确认报文段(ACK报文段)意味着网络中一切顺利，因此对先前未确认的确认到达时，能够增加发送方速率</b></li><li><b>带宽检测。TCP调节其传输速率的策略是<font color="red">增加其速率以影响到达的ACK，除非出现丢包事件，此时才减小传输速率</font></b>。该行为类似于一个要求并得到越来越多糖果的孩子，知道最后告知他不行。孩子后退一点，然后过一会儿再次开始要糖果。</li></ol><p>概述了TCP拥塞控制后，现在开始介绍TCP拥塞控制算法细节，该算法主要包括3个部分：</p><ol><li>慢启动</li><li>拥塞避免</li><li>快速恢复</li></ol><p>前两种是TCP的强制部分</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><font size="5">慢启动</font></h3><p>一条TC连接开始时，cwnd初始值同设置为一个MSS(最大传输单元)，这使得初始发送速率大约为MSS/RTT(平均往返时间)。对于TCP发送方而言，可用带宽可能远远大于该速率，因此发送方希望希望迅速找到可用带宽的数量<br>cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/14.png" alt>从图中可以看出，没过一个RTT，发送速率就会翻倍。<font color="blue">因此TCP发送速率起始满，但在慢启动阶段以指数增长。</font><br>那么这种指数增长什么时候结束呢？有三种方式分别对应三种情况</p><ul><li><font color="bllue"><b>出现由超时指示的丢包事件时(拥塞)</b></font><br>TCP发送方将cwnd重新置为1，将ssthresh(慢启动阈值标记)设置cwnd/2(这里的cwnd是置1之前的值)，并重新开始慢启动过程。</li><li><font color="bllue"><b>当cwnd&gt;=sshthresh时</b></font><br>当cwnd一直翻倍增长，超过ssthresh时，直接进入到拥塞避免模式(后面会说到)，这是因为，在第一种情况检测到拥塞时将sshthresh设置为拥塞时cwnd的一半，当cwnd再次达到ssthresh时，如果继续翻倍，那么很有可能继续造成拥塞，因此应采取更为缓慢的增长方式，即拥塞避免模式。</li><li><font color="bllue"><b>快速恢复</b></font><br>如果检测到3个冗余的ACK，这时TCP将执行快速重传，并进入快速回复模式</li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><font size="5">拥塞避免</font></h3><p>一旦进入拥塞避免，cwnd的值大约是上次拥塞值得一半，即距离拥塞并不远。因此TCP使用一种较为保守的方式增加cwnd，每个RTT将cwnd的值增加一个MSS。<br>如何结束拥塞避免模式得线性增长呢？</p><ul><li><font color="bllue"><b>出现由超时指示的丢包事件时(拥塞)</b></font><br>和慢启动一样，将MSS设置为1个MSS，ssthresh设置为cwnd/2，重新进入慢启动模式</li><li><font color="bllue"><b>收到3个冗余ACK包</b></font><br>将ssthresh设置为cwnd/2，然后将cwnd增加3个MSS(可以理解为3个冗余ACK各增加一个)，进入快速回复模式</li></ul><h3 id="快速回复"><a href="#快速回复" class="headerlink" title="快速回复"></a><font size="5">快速回复</font></h3><p>在此状态下，对收到的每一个冗余ACK，cwnd值增加一个MSS。<br>如何结束拥塞避免模式得线性增长呢？</p><ul><li><font color="bllue"><b>收到对未确认报文段的ACK</b></font><br>将cwnd设置为ssthresh值，进入到拥塞避免模式</li><li><font color="bllue"><b>出现由超时指示的丢包事件时(拥塞)</b></font><br>和慢启动一样，将ssthresh设置为cwnd/2，将cwnd置为1个MSS，重新进入慢启动模式</li></ul><p>TCP拥塞控制的状态转换如图所示<br><img src="/2019/10/09/自顶向下之计算机网络和因特网-运输层/15.png" alt><br>我们不难发现一些规律</p><ol><li>引起状态转换一共有四种事件，分别是<ol><li><b>超时</b></li><li><b>窗口长度超过阈值</b></li><li><b>收到正常ACK</b></li><li><b>收到累计3个冗余ACK</b></li></ol></li><li>当累计收到3个冗余ACK时，必定会转换到快速回复模式，并有ssthresh=cwnd/2和cwnd=ssthresh+3 MSS操作</li></ol><hr>关于运输层的简要学习就到这里，主要介绍了多路复用/分解，滑动窗口协议、选择重传、TCP的可靠数据传输、超时间隔加倍以及快速重传、流量控制和拥塞控制机制等。下次介绍网络层相关知识。]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 计算机网络自顶向下方法 </tag>
            
            <tag> 传输层 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法之二分查找</title>
      <link href="/2019/10/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/10/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>查找在日常生活中的应用也非常广泛，除了一般的线性查找，还有专门针对有序数组得二分查找、插值查找、斐波那契查找等查找算法。今天介绍的就是著名的二分查找算法。</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>二分查找要求待查找数据是有序的。每次取出数据的中间项midValue，和要查找的数searchValue相比较</p><ol><li>如果midValue&lt;searchValue，那么就在midValue得左边继续查找</li><li>如果midValue&gt;searchValue，那么就在midValue得右边继续查找</li><li>如果midValue==searchValue，返回midValue下标。</li></ol><p>算法使用递归实现，当<font color="red">left(左边界)&gt;right(有边界)时，说明数据得每一个元素都已经被访问过仍然没有找到，返回-1</font>。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li><p>只查找一个值，找到后就返回，无论是否有重复值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二分查找</span><br><span class="line"> * 找到一个就返回，不管是否重复</span><br><span class="line"> * @param arr 待查找数组</span><br><span class="line"> * @param left 左边界索引，初始值为0</span><br><span class="line"> * @param right 右边界索引，初始值为length-1</span><br><span class="line"> * @param value 要查找的值</span><br><span class="line"> * @return 返回值得下标，没找到返回0</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int value) &#123;</span><br><span class="line">//递归出口当left&gt;right时说明说明数组每一个元素都已经遍历完但是没有找到，直接返回-1</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mid = (right + left) / 2;</span><br><span class="line">int midValue = arr[mid];</span><br><span class="line"></span><br><span class="line">//向右递归</span><br><span class="line">if (value &gt; midValue) &#123;</span><br><span class="line">return binarySearch(arr, mid + 1, right, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向左递归</span><br><span class="line">else if (value &lt; midValue) &#123;</span><br><span class="line">return binarySearch(arr, left, mid - 1, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找数据中所有值为value的下标，返回一个下标集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二分查找</span><br><span class="line"> * 找出所有值为value的下标</span><br><span class="line"> * @param arr 带查找数组</span><br><span class="line"> * @param left 左边界索引，初始值为0</span><br><span class="line"> * @param right 右边界索引，初始值为length-1</span><br><span class="line"> * @param value 要查找的值</span><br><span class="line"> * @return 值得下标集合</span><br><span class="line"> */</span><br><span class="line">public static List&lt;Integer&gt; binarySearch1(int[] arr, int left, int right, int value) &#123;</span><br><span class="line">//当left&gt;right时说明说明数组每一个元素都已经遍历完但是没有找到，直接返回-1</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mid = (right + left) / 2;</span><br><span class="line">int midValue = arr[mid];</span><br><span class="line"></span><br><span class="line">//向右递归</span><br><span class="line">if (value &gt; midValue) &#123;</span><br><span class="line">return binarySearch1(arr, mid + 1, right, value);</span><br><span class="line">&#125;</span><br><span class="line">//向左递归</span><br><span class="line">else if (value &lt; midValue) &#123;</span><br><span class="line">return binarySearch1(arr, left, mid - 1, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">//再找到mid值时不马上返回，向mid索引值的两边扫描</span><br><span class="line">//将所有值为value的下标值添加到ArrayList集合中，最后返回集合</span><br><span class="line">//向左查找</span><br><span class="line">int goLeft=mid-1;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">while (left &gt; 0 &amp;&amp; arr[goLeft] == value) &#123;</span><br><span class="line">list.add(goLeft);</span><br><span class="line">goLeft--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向右查找</span><br><span class="line">while (mid &lt; arr.length &amp;&amp; arr[mid] == value) &#123;</span><br><span class="line">list.add(mid);</span><br><span class="line">mid++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>请注意，当我们需要在数组{1,2,3….100}中查找1或100时，用二分会查找次数相对多一些，这时候可以用到插值查找<br>插值查找思路也非常的简单，和二分查找唯一的区别在于mid(每次查找分界点)的选用不同。</p><ul><li>二分查找每次都去中间的数据作为分界点<br>即mid=left+(right-left)/2</li><li>而插值查找mid的选取是自适应的，和要查找的值findValue有关<br>mid=left+(right-left)*{(findValue-arr[left])/(arr[right]-arr[left])}</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><font size="5">代码实现</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插值查找</span><br><span class="line"> * @param arr 待查找数组</span><br><span class="line"> * @param left 左边界索引</span><br><span class="line"> * @param right 有边界索引</span><br><span class="line"> * @param findValue 待查找的值</span><br><span class="line"> * @return 数组下标，没找到返回-1</span><br><span class="line"> */</span><br><span class="line">public static int insertValueSearch(int[] arr, int left, int right, int findValue) &#123;</span><br><span class="line">//必须确保findValue在数组最大值和最小值中间，否则会导致数组越界</span><br><span class="line">if (left &gt; right || findValue &lt; arr[left] || findValue &gt; arr[right]) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mid = left + (right - left) * (findValue - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">int midValue = arr[mid];</span><br><span class="line"></span><br><span class="line">if (midValue &lt; findValue) &#123;</span><br><span class="line">return insertValueSearch(arr, mid + 1, right, findValue);</span><br><span class="line">&#125; else if (midValue &gt; findValue) &#123;</span><br><span class="line">return insertValueSearch(arr, left, mid - 1, findValue);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a><font size="5">算法分析</font></h2><p>这样一来，当要查找的数位于数据靠两边的位置时，查找次数会相对少一些。该算法<font color="blue">适用于待查找数据较为连续时。</font>当数不连续时有时甚至比二分查找次数更多一些。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之基数排序</title>
      <link href="/2019/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>这次要介绍的是最后一种排序算法，个人觉得也是最一种神奇的排序算法、当然更是最典型的空间换时间排序算法。它就是基数排序</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><ol><li>首先要额外申请10个桶(一维数组，和待排序数组arr一样大)，可以用二维数组来实现。</li><li>取出arr的每个元素个位数字m，根据元素的个位数字将元素放到下标为m的桶中(例如：123个位数为3，就将123放到下标为3的桶中)</li><li>将10个桶中的数依次再放回arr数组中</li><li>取出arr的每个元素十位数字，继续进行以上操作</li><li>知道最大元素的每个位都遍历完为止。</li></ol><p>该算法按照个、十、百位等依次将元素进行排序，最终得到有序数组。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序</span><br><span class="line"> * @param arr 待排序数组</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] arr) &#123;</span><br><span class="line">//用作桶的数组</span><br><span class="line">int[][] temp = new int[10][arr.length];</span><br><span class="line">//计数数组，用于记录每个桶中有多少个数</span><br><span class="line">int[] count = new int[10];</span><br><span class="line">//找到最大的元素</span><br><span class="line">int max = arr[0];</span><br><span class="line">for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">if (arr[i] &gt; max) &#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取最大元素的位数，即循环次数</span><br><span class="line">int maxLength = (max + &quot;&quot;).length();</span><br><span class="line">for (int r = 0, i = 1; r &lt; maxLength; r++, i *= 10) &#123;</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">//取出每个元素相应位的数</span><br><span class="line">int digitElement = (arr[j] / i) % 10;</span><br><span class="line">//放到对应的桶中</span><br><span class="line">temp[digitElement][count[digitElement]++] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">//每一轮开始将arr下标置0</span><br><span class="line">int index = 0;</span><br><span class="line">//遍历10个桶，将桶中元素放回arr数组中</span><br><span class="line">for (int k = 0; k &lt; 10; k++) &#123;</span><br><span class="line">int countIndex = 0;</span><br><span class="line">//将每个桶中的元素依次放回arr数组中</span><br><span class="line">while (count[k] &gt; 0) &#123;</span><br><span class="line">arr[index++] = temp[k][countIndex++];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>时间复杂度<br> O(n*k)</li><li>空间复杂度<br> O(n+k)</li><li>稳定性<br> <font color="red">基数排序是稳定的</font></li></ol><h1 id="算法速度"><a href="#算法速度" class="headerlink" title="算法速度"></a>算法速度</h1><p>既然说基数排序是典型的空间换时间，那么它的性能究竟如何呢？来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//生成了一个800w的随机数组进行排序</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//随机生成一个数组，对其进行排序</span><br><span class="line">int[] arr = new int[8000000];</span><br><span class="line">Random random = new Random();</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = random.nextInt(800000);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;====================&quot;);</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">radixSort(arr);</span><br><span class="line">long ends = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;插入排序共花费：&quot; + (ends - start) + &quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Output：</span><br><span class="line">500毫秒左右</span><br></pre></td></tr></table></figure><p>在800w时，速度仅为快排的一半。但是由于该算法空间复杂度过高，因此在8000w时就OOM了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自顶向下之计算机网络和因特网-应用层</title>
      <link href="/2019/10/07/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2019/10/07/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>应用层是五层协议中的最顶层，网络应用是计算机网络存在的理由，如果我们不能构想出来任何有用的应用，也就没必要去设计支持他们的网络协议了。接下来就介绍一些应用层的一些相关知识。</p><hr><a id="more"></a><h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><p>开发网络应用的核心在于能够写出运行在两个不同的端系统和通过网络彼此通信的程序。例如，在WEB应用中，有两个相互通信的不同的程序：一个是运行在用于主机上的浏览器程序，另一个是运行在服务主机上的WEB服务器程序。</p><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a><font size="5">网络应用程序体系结构</font></h2><p>应用程序体系结构由研发者设计，规定了如何在各种端系统上组织该应用程序。有两种主流的体系结构</p><ul><li><font color="blue"><b>客户-服务器体系结构</b></font><br>在该体系中，有一个总是打开的主机被称为服务器，它服务于来自许多被称为客户端主机的请求。该体系有两个特点<ul><li>客户端和客户端不直接通信</li><li>服务器具有周知的固定的IP地址</li></ul></li><li><font color="blue"><b>P2P体系结构</b></font><br>对专用服务器有最小的或者没有依赖，<b>应用程序在间断连接的主机对直接直接通信</b>，这些主机对称为对等方。</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><font size="5">进程通信</font></h2><p>用操作系统的术语来说，进程通信的实际上是进程而不是程序</p><ul><li>进程<br>可以被认为是运行在端系统上的一个程序。</li></ul><p>当多个进程运行在相同的端系统上时，它们使用进程通信机制相互通信。进程通信的规则由端系统上的操作系统确定。在这里，我们主要关注运行在不同端系统上的进程间通信。<br><font color="blue">在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信：</font></p><ul><li>发送进程生成并向网络中发送报文</li><li>接收进程接受这些报文并可能通过回送报文进行相应</li></ul><h3 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a><font size="5">客户和服务器进程</font></h3><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对于每一对通信进程，我们称其中一个为客户，另一个为服务器</p><ul><li><b>客户</b><br>在一对进程之间的会话通信中，发起通信的进程被标识为客户</li><li><b>服务器</b><br>在会话开始时等待联系的进程被标识为服务器</li></ul><h3 id="进程和计算机之间的接口"><a href="#进程和计算机之间的接口" class="headerlink" title="进程和计算机之间的接口"></a><font size="5">进程和计算机之间的接口</font></h3><p>前面说过，多数应用程序是由通信进程对组成，每对两个进程间相互发送报文。从一个进程到另一个进程发送报文必须通过下面的网络。<font color="bllue">进程通过一个称为套接字的软件接口像网络发送报文和从网络接收报文。</font></p><ul><li><b>套接字</b><br>是同一台主机内应用层和运输层之间的接口(关于套接字在前面一篇文章已介绍过)，又被称为应用程序和网络之间的应用程序编程接口。</li></ul><h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a><font size="5">进程寻址</font></h3><p>为了向特定目的地发送邮件，需要一个地址。类似的，在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，这样发送方才能通过这个地址找到接收进程。为了标识该进程，需要定义两种信息</p><ol><li>主机的地址<br>在因特网中，主机地址由IP地址标识。现在，只需要了解IP地址是一个32bit的数并且能唯一标识该主机。</li><li>目的主机中指定接收进程的标识符<br>知道了主机的地址后，分组就能够到达改主机。但是，主机中运行着不止一个进程，发送进程还必须指定运行在接受主机上的接收进程。我们用<font color="blue">目的端口号来标识进程。</font></li></ol><p><font color="red">发送进程通过IP地址和目的端口号，就能准确地将定位运行在目的主机上的接收进程。</font></p><h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a><font size="5">可供应用程序使用的运输服务</font></h2><p>前面说了，套接字是应用程序和运输层协议之间的接口。在发送端的应用程序将报文推进该套接字，在套接字的另一侧，运输层协议负责从接收进程的套接字得到该报文。运输层协议不止一种，当开发一个应用时，要选择一种可用的运输层协议。一个运输层协议能够为调用它的应用程序提供呢？接下来将从四个方面对应用程序服务要求进行分类</p><ul><li><font color="bllue"><b>可靠数据传输</b></font><br>前面说过，分组在计算机网络中可能丢失。有时候，数据丢失会带来巨大的损失，如金融应用程序，文件传输等。为了支持这些应用，必须做一些工作以<font color="blue">确保由应用程序的一端发送的数据正确、完全的交给另一端</font>。如果一个列协议提供了这样的确保数据交付服务，就认为提供了<font color="red">可靠数据传输</font>。<br>运输层协议能够潜在的想应用程序提供的一个重要服务是进程到进程的可靠数据传输服务。当一个运输层协议不提供可靠数据传输时，由进程发送的某些数据就可能到达不了接收进程。像多媒体应用如视频音乐等应用是允许少量数据丢失的。</li><li><font color="bllue"><b>吞吐量</b></font><br><font color="blue">可用吞吐量就是发送进程能够向接收进程交付比特的速率。</font>运输层协议能够以某种特定的速率提供确保的可用吞吐量，使用这种服务，该应用程序能够请求r bit/s的确保吞吐量，并且该运输协议能够确保可用吞吐量总是至少为r bit/s。这对一些即时应用如视频会话很有吸引力。具有吞吐量要求的应用被称为带宽敏感应用。相对的，弹性应用能够根据当时可用的带宽或多或少的利用可供使用的吞吐量，如电子邮件等。</li><li><font color="bllue"><b>定时</b></font><br>运输层协议也能提供定时保证。这种服务对于交互式应用很有吸引力，在多方游戏和虚拟互动环境中，在做出动作并看到来自环境的相应之间，较长的延迟极大的影响体验。</li><li><font color="bllue"><b>安全性</b></font><br>在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接受主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。这样就能够防止数据在发送的过程中被观察到。</li></ul><h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a><font size="5">因特网提供的运输服务</font></h2><p>上面考虑了计算机网络能够提供的通用运输服务，现在就具体介绍由因特网提供的运输层服务类型。因特网(或者说TCP/IP网络)为应用程序提供了两个运输层协议，即TCP和UDP</p><ul><li><font color="bllue"><b>TCP</b></font><br>TCP服务包括面向连接和可靠数据传输服务。当某个应用程序调用TCP作为运输协议时，该应用程序就能获得来自TCP的这两种服务。<ul><li><b>面向连接的服务</b><br>在应用层数据报文开始流动之前，TCP让客户端和服务器相互交换控制层信息(握手过程)。握手阶段后，一个TCP连接就在连个进程的套接字之间建立了。<font color="blue">这是一条双全工连接，即连接双方的进程可以在连接上同时进行报文收发。</font>当应用程序结束报文发送时，该连接被拆除。</li><li><b>可靠的数据传输服务</b><br>通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。</li></ul></li></ul><p>TCP协议具有拥塞控制协议，该服务不一定能贵进程带来直接好处，但能为互联网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。</p><ul><li><font color="bllue"><b>UDP</b></font><br><font color="blue">UDP是无连接的，提供一种不可靠数据传输服务</font>，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。并且接收进程的报文也有可能是乱序到达的。</li></ul><p>前面说了四种运输协议的服务，那么对因特网运输协议来说，TCP提供了可靠数据传输并且能通过SSL提供安全性服务(后面会说到)。然而对于定时和吞吐量，因特网协议虽然没有提供任何保证，但是却能够为时间敏感应用提供满意的服务。</p><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a><font size="5">应用层协议</font></h2><p><font color="red">应用层协议是网络应用的一部分(很重要的一部分)。</font>前面介绍了通过把报文发送进套接字实现网络进程间的相互通信，但是如何构造这些报文？报文中字段的含义是什么等等问题……应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了如下：</p><ol><li><b>交换的报文类型，如请求报文和响应报文等</b></li><li><b>各种报文类型的语法</b></li><li><b>字段的含义</b></li><li><b>确定一个进程何时以及如何发送这些报文，对报文进行响应的规则</b></li></ol><h1 id="Web和TTTP"><a href="#Web和TTTP" class="headerlink" title="Web和TTTP"></a>Web和TTTP</h1><p>Web具有按需操作，当我们需要时，就能得到想要的内容。这不同于广播和电视，它们迫使用户只能收听观看它们提供的内容。</p><h2 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a><font size="5">HTTP概况</font></h2><p>Web的应用层协议是超文本传输协议(Hyper Text Transfer Proyocol，即HTTP)，它是Web的核心。HTTP由两个程序实现：一个客户端程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。<font color="blue">HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</font><br>在介绍HTTP之前，先来了解几个Web术语</p><ul><li><b>Web页面</b><br>是由对象构成的，一个对象只是一个文件。诸如一个HTML文件、一个图片等等。且它们可以通过一个URL地址寻址。</li><li><b>URL地址</b><br>每个URL地址包括两部分：存放对象的服务器主机名和对象地址。    </li></ul><p>HTTP定义了Web客户向Web服务器请求Web页面的方式以及服务器向客户传送Web页面的方式。<font color="red">HTTP使用TCP作为它的支撑运输协议</font>。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字访问TCP。<br>客户向它的套接字发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。一旦客户向它的套接字发送了一个请求报文，该报文就脱离了客户控制并进入TCP控制。</p><ul><li><b>无状态协议</b><br><font color="blue">服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，</font>即<font color="red">HTTP是一个无状态协议</font>。同时Web服务器总是打开的并且拥有一个固定的IP地址。</li></ul><h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a><font size="5">非持续连接和持续连接</font></h2><p>在许多因特网应用程序中，客户和服务器在很长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。那么问题来了，每个请求/响应对是经一个单独的TCP连接发送还是所有的请求/响应对经同一个TCP连接发送呢？前面的方法被称为非持续连接，后面的被称为持续连接。</p><ul><li><font color="bllue"><b>非持续连接</b></font><br>对于非持续连接，<font color="blue">每一次请求响应都要维持一个新的TCP连接。</font>即一个请求/响应对对应着一个TCP连接。假设有一个Web页面包含一个HTML文件和10个png文件，那么发送该页面就要创建11个TCP连接。这种方式有一些缺点<ul><li>必须为每一个请求/响应对建立和维护一个全新的TCP连接，对于每一个TCP连接，在客户端和服务器端中都要分配TCP缓冲区和保持TCP变量(后面会说到)，这给Web服务器带来了严重的负担</li><li>对于每个TCP连接的都要经历”三次握手”的过程，因此响应时间变长。</li></ul></li><li><font color="bllue"><b>持续连接</b></font><br>HTTP1.1使用了持续连接。服务器在发送响应后保持TCP连接打开。<font color="blue">在相同的客户和服务器之间，后续的请求和响应报文能够通过相同的连接进行传送</font>。一般来说，如果一条TCP连接经过一段时间间隔(可设置该间隔)仍未被使用，HTTP服务器就关闭该连接。</li></ul><h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a><font size="5">HTTP报文格式</font></h2><p>HTTP报文有两种：请求报文和响应报文</p><ul><li><font color="bllue"><b>请求报文</b></font></li></ul><ol><li><b>请求行</b><ol><li>方法字段：包括GET、POST等</li><li>URL字段</li><li>HTTP版本字段</li></ol></li><li><b>请求头</b><br>由一系列键值对组成(具体键值对在HTTP协议概述大致介绍过)</li><li><b>请求空行</b><br>就是一个空行，用于分隔请求头和请求体</li><li><b>请求体</b><ol><li>使用GET方法时请求体为空，此时请求参数跟在URL后面</li><li>使用POST方法时，请求参数被封装在请求体中。</li></ol></li></ol><ul><li><font color="bllue"><b>响应报文</b></font><br>和请求报文类似，响应报文也有4部分</li></ul><ol><li>响应行(状态行)<ol><li>协议版本字段</li><li>状态码</li><li>对应状态信息</li></ol></li><li>响应头<br>同样的，由一系列键值对组成</li><li>响应空行<br>用于分隔响应头和响应体</li><li>响应体<br>包含了客户请求的对象。如HTML文档、jpg图片以及视频等</li></ol><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a><font size="5">Web缓存</font></h2><p>Web缓存器也叫Web代理服务器。它能够代表初始服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘空间，并在存储空间中保存最近请求过的对象的副本。<br><img src="/2019/10/07/自顶向下之计算机网络和因特网-应用层/1.png" alt>如图，当浏览器正在请求对象<a href="http://www.aaa.com/campas.gif时" target="_blank" rel="noopener">http://www.aaa.com/campas.gif时</a></p><ol><li>浏览器会创建一个到Wen缓存器的TCP连接，并向Web缓存器中对象发送一个HTTP请求</li><li>Web缓存器进行检查，查看本地是否存储了该对象的副本。如果有，Web缓存器就像客户浏览器用响应报文返回该对象</li><li>如果Web缓存器中没有该对象，它就创建一个与该对象初始服务器(<a href="http://www.aaa.com" target="_blank" rel="noopener">www.aaa.com</a> )的TCP连接。并在这个连接上发送一个该对象的HTTP请求。在接收到该请求后，初始服务器向Web缓存器发送具有该对象的响应报文。</li><li>Web缓存器收到来自初始服务器的对象时，在本地存储空间存储一份副本，并通过客户-缓存器的TCP连接向客户的浏览器用HTTP响应报文发送该副本。</li></ol><p>通过上面的描述可以发现，<font color="red">Web缓存器既是客户又是服务器。</font></p><p><font color="bllue"><b>在因特网上部署Web缓存器的原因</b></font></p><ol><li>Web缓存器可以大大减少对客户请求的响应时间，特别是客户与服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时。</li><li>Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。减少通信量，该机构就不必增加带宽，减少了成本。</li><li>Web缓存器能够从整体上大大降低因特网上的wen流量，从而改善了所有应用的性能。</li></ol><h2 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a><font size="5">条件GET方法</font></h2><p>前面说了Web缓存的一系列好处，但是也引入了一个新的问题：即存放在缓存器中的对象副本可能是陈旧的。换句话说，<font color="blue">保存在服务器中的对象自改副本缓存在客户上以后可能已经被修改了。</font><br>好在，HTTP协议有一种机制，允许缓存器证实它的对象是新的。这就是条件GET方法。如果</p><ol><li><b>请求报文中使用GET方法</b></li><li><b>并且请求报文中包含一个”If-Modified-Since”请求头字段</b></li></ol><p>那么该HTTP请求就是一个条件GET请求报文。</p><ol><li>前面说过，当缓存器将对象转发到浏览器时，也在本地缓存了该对象。重要的是，缓存器缓存对象的同时也缓存了最后修改日期。</li><li>下次再次请求该对象时，该对象仍然在缓存器中。由于该对象再这期间可能被修改，所以该浏览器发送一个条件GET执行最新检查。</li><li>该请求里面有一个If-Modified-Since字段，该字段的值，正是上次缓存的最后修改日期。该条件GET报文告诉服务器，仅当自指定日期之后该对象没有被修改过，才发送该对象。</li><li>如果没有修改过，Web服务器向缓存器发送一个响应报文(该响应报文中响应体为空)，状态行为304 Not Modified。告诉缓存器可以使用该对象</li><li>缓存器将本地缓存的对象发送给浏览器。</li></ol><h1 id="DNS-Domain-Name-System-域名系统"><a href="#DNS-Domain-Name-System-域名系统" class="headerlink" title="DNS(Domain Name System)域名系统"></a>DNS(Domain Name System)域名系统</h1><p>因特网上的主机和人类一样，可以用多种方式进行标识。主机的一种标识方法是用它的主机名，也可以用IP地址进行标识</p><h2 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a><font size="5">DNS提供的服务</font></h2><p>主机名是一种方便人们记忆的标识方式，而路由器则更喜欢定长的、有结构层次的IP地址。为了折中这些偏好。我们需要一种能<font color="blue">进行主机名到IP地址转换的目录服务，这就是域名系统的主要任务</font>。DNS是：</p><ol><li><b>一个由分层的DNS服务器实现的分布式数据库</b></li><li><b>一个使得主机能够查询分布式数据库的应用层协议</b></li></ol><p><font color="red">DNS是基于UDP协议的应用层协议，端口号为53。</font>通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。当用户访问一个主机名时</p><ol><li>将主机名发送给DNS应用的客户端</li><li>DNS客户端向DNS服务器发送一个包含主机名的请求</li><li>DNS客户最终会收到一份回答报文，其中包含主机名对应的IP地址</li><li>浏览器收到IP地址后，它能够向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接</li></ol><p>从上面可以看到，DNS的使用会带来额外的网络时延，有时可能时延很长。但是幸运的是，我们想获得的IP地址通常就缓存在一个”附近”的DNS服务器中，这有助于减少DNS的网络流量和DNS平均时延。<br>除了进行主机名到IP地址的转换以外，DNS还提供了一些其他的服务</p><ul><li><font color="bllue"><b>主机别名</b></font><br>有着复杂主机名的主机能拥有一个或多个别名。主机别名通常比主机规范名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的主机规范名以及IP地址。</li><li><font color="bllue"><b>负载分配</b></font><br>DNS也用于再冗余的服务器(如冗余的Web服务器)之间进行负载分配。繁忙的站点被冗余分布在多个服务器上，每台服务器运行在不同的端系统上，都有不同的IP地址。这些IP地址集合同一个主机名相联系。DNS数据库中存储着这些IP地址集合。<br><font color="blue">当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址集合进行响应，但在每个回答中循环这些地址次序。因为这些客户通常总时向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。</font></li></ul><h2 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a><font size="5">DNS工作机理概述</font></h2><p>下面主要讨论DNS的主机名到IP地址转换服务。假设运行在用户主机上的某应用程序(Web浏览器等)需要将主机名转换为IP地址。</p><ol><li>这些应用程序将调用DNS的客户端，并指明需要被转换的主机名</li><li>用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有的DNS请求和回答报文使用UDP协议经53号端口发送</li><li>用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。</li><li>这个映射结果被传递到调用DNS的应用程序。</li></ol><p>从用户主机上调用应用程序的角度看，DNS是一个提供简单地直接转换的黑盒子。事实上，这个黑盒子相当复杂，它<font color="red">由分布在全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成。</font></p><h3 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a><font size="5">分布式、层次数据库</font></h3><p>DNS使用了大量的DNS服务器，它们以层次的方式组织，并且分布在全世界范围内。没有一台服务器拥有因特网上所有主机的映射。DNS服务器分为三种</p><ul><li>根DNS服务器<br>有400多个根服务器分布在全世界，用于提供TLD服务器的IP地址</li><li>顶级域DNS(TLD)服务器<br>每一个顶级域(如com、org、net等)和所有的国家顶级域(如cn、uk等)都有TLD服务器，用于提供权威服务器的IP地址</li><li>权威DNS服务器<br>在因特网上具有公共可访问主机(例如Web服务器、邮件服务器等)的每个组织都必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。<br><img src="/2019/10/07/自顶向下之计算机网络和因特网-应用层/2.png" alt></li></ul><p>另外，还有一种很重要的DNS服务器，即本地服务器。它并不属于DNS服务器层次结构，但是它很重要。每个ISP都有一个本地DNS服务器，当主机和某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。<font color="blue">主机的本地DNS服务器通常”邻近”本主机。</font><br><img src="/2019/10/07/自顶向下之计算机网络和因特网-应用层/3.png" alt>如图请求主机如果要得到服务器主机的IP地址，假设服务器主机名为( aaa.bbb.com)</p><ol><li>主机向本地服务器发送一个DNS查询报文，该报文含有被转换的主机名</li><li>本地服务器将该报文转发到根服务器</li><li>根服务器注意到其com前缀并向本地服务器返回负责com得TLD得IP地址列表</li><li>本地服务器再向这些TLD服务器之一发送查询报文</li><li>该TLD服务器注意到bbb.com前缀，并用权威DNS服务器的IP地址进行响应，该权威服务器是bbb.com</li><li>最后，本地服务器直接向bbb.com重发查询报文,bbb.com用aaa.bbb.com的IP地址进行响应。这样就得到了服务器主机的IP地址。</li></ol><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a><font size="5">DNS缓存</font></h3><p>在上述映射中，为了得到一台主机名的映射，共发送了8份DNS报文，这无疑是增加了查询流量和查询时延。实际上，<font color="blue">为了改善时延性能并减少DNS报文数量，DNS广泛使用了缓存技术。</font><br>DNS缓存的原理很简单，<font color="blue">在一个请求链中，当某DNS服务器接收到一个DNS回答(如包含某主机名到IP的映射)时，它能将映射缓存在本地服务器中。</font><br>如果DNS服务器缓存了一台主机名/IP对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机名的权威服务器。</p><ol><li>要注意的是，主机名和IP地址之间的映射不是永久的，DNS服务器会在一段时间后(一般设置为2天)丢弃该缓存信息</li><li><font color="red">本地服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器</font>。事实上，除了少数DNS查询外，根服务器被绕过了。</li></ol><h2 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a><font size="5">DNS记录和报文</font></h2><h3 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a><font size="5">DNS记录</font></h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录(Resource Record，简称RR)，RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条RR。<br><font color="bllue">资源记录是一个包含了<b>{Name，Value，Type，TTL}</b>这些字段的四元组。</font></p><ul><li><b>TTL</b><br>是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间</li></ul><p><font color="bllue">Name和Value的值取决于Type</font></p><ul><li><b>Type=A</b><br>那么<font color="red">Name是主机名，Value是该主机名对应的IP地址</font>。即一条A类型的资源记录提供了标准主机名到IP地址的映射。</li><li><b>Type=NS</b><br>那么<font color="red">Name是一个域，而Value是一个权威服务器的主机名</font>，该权威服务器能够获取该域中主机IP地址的。</li><li><b>Type=CNAME</b><br>则<font color="red">Value是一个别名为Name的主机对应的规范主机名。</font></li><li><b>Type=MX</b><br>则<font color="red">Value是一个别名为Name的邮件服务器的规范主机名。</font></li></ul><ol><li>如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会包含一条用于该主机名的类型A记录。</li><li>如果DNS服务器不是用于主机名的权威服务器<ul><li>那么该服务器将包含一条NS记录，该记录对应包含主机名的域；</li><li>它还将包含一条类型A记录，该记录提供了上面NS记录中Value字段(权威服务器主机名)的IP地址</li></ul></li></ol><h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a><font size="5">DNS报文</font></h3><p>前面说到了DNS查询和回答报文，DNS只有这两种报文并且两种报文格式相同。<br><img src="/2019/10/07/自顶向下之计算机网络和因特网-应用层/4.png" alt></p><ul><li><font color="blue"><b>前12个字节是首部区域</b></font><ul><li><b>标识符(16比特)</b><br>用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和收到的回答</li></ul></li><li><font color="blue"><b>问题区域</b></font><br>包含正在进行的查询信息，该区域包括<ul><li><b>名字字段</b><br>包含正在被查询的主机名字</li><li><b>类型字段</b><br>指出有关名字的正被询问的问题类型，如主机地址是一个和名字相关(类型A)还是和邮件服务器相关(类型给MX)</li></ul></li><li><font color="blue"><b>回答区域</b></font><br>包含了对最初请求的名字的资源记录，在回答区域可以包含多条RR，因此一个主机名能够有多个IP地址的(前面讨论的冗余Web服务器)</li><li><font color="blue"><b>权威区域</b></font><br>包含了其他权威服务器的记录</li></ul><hr>应用层大致介绍到这里就结束了，主要介绍了HTTP和DNS两个应用层协议，至于书中的P2P、SMTP等其他协议就不赘述了。]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 应用层 </tag>
            
            <tag> HTTP </tag>
            
            <tag> DNS </tag>
            
            <tag> 计算机网络自顶向下方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之归并排序</title>
      <link href="/2019/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面说完了用递归实现的快速排序，这次介绍一下另外一种新的递归排序算法–归并排序。归并排序不仅用到了递归，更重要的是其分治的思想。</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>将待排序数组递归分成左右两部分，使得左右两部分数组分别有序，最后合并左右两数组得到有序的数组。<br>对于长度为n得数组，一共只需要进行n-1次合并。以数组{8, 4, 5, 7, 1, 3, 6, 2}为例</p><ol><li>第一次{8，4}的左右两部分合并为有序数组得到{4，8}</li><li>第二次{5，7}的左右两部分合并为有序数组得到{5，7}</li><li>第三次{4，8，5，7}的左右两部分合并为有序数组得到{4，5，7，8}</li><li>第四次{1，3}的左右两部分合并为有序数组得到{1，3}</li><li>第五次{6，2}的左右两部分合并为有序数组得到{2，6}</li><li>第六次{1，3，2，6}的左右两部分合并为有序数组得到{1，2，3，6}</li><li>最后一次{4，5，7，8，1，2，3，6}的左右两部分合并为有序数组得到{1，2，3，4，5，6，7，8}，最终得到有序数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//对数组&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;进行排序每一轮排序后的输出</span><br><span class="line">初始数组[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line">第一次归并过后[#4, 8#, 5, 7, 1, 3, 6, 2]</span><br><span class="line">第二次归并过后[4, 8, #5, 7#, 1, 3, 6, 2]</span><br><span class="line">第三次归并过后[#4, 5, 7, 8#, 1, 3, 6, 2]</span><br><span class="line">第四次归并过后[4, 5, 7, 8, #1, 3#, 6, 2]</span><br><span class="line">第五次归并过后[4, 5, 7, 8, 1, 3, #2, 6#]</span><br><span class="line">第六次归并过后[4, 5, 7, 8, #1, 2, 3, 6#]</span><br><span class="line">第七次归并过后[#1, 2, 3, 4, 5, 6, 7, 8#]</span><br><span class="line">排序后数组[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 归并算法</span><br><span class="line"> * @param arr  原始数组</span><br><span class="line"> * @param left 左边界</span><br><span class="line"> * @param right 有边界</span><br><span class="line"> * @param temp  中间数组</span><br><span class="line"> */</span><br><span class="line">public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">int mid = (left + right) / 2;   //中间索引</span><br><span class="line">//向左递归</span><br><span class="line">mergeSort(arr, left, mid, temp);</span><br><span class="line">//向右递归</span><br><span class="line">mergeSort(arr, mid + 1, right, temp);</span><br><span class="line">//调用方法合并</span><br><span class="line">merge(arr, left, right, mid, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================================================================================</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 每一次完成归并的方法</span><br><span class="line"> * @param arr 排序的原始数组</span><br><span class="line"> * @param left 左边有序序列的初始索引</span><br><span class="line"> * @param right 右边索引</span><br><span class="line"> * @param mid 中间索引</span><br><span class="line"> * @param temp 中转数组</span><br><span class="line"> */</span><br><span class="line">public static void merge(int[] arr, int left, int right, int mid, int[] temp) &#123;</span><br><span class="line">int i = left;       //初始化左边有序序列的初始索引</span><br><span class="line">int j = mid + 1;    //初始化右边有序序列的初始索引</span><br><span class="line">int t = 0;          //初始化temp数组的当前索引</span><br><span class="line"></span><br><span class="line">//先把左右两边的数据按照规则填充到temp数组中，直到左右两边的有序序列有一方处理完毕为止</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">if (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">t++;</span><br><span class="line">i++;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">t++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//把有剩余的一边依次全部填充到temp数组中</span><br><span class="line">while (i &lt;= mid) &#123;</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;= right) &#123;</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将temp数组元素拷贝到arr数组中</span><br><span class="line">t=0;</span><br><span class="line">int tempLeft = left;</span><br><span class="line">while (tempLeft &lt;= right) &#123;</span><br><span class="line">arr[tempLeft++] = temp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li><font color="bllue"><b>时间复杂度</b></font><br> 最好情况：nlogn<br> 最差情况：nlogn</li><li><font color="bllue"><b>空间复杂度</b></font><br> 一个temp数组，所以为O(n)</li><li><font color="bllue"><b>稳定性</b></font><br> <font color="blue">归并排序是稳定的</font></li></ol><h1 id="算法速度"><a href="#算法速度" class="headerlink" title="算法速度"></a>算法速度</h1><p>同前面一样，用一个大小为80000的随机数组进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//随机生成一个数组，对其进行排序</span><br><span class="line">int[] arr = new int[8000000];</span><br><span class="line">int[] temp = new int[arr.length];</span><br><span class="line">Random random = new Random();</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = random.nextInt(800000);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;====================&quot;);</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line">long ends = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;归并排序共花费：&quot; + (ends - start) + &quot;毫秒&quot;);</span><br><span class="line">&#125;</span><br><span class="line">======</span><br><span class="line">测试结果稳定在16-20毫秒左右</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2019/10/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是23种设计模式中最简单的一种。简单地说，单例模式就是整个程序中有且只有一个实例。该类负责创建自己的对象，同时确保只有一个对象。</p><hr><a id="more"></a><p>单例模式分为两种</p><ul><li><b>懒汉式</b><br>线程不安全，即在使用时在进行初始化。</li><li><b>饿汉式</b><br>线程安全，容易产生垃圾，因为类加载时就将对象初始化。</li></ul><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>饿汉式的实现很简单，类的实例作为该类的静态的成员属性和一个静态的public成员方法用于获取该属性，类加载时就已经生成了类的实例，调用静态方法可以获取该实例。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line">    //私有化构造方法</span><br><span class="line">    private Singleton1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //饿汉式，类加载时就已经创建</span><br><span class="line">    private static Singleton1 s = new Singleton1();</span><br><span class="line"></span><br><span class="line">//通过静态方法获取单例</span><br><span class="line">    public static Singleton1 getInstance() &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，getInstance方法里面的操作是原子性的，因此饿汉式单例模式是线程安全的</p><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>线程不安全的实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton2 &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton2()&#123;&#125;;</span><br><span class="line">    private static  Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    //线程不安全的单例模式</span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;    </span><br><span class="line">            instance=new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于懒汉式是线程不安全的，因此有两种实现方式</p><ul><li><font color="blue"><b>给相应部分加上同步代码块，使之变成线程安全</b></font><br>这里用的是双重检查加锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//双重检查加锁</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton2()&#123;&#125;;</span><br><span class="line">    private static volatile Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    //一个线程安全的单例模式</span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton2.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance=new Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上实现代码只需要在第一次实例化单例的时候会执行到同步代码部分。</p><ul><li><font color="blue"><b>利用内部类实现</b></font><br>使用静态内部类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private Singleton3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static class inner&#123;</span><br><span class="line">        private static Singleton3 instance=new Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        return inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看出，在获取方法中的操作也是原子性的，因此是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/10/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/10/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>由于计算机的存储设备与处理器的运算速度有几个数量级差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要用到的数据复制到缓存中，让运算能够快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就不用等待患难的内存读写了。</p><a id="more"></a><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>上面说的基于高速缓存的存储交互很好的解决了处理器和内存的速度矛盾，但是又引入了新的问题：<font color="blue">缓存一致性</font>。在多个处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存。那么<font color="red">当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各自缓存数据不一致，如果发生这种情况，那同步回主内存时又以以谁为准呢？</font><br>为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。</p><ul><li><font color="bllue"><b>内存模型</b></font><br>可以理解为在特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。<br><img src="/2019/10/01/Java内存模型/1.png" alt>处理器、高速缓存以及主内存间的交互关系</li><li><font color="bllue"><b>指令重排序</b></font><br>为了<font color="blue">使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但是并不保证程序中各个语句的执行顺序和输入代码中的顺序一致。</font>Java虚拟机的即时编译器中也有类似的指令重排序优化。</li></ul><h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h1><p>Java虚拟机规范中定义了一种Java内存模型(Java Memory Model)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致性的内存访问效果。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a><font size="5">主内存与工作内存</font></h2><p>Java内存模型的主要目标是<font color="blue">定义程序中各个变量的访问规则</font>，即<font color="blue">在虚拟机中将变量存储到内存和内存中取出变量这样的底层细节。</font>这里说的变量,和Java编程中所说的变量有所不同，它包括了<font color="bllue">实例字段、静态字段和构成数组对象的元素</font>，不包括局部变量和方法参数，因为这两者是线程私有的。<br>Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存(和前面说的处理器高速缓存类似)，线程的工作内存中保存了被该线程使用到的变量的主内存的拷贝副本。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成。<br><img src="/2019/10/01/Java内存模型/2.png" alt>线程、主内存以及工作内存三者关系</p><h2 id="内存间交互"><a href="#内存间交互" class="headerlink" title="内存间交互"></a><font size="5">内存间交互</font></h2><p>关于一个变量如何从主内存拷贝到工作内存、如何从工作内存同不会主内存之类的实现细节，Java内存模型中定义了8种操作来完成，这8种操作都是原子性的。</p><ul><li><font color="bllue"><b>lock(锁定)</b></font><br>作用于主内存的变量，把变量标识为一条线程独占状态</li><li><font color="bllue"><b>unlock(解锁)</b></font><br>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定</li><li><font color="bllue"><b>read(读取)</b></font><br>作用于主内存的变量，他一个变量的值从主内存传输到线程的工作内存</li><li><font color="bllue"><b>load(载入)</b></font><br>作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><font color="bllue"><b>use(使用)</b></font><br>作用于工作内存的变量，把工作内存的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时将会执行这个操作</li><li><font color="bllue"><b>assign(赋值)</b></font><br>作用于工作内存的变量，把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作</li><li><font color="bllue"><b>store(存储)</b></font><br>作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><font color="bllue"><b>write(写入)</b></font><br>作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul><p>同样Java内存模型还规定了在执行上述8种操作时必须满足一下条件</p><ul><li>不允许read和load，store和write这两对操作之一单独出现，即如果执行了read操作，那么就必须执行load(但两个操作不一定要连续执行)。即<font color="blue">不允许一个变量从主内存读取但工作内存不接受，或者从工作内存发起回写但主内存不接受的情况。</font></li><li>不允许一个线程丢弃它最近的assign(赋值)操作，即<font color="blue">变量在工作内存中改变了之后必须把该变化同步回主内存</font></li><li>不允许线程<font color="blue">无原因地(没有发生过assign操作)把数据从工作内存同步回主内存</font></li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量。也就是说，<font color="blue">对一个变量实施use、store操作之前，必须先执行过了assign和load操作</font></li><li><font color="blue">一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次</font>，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li><li><font color="blue">对一个变量执行unlock之前，必须先把此变量同步回主内存中(执行store、write操作)</font></li></ul><h2 id="Java指令重排序"><a href="#Java指令重排序" class="headerlink" title="Java指令重排序"></a><font size="5">Java指令重排序</font></h2><p>在执行过程中为了提高性能，编译器和处理器经常会对指令进行重排序，重排序分成三种类型</p><ul><li><b>编译器优化的重排序</b>，编译器在不改变单线程程序语义前提下，可以重新安排语句的执行顺序。</li><li><b>指令级并行的重排序</b>，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(可以理解为指令A不用到指令B的数据)，处理器可以改变语句对应机器指令的执行顺序。</li><li><b>内存系统的重排序</b>，由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从Java源码到最终实际执行的指令序列，会经过下面三种重排序<br><img src="/2019/10/01/Java内存模型/3.png" alt></p><hr><p><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">参考博客</a><br>Java内存模型大致能介绍就这些，关于并发和多线程最近开始看书，有了初步的理解后逐步介绍。深入理解JVM虚拟机这本书也算是初步看完了，继续努力。</p>]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的语法糖</title>
      <link href="/2019/09/30/Java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2019/09/30/Java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<p>语法糖，是指在计算机中添加某种语法这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，语法糖能够增加程序的可读性。Java中常用的语法糖有泛型、变长参数、自动拆箱/装箱等。下面就介绍一下这些语法糖的原理。</p><a id="more"></a><h1 id="泛型和类型擦除"><a href="#泛型和类型擦除" class="headerlink" title="泛型和类型擦除"></a>泛型和类型擦除</h1><p>泛型时JDK1.5的新增特性，本质是参数化类型的应用。即将所操作的数据类型指定为一个参数，这种参数可以用在类、接口、方法的创建中，分别被称为泛型类、泛型接口和泛型方法。<br>Java中的泛型被称为伪泛型，它<font color="bllue">只在Java源码中存在，在编译后的字节码文件中就已经被替换为原生类型了(裸类型)，并且在相应地方插入了强制转型代码</font>。因此对于运行期的Java语言来说，ArrayList<integer>和ArrayList<string>就是同一个类，所以Java中泛型实现方法被称为类型擦擦除。<br>举一个Java泛型的例子</string></integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;hello&quot;, &quot;你好&quot;);</span><br><span class="line">map.put(&quot;how are you&quot;, &quot;吃了没&quot;);</span><br><span class="line">System.out.println(map.get(&quot;hello&quot;));</span><br><span class="line">System.out.println(map.get(&quot;how are you&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面代码，编译成Class文件，然后再反编译进行反编译后，会变成下main这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;hello&quot;, &quot;你好&quot;);</span><br><span class="line">map.put(&quot;how are you&quot;, &quot;吃了没&quot;);</span><br><span class="line">System.out.println((String) map.get(&quot;hello&quot;));</span><br><span class="line">System.out.println((String) map.get(&quot;how are you&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看到，程序中所有的泛型又变回的原生类型，并且加上了强制转型。这说明，<font color="blue">在编译后的字节码文件中是没有泛型的，即反省在编译过程中已经被擦除。</font><br>既然知道了泛型的实现原理，那么看一看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void method(List&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;List&lt;String&gt; list&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;List&lt;Integer&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，上面这段代码是无法通过编译的，这是为什么呢？<font color="blue">因为编译期对泛型进行类型擦除后，这两个方法实际上是一模一样的，不构成重载</font>。因此自然无法通过编译。<br>让我们再回顾一下<font color="blue">Signature属性，它能够存储一个方法在字节码层次上的特征签名，这个属性中保存的参数并不是原生类型，而是包括了参数化类型的信息。</font><br>另外，通过Signature属性可以看出，擦除法所谓的擦除，<font color="red"><b>仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据还是保留了泛型信息，这也是我们能通过反射取得参数化类型的根本依据。</b></font></p><h1 id="自动装箱、拆箱和遍历循环"><a href="#自动装箱、拆箱和遍历循环" class="headerlink" title="自动装箱、拆箱和遍历循环"></a>自动装箱、拆箱和遍历循环</h1><ul><li><p><b>自动装箱</b><br>实际上调用的是<font color="blue">包装类的valueOf()</font>方法；</p></li><li><p><b>自动拆箱</b><br>调用的则是<font color="blue">包装类的xxxValue()</font>方法。下面以Integer和int为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">//自动装箱</span><br><span class="line">Integer.valueOf(i)</span><br><span class="line">=======================</span><br><span class="line">Integer=new Integer(4)</span><br><span class="line">//自动拆箱</span><br><span class="line">i=Integer.intValue()</span><br></pre></td></tr></table></figure></li><li><p><b>遍历循环for-each</b><br>使用的则是<font color="blue">Iterator迭代器</font>来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=new ArrayList;</span><br><span class="line">for(int i:list)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//实际上是通过迭代器实现</span><br><span class="line">for(Iterator localIterator=list.iterator();localIterator.hasNext;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><b>使用包装类要注意两点</b></p><ul><li>包装类的”==”再不遇到算术运算的情况下不会自动拆箱</li><li>包装类的”equals()方法”不处理数据转型的关系</li></ul></li></ul><p>给出下面一段测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer a = 1;</span><br><span class="line">Integer b = 2;</span><br><span class="line">Integer c = 3;</span><br><span class="line">Integer d = 3;</span><br><span class="line">Integer e = 321;</span><br><span class="line">Integer f = 321;</span><br><span class="line">Long g = 3L;</span><br><span class="line"></span><br><span class="line">System.out.println(c == d); //true ,-128~127之间用到Integer内的缓存池</span><br><span class="line">System.out.println(e == f); //false</span><br><span class="line"></span><br><span class="line">//遇到算术运算，自动拆箱</span><br><span class="line">System.out.println(c == (a + b));   //true</span><br><span class="line">//equals不会处理数据转型</span><br><span class="line">System.out.println(c.equals(a + b));//true</span><br><span class="line">System.out.println(g.equals(a + b));//false</span><br><span class="line">//遇到算术运算自动拆箱，进行数据转型</span><br><span class="line">System.out.println(g == a + b);     //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM虚拟机四</title>
      <link href="/2019/09/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9B/"/>
      <url>/2019/09/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>这一节主要介绍一下虚拟机是怎么执行Class文件的字节码以及《深入理解JVM虚拟机》后面一些知识，因为后面很多都不是很理解，所以结合在一起记录，如果以后再次翻看弄懂了一些，就再另外记录吧。</p><a id="more"></a><p>执行引擎是Java虚拟机最核心的组成部分之一，Java虚拟机在执行Java代码时可能会有解释执行(通过解释器执行)和编译执行(通过编译器执行)两种选择，或者两者都有。所有Java虚拟机的执行引擎都是一致的</p><ul><li>输入过程：输入字节码文件</li><li>处理过程：字节码解析，执行相应指令</li><li>输出过程：输出执行结果</li></ul><h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><ul><li><font color="bllue"><b>栈帧</b></font><br>是<font color="blue">用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素</font>。每一个方法从调用开始到执行完成的过程，对应着栈帧在虚拟机中从入栈到出栈的过程。栈帧中包括<ul><li><b>方法的局部变量表</b></li><li><b>操作数栈</b></li><li><b>动态连接</b></li><li><b>方法返回地址等</b></li></ul></li></ul><p>另外前面说到过，在编译阶段，局部变量表和操作数栈的大小都已经确定并写在Code属性中，因此<font color="bllue">一个栈桢分配多少内存不会受到运行时数据的影响。</font><br>对于执行引擎来说，只有线程栈顶的栈帧才是有效的，称为当前栈帧，与栈帧相关联的方法称为当前方法。<br>虚拟机使用<font color="bllue">局部变量表完成参数值到参数列表的传递过程</font>，如果是一个实例方法，那局部变量表第0位索引的Slot默认用于传递方法所属对象实例的引用，在方法中可以通过this关键字来访问这个隐含的参数。其余参数按照参数表顺序排列，占用从1开始的Slot。参数表分配完毕后再根据方法体内定义变量的顺序和作用域分配其余Slot。<br><font color="blue">局部变量表的Slot是可以重用的，如果当前字节码PC计数器已经超过了方法体中的某个变量的作用域，那么该变量对应的Slot就可以交给其他变量使用。</font></p><ol><li>对于类变量(sttaic)，会有两次赋值<ul><li><b>一次是在准备阶段赋初始值</b></li><li><b>一次是在初始化阶段赋予程序设置的值</b><br>因此<font color="red">初始化阶段不为类类变量赋值也可以直接使用。</font></li></ul></li><li>对于<font color="red">局部变量，如果定义了但没有赋初始值是不能使用的。</font></li><li>对于类成员变量，也会有两次赋值<ul><li><b>第一次是new指令过后，&lt; init&gt;方法执行之前，对象的字段(即成员变量)已经被赋初始化值</b></li><li><b>第二次是在&lt; init&gt;方法(实例构造器)，赋予字段程序设置的值</b><br>因此<font color="red">对于成员变量，不赋初值也能直接使用</font></li></ul></li></ol><ul><li><p><font color="bllue"><b>操作数栈</b></font><br>和局部变量表一样，操作数栈的大小在编译后就已经确定，记录在Code属性中。<font color="blue">操作数栈的每一个元素可以是任意的Java数据类型。</font><br>当一个方法开始执行时，方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈出栈操作。<font color="bllue">Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，这里指的就是操作数栈。</font></p></li><li><p><font color="bllue"><b>动态连接</b></font><br><font color="blue">每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用。</font>前面说到，Class文件的常量池中有大量符号引用，字节码中的方法调用指令就常以常量池中指向方法的符号引用作为参数，这些符号引用</p><ul><li><b>一部分会在类加载阶段或第一次使用时转换为直接引用，即静态解析</b></li><li><b>另外一部分将在每次运行期间转换为直接引用，这部分称为动态连接</b></li></ul></li><li><p><font color="bllue"><b>方法返回地址</b></font><br>当一个方法开始执行，有两种方式可以退出这个方法。</p><ul><li><b>执行引擎遇到任意一个方法返回的字节码指令。</b><br>这时可能会有返回值传递给调用该方法的方法，至于是否有返回值或者返回值类型取决于返回指令的类型。这种退出方式被称为正常完成出口。<br><font color="blue">此时调用该方法的方法PC计数器的值可以作为返回地址。</font></li><li><b>方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。</b><br>无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码产生的异常(throw语句)只要在方法的方法表中内有搜索到匹配的异常处理器(即不属于Java代码中catch语句列举的异常)，就会导致方法退出。这种退出方式被称为异常完成出口。是不会给上层调用方法任何返回值的。<br><font color="blue">此时，返回地址是通过异常处理器来确定的。</font></li></ul></li></ul><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p><font color="blue">方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法(因为Java中重写和重载机制)</font>，不涉及方法的执行。前面说过，一切调用在Class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址(直接引用)，这就导致Java方法调用时，需要在类加载期，甚至是运行期才能确定目标方法的直接引用。</p><ul><li><p><font color="bllue"><b>解析</b></font><br>在类加载的解析阶段，会将一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序运行之前就有一个确定的调用版本，并且这个调用版本在运行期间是不可变的。即编译器可知，运行期不可变，这类方法主要有两类</p><ul><li><b>静态方法</b><br>与类型直接关联</li><li><b>私有方法</b><br>外部不可被访问</li><li><b>实例构造器</b></li><li><b>父类方法</b><br>这四类方法<font color="blue">适合在类加载阶段进行解析</font>。这四类方法又被称为<font color="red">非虚方法</font>，其他方法都是虚方法。<font color="bllue">除此之外final方法也是非虚方法。</font></li><li><b>解析调用是静态过程</b><br>在编译期就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为直接引用。这时第一次的解析结果会被缓存在运行时常量池中，并将常量标识为已解析，从而避免重复解析。</li><li><b>分派调用可能是静态的也可能是动态的</b></li></ul></li><li><p><font color="bllue"><b>静态分派</b></font><br>Java具备三大特征：继承、封装和多态。分派将会揭示重写和重载在Java虚拟机中是如何实现的。来测试一下下面一段代码，然后看一看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispath &#123;</span><br><span class="line">    static abstract class Human&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human human) &#123;</span><br><span class="line">        System.out.println(&quot;Human&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello(Man human) &#123;</span><br><span class="line">        System.out.println(&quot;Man&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello(Woman human) &#123;</span><br><span class="line">        System.out.println(&quot;Woman&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman=new Woman();</span><br><span class="line"></span><br><span class="line">        StaticDispath s=new StaticDispath();</span><br><span class="line">        s.sayHello(man);</span><br><span class="line">        s.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行结果<br><img src="/2019/09/30/深入理解JVM虚拟机四/1.png" alt>有三个重载的方法，为什么会选择执行参数类型为Human的重载呢？先介绍一下两个概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = new Man();</span><br></pre></td></tr></table></figure><p>上面这段代码中的”Human”被称为静态类型，new后面的”Man”被称为实际类型。</p><ul><li>静态类型<br>仅仅在使用时发生变化，而变量本身的静态类型不会改变，并且静态类型在编译期可知</li><li>实际类型<br>在运行期才能确定变化的结果，编译器在编译时并不知道实际类型是什么</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在这里实际类型从Man变成了Woman，而静态类型仍是Hunman</span><br><span class="line">Human man=new Man()</span><br><span class="line">man=new Woman()</span><br><span class="line"></span><br><span class="line">//这时候静态类型仅仅在使用时发生了变化，但是man和woman仍旧是Human类型。</span><br><span class="line">//如果这样调用，那么输出结果就是Man和Woman而不是Human了。</span><br><span class="line">s.sayHello((Man)man);</span><br><span class="line">s.sayHello((Woman)woman);</span><br></pre></td></tr></table></figure><p>虚拟机(确切的说是编译器)在重载时通过参数的静态类型(即参数字面值)作为判定依据而不是实际类型。并且静态类型是编译期可知的，因此，<font color="bllue">在编译期Javac编译器会根据参数的静态类型选择使用哪个重载方法。</font><br>所有依赖静态分派来定位方法执行版本的分派动作称为静态分派。<font color="blue">静态分派的典型就是<b>方法重载</b></font></p><ul><li><font color="bllue"><b>动态分派</b></font><br>同样的，还用一段代码来做测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line"></span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man=new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Human&#123;</span><br><span class="line">    protected abstract void sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Man extends Human&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;man&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Woman extends Human &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;woman&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>很简单的一段代码，用到了重写，运行结果<br><img src="/2019/09/30/深入理解JVM虚拟机四/2.png" alt>这里显然不是根据静态类型来决定的，因为静态类型都是Human的两个变量在调用sayHello时执行了不同的方法，并且man两次调用sayHello方法输出结果不同。<br>来看一下字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #6                  // Method Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #6                  // Method Human.sayHello:()V</span><br></pre></td></tr></table></figure><p>其中aload_1和aload_2就是将man和woman两个对象的引用入操作数栈，这两个对象是将要执行的sayHello方法的所有者。<br>17和21行的invokevirtual是方法调用指令，从字节码角度来看，无论是指令(都是invokevirtual指令)还是参数(注释显示了参数是Human.sayHello的符号引用)都完全一样，两行指令一模一样。但是执行的结果却不同。<br>这就要从invokevirtual的多态查找过程说起，该指令运行使得解析过程大致分为一下几个步骤</p><ol><li>找到操作数栈顶的<font color="blue">第一个元素指向的对象的实际类型</font>(在这里man的实际类型是Man，woman的实际类型是Woman)，记为C。</li><li>如果在C中找到了与常量中的描述符和简单名称都相符(Human.sayHello:()V)的方法，则进行访问权限校验，如果通过返回该方法的直接引用，否则抛出异常。</li><li>否则，按照继承关系从下往上依次对C的父类进行第二步操作</li><li>如果始终没有找到，抛出异常。</li></ol><p>从上面过程可以发现，该指令第一步就是在<font color="red">运行期间找到执行方法所有者的实际类型，所以两次invokevirtual虽然参数一模一样，但是却将符号引用解析到了不同的直接引用上，这就是<b>Java重写的本质</b>。</font><br>这种运行期间根据实际类型确定具体实行哪个方法的分派过程称为动态分派。</p>]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM虚拟机三</title>
      <link href="/2019/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89/"/>
      <url>/2019/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>前面已经介绍了JVM的内存布局、自动内存管理、垃圾回收以及Class文件结构，那么虚拟机又是怎么加载Class文件的？Class文件的信息进入到JVM中会不会发生变化呢？那么这次就记录一下<b>虚拟机类加载机制</b>。</p><hr><a id="more"></a><font color="bllue">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析以及初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</font>在Java中，类型的加载、连接、初始化过程都是在程序运行期间完成的，这种做法会令加载时性能开销增加一些，但是却为Java程序提供了高灵活性。例如，对于一个接口，可以等到运行时在指定其实际的实现类。可以通过类加载器在程序运行时从其他地方加载一个二进制流作为代码的一部分。<h1 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期如下<br><font color="red"><b>加载==&gt;连接(验证==&gt;准备==&gt;解析)==&gt;初始化==&gt;运行==&gt;使用==&gt;卸载</b></font><br>其中验证、准备、解析三个阶段统称为连接。并且加载、验证、准备、解析、初始化这5个阶段的顺序是确定的。<br>那么什么情况下需要执行类加载的第一个过程：加载呢？<br>对于初始化阶段，虚拟机严格规定了<font color="red"><b>有且只有</b></font>5种情况必须立即对类进行初始化(初始化之前自然要先进行加载、连接操作)</p><ul><li>遇到<font color="blue">new、getstatic、putstatic、invokestatic这四条指令</font>时，如果类没有进行过初始化，则需要先对类进行初始化。可以概括为一下几个方面：<ul><li><b>使用new关键字实例化对象时</b></li><li><b>读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)时</b></li><li><b>调用一个类的静态方法时</b></li></ul></li><li><font color="blue">使用java.lang.reflect包的方法进行反射调用时</font>，如果类没有进行过初始化，则需要先对类进行初始化。</li><li><font color="blue">初始化一个类时，如果发现其父类还没有进行过初始化，则需先对其父类进行初始化。</font></li><li>当虚拟机启动时，用户需要指定一个要执行的<font color="blue">主类(含main方法的类)，虚拟机会先初始化这个类</font></li><li>如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStati或REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先对类进行初始化。</li></ul><p>上面5种场景的行为称为对一个类的主动引用。<font color="blue">除此之外，所有引用类的方法都不会触发其初始化，称为被动引用</font>，如：</p><ul><li>通过子类引用父类的静态字段，子类不会被初始化。<font color="bllue">对于静态字段，只有直接定义这个字段的类才会被初始化。</font></li><li><font color="bllue">通过数组来引用类，不会触发此类的初始化。</font></li><li><font color="bllue">常量在编译期进入调用类的常量池，本质上讲没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。</font></li></ul><p>(具体示例代码见书P211。)<br>接口的类加载过程和类有所不同，主要体现在第3点，<font color="red">一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候才会初始化。</font></p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>下面说一下类加载的全过程：加载、验证、准备、解析和初始化。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a><font size="5">加载</font></h2><p>加载时类加载过程的一个阶段，在加载阶段，虚拟机可以完成三件事</p><ul><li><b>通过一个类的全限定名获取此类的二进制字节流</b></li><li><b>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</b></li><li><b>在内存中生成一个代表此类的java.lang.Class对象，作为方法区此类各种数据的访问入口。</b></li></ul><p>相比于类加载过程的其他阶段，一个非数组类的加载阶段(确切的说是加载阶段中获取类的二进制字节流的操作)是开发人员可控性最强的。因为我们可以使用系统的的引导类加载器来完成，也可以使用自定义的类加载器完成。<br>对于数组类而言，<font color="bllue">数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的</font>。但数组类和类加载器仍有密切的关系。数组类的元素类型(去掉所有[])最终要靠类加载器去创建。一个数组类C的创建过程如下</p><ul><li>如果数组的组件类型(去掉一对[]的类型)是引用类型，那就递归采用前面说的加载过程去加载这个组件类型，<font color="bllue">数组C将在加载组件类型的类加载器的类名称空间上被标识</font></li><li>如果数组的组件类型不是引用类型(如int[] a或二维数组等)，<font color="bllue">Java虚拟机将会把数组标记为与引导类加载器关联</font></li><li>数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那数组可见类型默认public。</li></ul><p><font color="blue">加载完成后，虚拟机外部的二进制字节流就被加载进方法区中。然后在内存中实例化一个java.lang.Class对象</font>，(对于HotSpot而言，该对象存放在方法区中)</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><font size="5">验证</font></h2><p>加载阶段和连接阶段的部分内容是交叉进行的，如一部分字节码文件格式的验证动作。<br>验证时连接阶段的第一步，是虚拟机对自身保护的一项重要工作。这一阶段的目的<font color="bllue">是为了确保Class文件的字节流中包含的信息符合虚拟机要求，并且不会危害虚拟机自身安全。</font>该阶段分为四步：</p><ol><li><b>文件格式验证</b></li><li><b>元数据验证</b></li><li><b>字节码验证</b></li><li><b>符号引用验证</b></li></ol><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a><font size="5">文件格式验证</font></h3><p>验证字节码是否符合Class文件格式，并且能被当前版本虚拟机处理，可能包含一下验证点</p><ul><li>是否以魔数”0xCAFEBABE”开头</li><li>主次版本号是否在当前虚拟机处理范围</li><li>常量池常量是否有不被支持的常量类型(检查tag标志)….</li></ul><p>实际上，该阶段的验证点有很多，该阶段的主要目的是<font color="blue">保证输入的字节流能够正确的解析并存储与方法区内</font>，格式上符合一个Java类型信息的要求。该方法是基于二进制字节流进行的，<font color="red">只有通过了该阶段，字节流才会进入方法区，后面的三个阶段都是基于方法区的存储结构进行</font>，不会直接操作字节流。</p><h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a><font size="5">元数据验证</font></h3><p>该阶段<font color="bllue">对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范</font>，可能的验证点</p><ul><li>该类是否有父类(除了java.lang.Object以外，所有类都应该有父类)</li><li>该类是否继承了不允许被继承的类(final类)</li><li>该类如果不是抽象类，那么是否实现了其父类/父接口的抽象方法……</li></ul><p>该阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a><font size="5">字节码验证</font></h3><p>该阶段最为复杂，主要目的是<font color="blue">确定程序语义是否合法、符合逻辑，该阶段对方法体进行校验分析，确保被校验的方法在运行时不会做出危害虚拟机安全的事</font>。可能验证的点</p><ul><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的，例如不能把对象赋值给与他毫无继承关系、完全不相干的数据类型，这是不合法的……</li></ul><p>如果一个类不能通过字节码验证，那么这个类肯定有问题，但是通过了字节码验证，并不能够说明其一定安全。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a><font size="5">符号引用验证</font></h3><p>该阶段发生在虚拟机将符号引用转化为直接引用的时，这个转化动作将在连接的第三个阶段–解析阶段发生。<br>符号引用验证可以看作是对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验，通常需要校验以下内容</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性(public、private…)是否可以被当前类访问……</li></ul><p>符号引用验证的<font color="blue">目的是确保解析动作能够正常进行</font>，如果无法通过该阶段验证，那么会抛出异常。<br>最后，对于虚拟机类加载机制来说，<font color="blue">验证阶段非常重要、但却不一定必要</font>。如果所运行的全部代码都已经被反复使用和验证过，那么可以通过”-Xverify:none”参数来关闭大部分验证措施。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><font size="5">准备</font></h2><p>准备阶段是<font color="blue">正式为类变量分配内存并设置类变量初始值的阶段</font>。这些变量所使用的内存都在方法区分配。这里说的<font color="red">初始化值通常情况下是数据类型的零值。</font><br>例如一个类变量private static int value=123。在准备阶段过后的初始值是0值而不是123。而将<font color="red">value赋值为123的操作是在初始化阶段的类构造器&lt; clinit&gt;方法执行。</font><br>如果一个<font color="blue">类字段有ConstantValue属性，那么准备阶段变量value就会被初始化为ConstantValue属性所指定的值。</font></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a><font size="5">解析</font></h2><p>前面说过，Class文件中不会保存各个方法、字段最终在内存的哪个地方，因此这些字段、方法的符号引用不经过不经过运行期转换是无法得到字段、方法的内存入口。解析阶段是<font color="bllue">虚拟机将常量池内的符号引用替换为直接引用的过程。</font></p><ul><li><b>符号引用</b><br>用一组符号来描述所引用的目标(如字段表集合中对字段的描述)，符号引用可以是任意形式的字面量，只要能无歧义的定位到所引用的目标。符号引用的目标不一定已经被加载进内存。</li><li><b>直接引用</b><br>可以是指向目标的指针的相对偏移量、或能间接定位目标的句柄，能够直接在内存中定位到目标。如果有了直接引用，那么引用的目标肯定在内存中存在。</li></ul><p>需要注意的是，虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行<b>anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、new、putfield、putstatic</b>等<font color="bllue">操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。</font><br>对一个符号引用进行多次请求解析是很常见的，除了invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)从而避免重复解析，这些解析被称为<font color="red">静态解析</font>。<br>而<font color="blue">对于invokedynamic指令，必须等到程序实际运行到这条指令时，才会对符号引用进行解析，并且不会缓存。每一次运行时都要讲符号引用转换为直接引用</font>，这种解析被称为<font color="red">动态连接<font>。(后面讲到动态分派和重写时会介绍)</font></font></p><p><font color="bllue"><b>解析动作主要针对</b></font></p><ul><li><b>类或接口</b></li><li><b>字段</b></li><li><b>类方法</b></li><li><b>接口方法等</b></li></ul><p>具体对类、接口、类字段、类方法的解析见书P221</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font size="5">初始化</font></h2><p>该阶段是类加载过程的最后一步，前面的类加载过程，除了加载阶段用户可以参与，其余动作完全由虚拟机控制。到了初始化阶段，才真正开始执行类中定义的Java代码(Java代码编译后的字节码更准确一些)。<br>在准备阶段，变量已经赋过一次值，而在初始化阶段，则根据程序员通过程序制定的计划去初始化类变量和其他资源。<font color="bllue">初始化阶段是执行类构造器&lt; clinit&gt;方法的过程。</font></p><ul><li><font color="bllue"><b>&lt; clinit&gt;()方法</b></font><ul><li>由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。编译器手机的顺序是由语句在源文件中出现的顺序决定的。静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，语句块只能赋值不能访问。(书P225)</li><li>该方法和实例构造器不同，不需要显式的调用父类构造器。<font color="bllue">虚拟机会保证在子类的&lt; clinit&gt;()方法执行前，父类的&lt; clinit&gt;()方法已经执行完毕</font>。因此在虚拟机中第一个执行&lt; clinit&gt;()方法的类肯定是Object类。</li><li>由于父类的&lt; clinit&gt;()方法先执行，也就意味着<font color="blue">父类中定义的静态语句块和静态变量赋值要优先于子类</font></li><li>&lt; clinit&gt;()方法对于接口或类来说不是必须的，<font color="bllue">如果类中没有静态代码块、也没有对类变量的赋值操作，那么编译器可以不生成&lt; clinit&gt;()方法</font></li><li>对于接口，执行接口的&lt; clinit&gt;()方法不需要先执行父接口的&lt; clinit&gt;()方法，只有当父接口中定义的变量使用时父接口才会被初始化。</li><li>同样的，接口的实现类在初始化时也一样不会执行接口的&lt; clinit&gt;()方法。</li><li><font color="red">同一个类加载器下，一个类型只会初始化一次。</font></li></ul></li></ul><p>至此，一个类加载的全过程就完成了。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><font size="5">类加载器</font></h1><p>加载阶段中”通过一个类的全限定名来获取类的的二进制字节流”这个动作是在虚拟机外部实现的，实现这个动作的代码模块被称为类加载器。<br><font color="blue">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</font>即如果比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，<font color="blue">即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</font><br>这里说的相等</p><ul><li>代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果</li><li>使用instanceof关键字做对象所属关系判定结果……</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><font size="5">双亲委派模型</font></h2><p>对于开发人员来说，类加载器分为三种</p><ul><li>启动类加载器(Bootstrap ClassLoader)=&gt;最顶层<br>将存放在<java_home>\lib目录中的虚拟机识别的类库加载到虚拟机内存中</java_home></li><li>扩展类加载器(Extension ClassLoader)=&gt;第二层<br>负责加载lib目录下ext目录中的类库，开发者可以直接使用扩展类加载器</li><li>应用程序类加载器(Application ClassLoader)=&gt;第三层<br>这个类加载器时ClassLoader中的getSystemClassLoader()方法返回值，所以也叫系统类加载器。<font color="bllue">如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。</font></li><li>自定义类加载器=&gt;最底层</li></ul><ul><li><font color="bllue"><b>双亲委派模型的工作过程</b></font><br>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是这样，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。</li><li><font color="bllue"><b>好处</b></font><br>使用双亲委派模型来组织类加载器的关系，Java类随着它的类加载器一起具备了一种带优先级的层次关系。例如java.lang.Object，无论哪一个类加载器要加载这个类，绥中都是委派给顶层的启动类加载器完成，因此Object类在程序中总是一个类。</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><font size="5">破坏双亲委派模型</font></h2><p>没怎么理解，见书P234</p><hr>至此，类加载机制也就介绍完了。主要介绍了类的加载、验证、准备、解析和初始化过程中虚拟机是怎么做的，以及类加载器的工作原理和双亲委派模型。]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM虚拟机二</title>
      <link href="/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C/"/>
      <url>/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>前面说了JVM虚拟机的内存布局和自动内存管理机制，这次就着重记录一下Class文件的结构，毕竟JVM只是工具，而Class文件才是被执行的主体。</p><hr><a id="more"></a><h1 id="无关性基石"><a href="#无关性基石" class="headerlink" title="无关性基石"></a>无关性基石</h1><p>这里说的无关性，包括两个方面</p><ul><li><b>平台无关性</b></li><li><b>语言无关性</b></li></ul><p><font color="bllue"><b>平台无关性</b></font><br>你一定听过一句话–Write Once,Run AnyWhere。以前，一个应用程序要想在要想在不同的操作系统上运行，就要编写不同的代码。因为代码编译后得到的是本地机器码，而不同的操作系统机器码是不一样的，因此如果一个程序需要在多个系统上运行，就要编写不同的代码。平台无关性，顾名思义，就是同样的代码可以在不同的操作系统上正确的运行。这就要通过虚拟机来实现。<br>我们编写的代码(并不是特指Java代码)，<font color="blue">会通过编译器编译为字节码，而虚拟机能够载入和执行字节码，从而实现了平台无关性。</font>运行在不同操作系统上的JVM虚拟机是不一样的。JVM虚拟机接收到字节码后，再将字节码转换为本地的机器码。虚拟机就相当于代码和机器码之间的转换器，能够将同一种字节码根据不同的操作系统转换成不同的机器码。<br>通过上述的介绍不难发现，<font color="bllue">各种不同平台的虚拟机和所有平台都使用的统一的程序存储格式–字节码是构成平台无关性的基石。</font><br><font color="bllue"><b>语言无关性</b></font><br>语言无关性的基石仍然是虚拟机和字节码存储格式。<font color="bllue">Java虚拟机只认识字节码，只和”Class文件”这种特定的二进制文件关联</font>。即如果你将其他语言编译成字节码交付给Java虚拟机，它一样能够执行。事实也是这样，Java程序通过Javac编译器将Java编译成字节码，其他语言如JRuby通过jruby编译器将JRuby编译成字节码，JVM都能够执行。</p><p>Java中的各种变量、关键字、和运算符号最周都是由多条字节码命令组合而成，因此字节码命令的语言描述能力肯定比Java更加强大。有一些Java语言本身无法支持的语言特性并不代表字节码本身无法识别。</p><h1 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目都严格的按照顺序紧凑的排列在Class文件中，中间没有任何分隔符，也就是说，整个Class文件所存储的内容几乎都是程序运行时必要的数据。对于需要占用8位以上的数据项，会按照<font color="red">高位在前</font>的方式将其分割成若干个8位字节进行存储。</p><h2 id="魔数和Class文件版本"><a href="#魔数和Class文件版本" class="headerlink" title="魔数和Class文件版本"></a><font size="5">魔数和Class文件版本</font></h2><ul><li><font color="bllue"><b>魔数</b></font><br>每个Class文件的<font color="blue">前四个字节</font>，值为”0xCAFEBABE”(可以称为咖啡宝贝…)。它的唯一作用是<font color="blue">确定这个文件是否为一个能被虚拟机接受的Class文件。</font></li><li><font color="bllue"><b>Class文件版本</b></font><br>紧接着魔数的<font color="blue">四个字节，前两个字节是Class文件的次版本号(Minor Version)，后两个字节是主版本号(Major Version)</font>。<font color="blue">高版本的JDK能够运行低版本的Class文件，但是不能运行更高版本的Class文件</font>，即使这个Class文件没有发生任何变化。</li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a><font size="5">常量池</font></h2><p>紧接着版本号之后就是常量池入口。常量池可以理解位Class文件的资源仓库。常量池中常量的数量是不确定的，因此需要一个常量池容量计数器。</p><ul><li><font color="bllue"><b>常量池容量计数器</b></font><br>紧接着版本号后的<font color="blue">两个字节</font>，但是要注意的是，&lt;?font color=blue&gt;容量计数是从1开始的。即如果容量转换为十进制是22，那么就有21项常量(1-21)。将0索引空出来的目的在于，当有些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”时，就可以把索引值置0。</li></ul><p>常量池中主要存放两大类常量</p><ul><li><font color="bllue"><b>字面量</b></font><br>如文本字符串、声明为final的常量值等</li><li><font color="bllue"><b>符号引用</b></font><ul><li><b>类和接口的全限定名</b></li><li><b>字段的名称和描述符</b></li><li><b>方法的名称和描述符</b></li></ul></li></ul><p>Java代码在进行Javac编译时，是在虚拟机加载Class文件的时候进行<font color="red">动态连接</font>。也就是说，<font color="bllue">在Class文件中不会保存各个方法、字段最终在内存的哪个位置，因此这些字段、方法的符号引用要经过运行期的转换才能得到真真的内存地址</font>。当虚拟机运行，需要从常量池获得符号引用，在类创建或运行时解析、翻译到具体内存地址中。(常量池表的类型和内容见书P169)</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a><font size="5">访问标志</font></h2><p>常量池结束后紧接着的<font color="red">两个字节</font>就是访问标志(access_flags)，该标志用于识别一些类或者接口层次的访问信息。</p><ul><li>该Class是类还是接口</li><li>是否为public类型</li><li>是否为abstruct</li><li>如果是类是否被声明为final等…(P173)</li></ul><h2 id="类索引、父类索引和索引接口集合"><a href="#类索引、父类索引和索引接口集合" class="headerlink" title="类索引、父类索引和索引接口集合"></a><font size="5">类索引、父类索引和索引接口集合</font></h2><p>紧接着访问标志之后</p><ul><li><font color="bllue"><b>类索引</b></font><br><font color="red">两个字节</font>，用于确定类的全限定名</li><li><font color="bllue"><b>父类索引</b></font><br><font color="red">两个字节</font>，用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个</li><li><font color="bllue"><b>接口索引集合</b></font><ul><li><font color="red">两个字节</font>，接口计数器。表示类实现的接口数</li><li>每一组都是<font color="red">2个字节</font>，用于确定类实现了哪些接口。如果接口计数器为0，那么一组都没有。</li></ul></li></ul><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a><font size="5">字段表集合</font></h2><p>用于描述接口或类中声明的变量。即<font color="bllue">字段表包括类级变量和实例级变量，但不包括方法内部声明的变量。</font></p><ul><li><font color="bllue"><b>字段计数器(fields_count)</b></font><br>紧接着接口集合后的<font color="red">两个字节</font>，表示字段的数量。</li></ul><p>每个字段都有一个字段表，用于记录字段信息，字段计数器为多少，后面就有多少个字段表。</p><ul><li><font color="bllue"><b>字段表</b></font><ul><li><b>access_flags(访问标志)</b><br><font color="red">两个字节</font>，同类的访问标志一样，描述字段的信息(书P176)</li><li><b>name_index(名称索引)</b><br><font color="red">两个字节</font>，对常量池的引用，代表字段的简单名称(不包括类名包名等…)</li><li><b>descriptor_index(描述索引)</b><br><font color="red">两个字节</font>，对常量池的引用，字段的描述符(描述符含义表书P177)</li><li><b>属性表集合</b><br>用于存储额外信息，字段可以有0至多项额外信息。例如一个常量字段，额外信息中就包含一项ConstantValue属性，其值指向常量值</li></ul></li></ul><p><font color="bllue">字段表集合中不会列出从超类或父接口中继承而来的字段</font>，但有可能列出原本Java代码中不存在的字段，譬如一个内部类，在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。并且，<font color="blue">在Java中字段是无法重载的，两个字段的数据类型、描述符不管是否相同，都必须使用不一样的名称，但是对于字节码而言，如果两个字段的描述符不一致，那么字段可以重名。</font></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a><font size="5">方法表集合</font></h2><p>和字段表集合描述方式一模一样，分别是</p><ul><li><font color="bllue"><b>方法计数器(fields_count)</b></font><br>紧接着字段表集合后的<font color="red">两个字节</font>，表示方法的数量。</li><li><font color="bllue"><b>方法表</b></font><ul><li><b>access_flags(访问标志)</b><br><font color="red">两个字节</font>，同字段的访问标志一样，描述方法的信息(书P179)</li><li><b>name_index(名称索引)</b><br><font color="red">两个字节</font>，对常量池的引用，代表方法的简单名称(int inc()==&gt;简单名称为inc)</li><li><b>descriptor_index(描述索引)</b><br><font color="red">两个字节</font>，对常量池的引用，方法的描述符(描述符含义表书P177)</li><li><b>属性表集合</b><br>用于存储额外信息，字段可以有0至多项额外信息，例如<font color="bllue">方法的方法体编译为字节码后存放在Code属性中</font></li></ul></li></ul><p>与字段表集合相应的，<font color="bllue">如果父类方法在子类中没有被重写，方法表集合中就不会出现父类的方法信息</font>。在Java中，要重载一个方法有两个要求</p><ul><li><b>重载方法和原方法具有相同的简单名称</b></li><li><b>重载方法和原方法的特征签名不同。</b><ul><li><font color="bllue"><b>特征签名(Signature)</b></font><ul><li>Java代码中包含了方法名称、参数类型、参数顺序</li><li>字节码中还包括了方法返回值和受检查异常表</li></ul></li></ul></li></ul><p><font color="blue">因此Java中返回值的不同不能构成重载。</font>但是在Class文件中却可以。</p><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a><font size="5">属性表集合</font></h2><p>前面以及提到了很多次，在Class文件、字段表、方法表都可以携带自己的属性表集合信息。(虚拟机规范预定义属性见书P181)</p><ul><li><font color="bllue"><b>Code属性</b></font><ul><li><b>attribute_name_index(属性名称索引)</b><br><font color="red">两个字节</font>，对常量池的引用，固定为Code，代表属性名称。</li><li><b>attribute_length</b><br><font color="red">四个字节</font>属性值的长度</li><li><b>max_stack</b><br><font color="red">两个字节</font>，操作数栈的最大深度，方法执行的任意时刻操作数栈都不会超过这个深度。<font color="bllue">虚拟机运行时需要根据这个值来分配栈帧。</font></li><li><b>max_locals</b><br><font color="red">两个字节</font>，局部变量表所需的存储空间，单位是Slot(double和long占2个Slot，其他基本类型等长度不超过32位的占1个Slot)。局部变量表中存放着<ul><li>方法参数(包括实例方法的隐藏参数this)</li><li>显示异常处理器参数(try-catch中catch块定义的异常)</li><li>方法中定义的局部变量</li></ul></li><li><b>code_length和code</b><br>分别为<font color="red">四个字节和一个字节</font>，用于存储Java代码编译后生成的字节码指令。code_length代表字节码长度，code用于存储字节码指令。(每个指令占一个字节)。当虚拟机读取到一条指令时，就可以找到这个字节码代表的是什么指令，并且可以知道这条指令后有没有跟参数，以及参数该如何理解。</li></ul></li></ul><p><font color="blue">Code属性时Class文件最重要的属性</font>。如果将Java程序分为元数据(类、字段、方法等信息)和代码，那么在Class文件中</p><ul><li><b>Code属性用于描述代码</b></li><li><b>其他所有数据项目都用于描述元数据。</b></li></ul><p><b>在任何实例方法中，都可通过this关键字访问到此方法所属的对象，这是为什么？</b></p><ol><li>通过Javac编译的时候把对this关键字的访问转变为对一个普通方法参数的访问</li><li>然后再虚拟机调用实例方法时自动传入此参数</li></ol><p>因此在<font color="red">实例方法的局部变量表中至少会有一个指向当前实例对象的参数，局部变量表也会预留出一个Slot位来存放对象实例的引用。</font><br>同样在<font color="bllue">Code属性中，字节码指令后存放的是方法的显式异常处理表(简称异常表)</font>，该表对于Code属性来说不是必须存在的。(当方法中有try-catch语句时会有该表)</p><ul><li><b>显式异常处理表</b><br>  属于Java代码的一部分，编译器使用异常表来实现Java异常和finally处理机制，表结构如下<ul><li>start_pc</li><li>end_pc</li><li>handler_pc</li><li>catch_type</li></ul></li></ul><p><font color="blue">如果方法在start_pc行和end_pc行(不包括end_pc)间出现了catch_type异常，则转到handler_pc行继续处理。</font></p><ul><li><p><font color="bllue"><b>Exceptions属性</b></font><br>不要和前面的显式异常处理表混淆，显式异常处理表是Code属性的一部分，Exceptions属性是属性表集合中的一种属性，和Code属性平级。该<font color="bllue">属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时throws关键字后面列举的异常。</font></p><ul><li><b>attribute_name_index</b><br><font color="red">两个字节</font>，对常量池的引用，固定为Exception，代表属性名称。</li><li><b>attribute_length</b><br><font color="red">四个字节</font>属性值的长度</li><li><b>numbers_of_exception</b><br><font color="red">两个字节</font>，可能抛出的受检查异常的个数</li><li><b>exception_index_table</b><br><font color="red">两个字节</font>，对常量池的引用，代表了受检查异常的类型。</li></ul></li><li><p><font color="bllue"><b>LineNumberTable属性</b></font><br>用于<font color="blue">描述Java源码行号和字节码行号之间对应关系</font>(例如3：0，前面是字节码行号，后面是源码行号)。可以选择不生成，如果不生成，那么抛出异常时将不会显示出错的行号，并且调试程序时无法按照源码设置断点。</p></li><li><p><font color="bllue"><b>LocalVariable Table属性</b></font><br>用于<font color="blue">描述局部变量表中的变量和Java源码中定义的变量之间的关系</font>，可以选择不生成。如果不生成，当其他人引入这个方法时，所有参数名称都会丢失，IDE会使用arg0、arg1等代替原参数名。该属性作用</p><ul><li><b>描述局部变量在字节码中的作用域</b></li><li><b>存放局部变量的名称以及描述符</b></li><li><b>该局部变量在栈帧局部变量表中Slot位置，如果变量为64位，那么它占用的Slot为index和index+1。</b></li></ul></li><li><p><font color="bllue"><b>ConstantValue属性</b></font><br><font color="blue">通知虚拟机自动为静态变量赋值。只有被static修饰的变量才可以使用这项属性。</font></p><ul><li>对于实例变量，在实例构造器(&lt; init&gt;)方法中进行赋值</li><li>对于类变量，可以在类构造器(&lt; clinit&gt;)中进行赋值，也可以使用ConstantValue属性进行赋值。<ul><li>如果同时使用了final和static修饰、并且该变量数据类型为基本类型或String，就生成ConstantValue属性进行初始化</li><li>否则，在类构造器中进行赋值</li></ul></li></ul></li><li><p><font color="bllue"><b>Signature属性</b></font><br>可以用在类/接口、方法表、字段表上。在Java中，任何类、接口、初始化方法或成员如果使用了泛型，则该属性会记录泛型的类型(在Java的语法糖中会详细说到)。</p><ul><li><b>Java代码的方法特征签名</b><br>包括了<font color="blue">方法名称、参数顺序以及参数类型</font></li><li><b>字节码层次的方法特征签名</b><br><font color="blue">还包括了方法返回值和受检查异常表</font></li></ul></li></ul><p>可以出现在类、字段表和方法表结构的属性表中，可选属性。在Java中的泛型采用的是擦除机制，在Code属性中，泛型信息编译的(类型变量，参数化类型)之后都统统被擦除掉。好处是实现简单、运行期节省一些类型所占的空间。但坏处是无法将泛型类型和用户定义的普通类型同等对待。例如运行期反射无法获取到反省信息。<br>该属性就是为了弥补这个缺陷设计，<font color="bllue">Java反射API能够获取泛型类型，最终数据来源就是这个属性</font>。</p><hr>属性表还有很多其他属性，就不多记录了。Class文件结构就记录到这里。]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM虚拟机一</title>
      <link href="/2019/09/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80/"/>
      <url>/2019/09/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>作为Java程序员，对于JVM虚拟机的理解是必不可少的。今天刚看了周志明周老师的《深入理解JVM虚拟机》(第二版)，还是有所收获。看得不多，简单小结一下，后面会继续完善JVM方面的知识。</p><hr><a id="more"></a><h1 id="走进Java"><a href="#走进Java" class="headerlink" title="走进Java"></a>走进Java</h1><p>从传统意义上来讲，Java技术体系包括以下几个组成部分：</p><ul><li><b>Java程序设计语言</b></li><li><b>各种硬件平台上的Java虚拟机</b></li><li><b>Class文件格式</b></li><li><b>Java的API类库</b></li><li><b>来自商业机构和开源社区的第三方Java类库</b></li></ul><p>其中<font color="bllue">JDK(Java Development Kit)是用于支持Java程序开发的最小环境</font>，包括<font color="red">Java程序设计语言、各种硬件平台上的Java虚拟机以及Java的API类库</font>。<br>而<font color="bllue">JRE(Java Runtime Enviroment)是支持Java运行的标准环境</font>，包括<font color="red">Java类库中Java SE API子集和Java虚拟机两部分。</font><br>目前使用范围最广的Java虚拟机是<b>HotSpot</b>。</p><h1 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h1><p>##<font size="5">Java内存区域</font><br>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域：</p><ol><li><b>方法区</b></li><li><b>堆</b></li><li><b>虚拟机栈</b></li><li><b>本地方法栈</b></li><li><b>程序计数器</b></li></ol><p>下面来分别说一说这几个区域的作用。再说之前，先说一下线程私有的概念<br><font color="bllue"><b>线程私有</b></font><br>每条线程都需要有一个自己的内存区域，<font color="red">各线程之间互不影响，独立存储</font>，我们称这类内存区域为线程私有。<br><font color="bllue"><b>程序计数器</b></font></p><ul><li>是一块较小的内存空间，它可以看作是<font color="blue">当前线程所执行的字节码的行号指示器</font>。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>该区域是<font color="red">线程私有</font>的</li></ul><p><font color="bllue"><b>Java虚拟机栈</b></font></p><ul><li>虚拟机栈也是<font color="red">线程私有</font>的，生命周期和线程相同</li><li>每个方法在执行时会创建一个栈帧，用于<font color="bllue">存储局部变量表、操作数栈、动态链接和方法出口</font>等信息，调用方法时，将栈帧入虚拟机栈；方法执行过后，栈帧出栈，因此不难发现，<font color="bllue">虚拟机栈可以看作是用于执行Java方法的内存</font></li></ul><p><font color="bllue"><b>局部变量表</b></font></p><ul><li>存放了<font color="blue">编译期可知</font>的各种基本数据类型，对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)</li><li>long和double类型数据占2个局部变量空间(Slot)，其余的只占1个。</li><li>局部变量表所需的<font color="blue">内存空间在编译期间分配完成</font>。<b>当进入一个方法时，这个方法需要在栈帧中分配的局部变量空间是完全确定的。</b></li><li>在方法运行期间不会改变局部变量表大小</li></ul><p><font color="bllue"><b>本地方法栈</b></font><br>该栈和Java虚拟机栈的服务很类似，区别在于Java虚拟机栈为执行Java方法(字节码)服务，而本地方法栈<font color="blue">为虚拟机使用到的Nativa方法(本地方法，由其他语言编写)服务。</font><br><font color="bllue"><b>Java堆(Java Heap)</b></font></p><ul><li>一般来说，堆是Java虚拟机管理的内存中最大的一块</li><li>被所有线程共享的内存区域，在虚拟机启动时创建</li><li>作用是存放对象实例，几乎所有的对象实例都在这里分配</li><li><font color="blue">字符串常量池在堆中</font></li><li>同时，堆是垃圾收集器管理的主要区域，又被称为GC堆</li><li>Java堆还可以被细分为<ul><li>新生代(1/3)<ul><li>Eden区(8/10)</li><li>From Survivor区(1/10)</li><li>ToSurvivor区(1/10)</li></ul></li><li>老年代(2/3)</li></ul></li><li>常见的配置堆的参数<ul><li><b>-Xmx</b>：堆内存的最大内存</li><li><b>-Xms</b>：堆内存的最小内存</li><li><b>-Xmn</b>：新生代的大小</li><li><b>XX:NewRatio</b>：设置老年代是年轻代的几倍</li><li><b>XX:SurvivorRatio</b>：设置Eden区是一个Survivor的几倍(注意是一个)</li></ul></li></ul><p><font color="bllue"><b>方法区</b></font></p><ul><li>方法区也是各个线程共享的内存区域</li><li>用于存储一下信息<ul><li><b>已被虚拟机加载的类信息</b></li><li><b>常量</b></li><li><b>静态变量</b></li><li><b>即时编译后的代码等</b></li></ul></li></ul><p><font color="bllue"><b>运行时常量池</b></font></p><ul><li>该区域是方法区的一部分</li><li>Class文件除了有类的版本、字段、方法、接口等描述信息(后面会说到)外，还有一项信息是常量池，<font color="blue">用于存放编译期生成的各种字面量和符号引用</font></li><li>这部分内容将在<font color="red">类加载后</font>进入方法区的运行时常量池中</li><li>相比于Class文件的常量池，运行时常量池具备<font color="red">动态性</font>。Java语言不要求常量一定只有编译期才能产生，也就是并不是只有预置入Class文件中常量池的内容才能进入方法区的运行时常量池，<font color="blue">运行期间也可能有新的常量放入运行时常量池中</font>，例如String类的intern方法。(关于此方法可以看我String源码的文章)</li></ul><h2 id="关于Java对象"><a href="#关于Java对象" class="headerlink" title="关于Java对象"></a><font size="5">关于Java对象</font></h2><p>说完了JVM内存区域，就简单说一下Java对象的相关内容</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><font size="5">对象的创建</font></h3><p>当遇到一条new指令时</p><ol><li>检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化<ul><li>如果没有，那必须先执行相应的类加载过程</li></ul></li><li>类加载完成后，为新生对象分配内存。值得注意的是，<font color="blue">对象所需内存大小在类加载完成后就已经完全确定</font>。为对象分配内存的过程其实就是从堆内存中划分出一块确定大小的区域。</li><li>内存分配完成后，虚拟机将分配到的内存空间都<font color="red">初始化为零值，除了对象头以外</font>(后面会说到)。这一操作保证了对象的实例字段在Java代码中可以不赋初始值就能使用。(不难理解，因为我们在创建Java对象时，成员变量就是默认零值)</li><li>接下来JVM对对象进行必要的配置，这些信息都<font color="blue">存放在对象头中</font>。例如<ul><li>对象是哪个类的实例</li><li>如何找到类的元数据信息</li><li>对象的哈希值</li><li>对象的GC分代年龄(后面会说)等</li></ul></li><li>到了这一步，已经执行完new指令了，但是此时对象的成员变量值都为0，显然不符合我们的实际情况。一般来说，这时候会<font color="blue">执行&lt; init&gt;方法，把对象按照程序员的意愿进行初始化</font>。这样，我们就得到了一个真正可用的对象。</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><font size="5">对象的内存布局</font></h3><p>说完了对象的创建，紧接着自然就该说一说创建出来的对象是什么样的，有着什么样的内存布局。<br>在HotSpot中虚拟机中，对象在内存中存储的布局可以分为三部分</p><ol><li><b>对象头</b></li><li><b>实例数据</b></li><li><b>对齐填充</b></li></ol><p>下面分别说一下这三个部分<br><font color="bllue"><b>对象头</b></font><br>前面说过，在创建对象分配内存阶段，会将除了对象头以外的内存空间初始化为零值，那接下来就看看对象头到底有什么作用吧。<br>对象头包含两部分信息</p><ul><li>一部分<font color="blue">用于存储对象自身的运行时数据</font>，如<ul><li><b>哈希值</b></li><li><b>GC分代年龄</b></li><li><b>锁状态标志</b></li><li><b>线程持有的锁</b></li><li><b>偏向线程ID和偏向时间戳等</b></li></ul></li><li>另一部分是类型指针，即对象指向它的类元数据的指针。通俗的讲，<font color="blue">JVM通过这个指针来确定对象是哪个类的实例</font>。</li></ul><p><font color="bllue"><b>值得注意的是：</b></font></p><ol><li>查找对象的元数据信息并不一定要经过对象本身(后面会说到)，因此并不是所有的虚拟机实现都必须在对象数据上保留类型指针。</li><li>除此之外，如果对象是<font color="red">Java数组，对象头中还必须有一块用于记录数组长度的数据。</font></li></ol><p><font color="bllue"><b>实例数据</b></font></p><ul><li>该部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。</li><li>无论是从父类继承的，还是子类定义的，都会记录下来。</li><li>默认情况下，相同宽度的字段会分配到一起。在满足这个条件的前提下，父类中定义的变量会出现在子类之前。</li></ul><p><font color="bllue"><b>对齐填充</b></font><br>这一部分并不是必然存在的，也没有特别含义，仅仅起着占位符的作用。HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。因此实例对象的大小必须是8字节的整数倍，如果对象不是，那么就需要通过对齐填充来补全。</p><h3 id="对象的定位访问"><a href="#对象的定位访问" class="headerlink" title="对象的定位访问"></a><font size="5">对象的定位访问</font></h3><p>介绍了对象的创建和内存布局，相比你对Java对象已经有了一定的了解了，那么我们又是怎么在堆中找到这个对象并使用它的呢？<br>Java程序是通过栈上的<font color="blue">reference类型数据(前面说过，存放在栈帧中的局部变量表)来操作堆上的具体对象。</font>通过reference数据有两种方式可以定位到堆中的数据</p><ol><li>使用句柄访问对象，此时会在堆中划出一块内存叫做句柄池，<font color="bllue">refenence中存储的就是对象的句柄地址。</font>而<font color="red">句柄中包含了对象的实例数据和类型数据各自的地址信息</font><ul><li><b>实例数据</b>：可以理解为当前对象的所有数据，位于堆中。</li><li><b>类型数据</b>：属于类的数据，如静态变量，常量等，位于方法区中。</li></ul></li><li>使用指针直接访问，此时<font color="bllue">reference中存储的就是对象实例数据的地址</font>。而在<font color="red">对象中有指向类型数据的指针，通过该指针可以访问类型数据。</font></li></ol><p><font color="bllue"><b>以上两种访问方式都有各自的优势：</b></font></p><ul><li>句柄访问，reference中存储的是稳定的句柄地址，在对象移动时(如GC过程中)只会改变句柄的实例数据指针，而reference本身不需要修改。</li><li>指针直接访问，速度更快，节省了一次指针定位的时间<ul><li><font color="red">在使用句柄访问时,reference</font><ul><li>需要访问句柄池(1次)</li><li>通过句柄池中指向实例数据的指针访问堆上的实例数据(2次)</li><li>通过句柄池中指向类型数据的指针访问访问方法区上的类型数据(3次)</li></ul></li><li><font color="red">直接使用指针时，reference</font><ul><li>直接访问堆上的实例数据(1次)</li><li>在示例数据中找到指向类型数据的指针</li><li>通过该指针访问方法区上的类型数据(2次)</li></ul></li></ul></li></ul><p>由于对象的访问在Java中很频繁，因此这一次开销也是相当客观的。<font color="blue">对于HotSpot而言，使用的是第二种情况。<font></font></font></p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p>前面说过，程序计数器、虚拟机栈、本地方法栈这三个区域和线程生命周期相同，每个栈帧中分配多少内存基本在类结构确定下来时就已知，<b>这几个区域的内存分配的回收都具有确定性，因此不用过多考虑回收问题。</b>但是Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法不同的分支所需要的内存也可能不一样，<font color="blue">只有在程序运行期间才能知道会创建哪些对象。</font>这部分内存分配和回收都是动态的，垃圾收集器所关注的就是这一部分内存。</p><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a><font size="5">判断对象是否存活</font></h2><p>垃圾收集器在对堆进行回收前，首先要判断堆中的哪些对象还”存活”着，哪些对象已经”死去”(不可能再被任何途径使用的对象)，判断对象是否存活，有以下几种常用方法</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><font size="5">引用计数法</font></h3><p>给对象添加一个<font color="blue">引用计数器</font></p><ul><li>每当有一个地方引用它时，计数器值+1</li><li>当引用失效时，计数器值-1；</li><li>这样一来，任何时候计数器值为0的对象就是不可能再被使用的，也就是已经”死去”的</li></ul><p>这样的算法实现简单，效率也高，在大多数情况下都是一个不错的算法。但是它也有一个很大的缺陷，那就是<font color="bllue">无法解决两个对象相互引用的问题</font>。<br><b>什么是相互引用的问题呢？</b>(代码见《深入理解JVM虚拟机》P63)</p><ul><li>有两个对象A和B，A和B这两个对象已经不可能再被访问，但是它们之间相互引用</li><li>导致两者引用计数器都不为0，于是GC收集器也就无法收集它们。</li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><font size="5">可达性分析算法</font></h3><p>大多数的应用程序语言都是使用可达性分析算法来判定对象是否存活。<br><font color="bllue"><b>基本思路</b></font></p><ul><li>通过一系列被称为<font color="blue">“GC Roots”的对象作为起始点，从这些节点向下搜索</font></li><li>搜索走过的路径称为”引用链”，当一个对象到GC Roots没有任何引用链相连时(即<font color="red">从GC Roots到这个对象不可达</font>)，则该对象是”死亡”的。</li></ul><p><font color="bllue"><b>在Java中，可作为GC Roots的对象有</b></font></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Nativa方法引用的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><font size="5">引用</font></h3><p>前面说到的引用计数法和可达性分析法两种方法判断对象是否存活，都和”引用”有关，下面就详细说一下引用的类型</p><ul><li><b>强引用(StrongReference)</b><br>在程序代码中普遍存在，类似Object o=new Object()这类的引用。<font color="blue">只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</font></li><li><b>软引用(SoftReference)</b><br>用来描述一些<font color="red">还有用但并非必须的对象</font>。对于这些对象，<font color="blue">在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次回收</font>。但如果这次回收还没有足够的内存，就会抛出内存溢出异常。</li><li><b>弱引用(WeakReference)</b><br>比软引用强度更弱，被弱引用关联的对象<font color="red">只能生存到下次垃圾收集发生之前</font>。当垃圾收集器工作时，<font color="bllue">无论当前内存是否足够，都会回收掉被弱引用关联的对象。</font></li><li><b>虚引用(PhantomReference)</b><br>最弱的一种引用关系，一个对象是否有虚引用存在，完全不影响其生存时间，也无法通过虚引用来获取一个对象实例。设置该引用的<font color="bllue">唯一目的就是能在这个对象被垃圾收集器回首时收到一个系统通知。</font></li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a><font size="5">生存还是死亡</font></h3><p>即使在前面的可达性分析中得到不可达的对象，该对象也并是”非死不可”。这时候它们暂时处于”缓刑”，如果真正要宣告一个对象”死亡”，至少要经过两次标记过程。在其中对象还有”自救”的机会。</p><ul><li>如果对象在可达性分析中发现没有和GC Roots相连的引用链，那么它将会<font color="red">被第一次标记并且进行筛选</font><ul><li>如果该对象<font color="red">没有覆盖”finalize()”方法或该方法已经被虚拟机调用过，那么该对象被回收</font></li><li>如果该对象覆盖了”finalize()”方法并且没有被虚拟机调用过，那么该对象会被放置在F-Queue中。并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程执行它。<ul><li>这里说的”执行”是指虚拟机会触发finalize()方法，但并不承诺会等待它运行结束。这样做的原因在于<ul><li>如果一个对象在finalzie()方法中执行缓慢，或者发生了死循环，很可能会导致F-Queue队列中其他对象处于永久等待，甚至内存回收系统崩溃。</li></ul></li></ul></li></ul></li><li><font color="red">finalzie()方法是对象最后一次自救机会。</font>稍后GC将对F-Queue队列中的对象进行第二次标记。<ul><li>如果对象在finalxize()方法中成功拯救自己，<font color="bllue">和引用链上的任何一个对象建立关联</font>(例如把自己this赋值给某个类的变量等)，那么<font color="bllue">在第二次标记时会被移出”即将回收”集合。</font></li><li>如果对象这时候没有成功拯救自己，那么基本就被回收了。</li></ul></li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a><font size="5">回收方法区</font></h2><p>方法区回收效率较低，这是由方法区存放的数据相关的。方法区主要回收两部分内容，<font color="blue">废弃常量和无用的类</font>。判断一个常量是否是废弃常量比较简单，但是要判定一个类是无用的类，条件就会严苛许多，这也是导致方法区回收效率低的原因。<br><font color="bllue"><b>判断无用的类</b></font></p><ul><li>该类的所有实例都被回收</li><li>加载该类的ClassLoader已被回收</li><li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p><b>满足上述三个条件的类可以被回收，但并不是必然被回收。</b></p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><font size="5">垃圾收集算法</font></h2><p>正如书上所说，垃圾收集算法涉及大量的程序细节，这里只是大致的介绍三种算法的思想</p><ul><li>标记清除算法</li><li>复制算法</li><li>标记整理算法</li></ul><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><font size="5">标记清除算法</font></h3><p>该算法分为<font color="bllue">标记</font>和<font color="bllue">清除</font>两个阶段。</p><ol><li>标记出所有需要回收的对象(标记过程前面已经说过)</li><li>标记完成后统一回收所有被标记的对象。</li></ol><p>这个方法主要<font color="red">有两个缺点</font></p><ul><li><b>效率问题</b>，标记和清除两个过程效率都不高。</li><li><b>空间问题</b>，标记清楚过后会产生大量不连续的内存碎片，这类碎片过多可能会导致程序在分配较大对象时无法找到连续内存而不得不再进行一次GC。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><font size="5">复制算法</font></h3><p>为了解决效率问题，该算法出现了。它<font color="blue">将可用内存按容量划分为大小相等的两块，每次只使用其中一块</font>。当这一块内存用完了，将还存活着的对象复制到另一块内存上面，然后把自己使用过的内存空间一次清理掉。<br><font color="bllue">这样做的好处</font></p><ul><li>每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只需要移动堆顶的指针，按顺序分配内存即可，实现简单且运行高效。</li></ul><p><font color="red">缺点</font></p><ul><li>将内存缩小为原来的一半，代价过高。</li></ul><p>现在的虚拟机大多都采用这种方法来<font color="blue">回收新生代</font>(注意是新生代)。据分析，98%的对象都是朝生夕死的所以并不需要1：1的比例来分配内存空间。因此新生代就被划分为Eden区(8/10)、FromSurvivor区(1/10)和ToSurvivor区(1/10)三个区域。</p><ul><li>每次使用Eden区和一块Survivor区</li><li>当回收时，将Eden和Survivor中还存活的对象一次性的复制到另外一块Survivor区中</li><li>清理Eden区和刚才用过的Survivor区。</li></ul><p>当然，我们并不能保证每次回收后都只有不多于1/10的对象存活，即有可能某次回收后对象存活较多，Survivor空间不够。这时候就要依赖其他内存(老年代)进行分配担保。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a><font size="5">标记整理算法</font></h3><ul><li>复制算法在对象存活率较高时，效率就会变低(因为要进行较多的复制操作)</li><li>更关键的是，使用复制算法就必须要有额外的空间进行分配担保。</li></ul><p>对于老年代，没有空间进行担保，因此<font color="red">对于老年代不能够使用复制算法，应该使用标记整理算法。</font><br>和标记清除算法思想一样，但是后续的步骤不是直接对可回收对象进行清理，<font color="bllue">而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。</font></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a><font size="5">分代收集算法</font></h3><p>这种算法就是根据对象存活周期不同将内存划分为几块。一般是<font color="blue">把Java堆划分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</font></p><ul><li>对于<font color="red">新生代</font>，每次垃圾收集都会有大量对象死去，只有少量存活，因此<font color="bllue">选用复制算法。</font></li><li>对于<font color="red">老年代</font>，对象存活率较高且没有额外担保空间，不宜使用复制算法，因此<font color="bllue">选用标记清理或标记整理算法。</font></li></ul><h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a><font size="5">HotSpot算法实现</font></h2><p>前面从理论上介绍了对象的存货判定和垃圾收集算法，下面就具体说一下HotSpot的实现细节</p><h3 id="HotSpot枚举根节点"><a href="#HotSpot枚举根节点" class="headerlink" title="HotSpot枚举根节点"></a><font size="5">HotSpot枚举根节点</font></h3><ul><li>在判断对象存活的可达性分析算法中，使用到了GC Roots。而可以作为GC Root的节点有很多，如果要逐一检查，无疑是很耗费时间的。</li><li>另外，可达性分析的过程中整个执行系统看起来就被冻结在某个时间点上，即GC停顿。不允许出现分析过程中对象的引用关系还在不断变化的情况，否则分析结果的准确性就不能得到保证。这就导致了GC进行时必须停掉所有的Java线程(Stop The World)。</li></ul><p>由于大多虚拟机都是采用<font color="red">准确式GC</font>(<font color="bllue">即虚拟机知道内存中某个地方的数据到底是什么类型，这样在GC时能够准确判断堆上的数据是否还可能被使用</font>)。HotSpot虚拟机使用一组称为<font color="blue">OopMap的数据结构</font>，在<font color="red">类加载完成后</font>，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在<font color="red">JIT编译过程中</font>，也会在<font color="bllue">特定位置记录下栈和寄存器中哪些位置是引用</font>。这样，GC在扫描时就可以直接得知这些信息了。</p><h3 id="安全点-SafePoint"><a href="#安全点-SafePoint" class="headerlink" title="安全点(SafePoint)"></a><font size="5">安全点(SafePoint)</font></h3><p>前面说了，在OopMap的协助下，HotSpot可以准确地完成GC Roots枚举。但仍有一个问题，可能程序中，<font color="bllue">导致引用关系变化(即导致OopMap内容发生变化)的指令很多，如果每一条指令都生成对应的OopMap，这样很占内存</font>。<br>实际上，HotSpot也没有为每条指令都生成OopMap。前面说到了，它只是在<font color="red">特定位置</font>记录这些信息，这些位置被称为<font color="blue">安全点</font>。即<font color="bllue">在程序执行时并非所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</font><br>安全点的选用既不能太少以至于让GC等待时间太长，也不能太多导致频繁GC增大运行负荷。安全点的选定<font color="blue">基本上是以指令”是否具有让程序长时间执行的特征”为标准进行选定。</font><br>这是因为：每条指令执行时间都非常短暂，”长时间执行”最明显的特征<font color="bllue">就是指令序列的复用</font>，例如<font color="blue">方法调用、循环跳转、异常跳转等</font>。所以<font color="red">具有这些功能的指令才会产生SafePoint。</font></p><p>对于安全点，还有一个问题就是<font color="red">如何在GC发生时让除了执行Native的所有线程都”跑”到最近的安全点上再停顿下来？</font>书上给了两种方案</p><ul><li><b>抢先式中断</b><br>不需线程的执行代码主动去配合，在GC发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复该线程，让它跑到”安全点”上。(这种方法现在几乎不用)</li><li><b>主动式中断</b><br>当GC需要中断线程时，不直接对线程进行操作，仅仅是简单地设定一个标志，各个线程执行时主动的去访问这个标志，发现中断标志为真时就自己中断挂起。标志的地方和安全点是重合的。</li></ul><h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a><font size="5">安全区域(Safe Region)</font></h3><p>前面的安全点并没有完全解决如何进入GC的问题。你发现没有，<font color="bllue">当一个线程不执行的时候(即没有分配到CPU时间，有可能是处于Sleep状态或者Blocked状态)，显然无法响应JVM的中断请求，”走”到安全点中断挂起；同样的JVM也不可能等待线程重新被分配CPU时间。</font>这时，就需要安全区域来解决。</p><ul><li><font color="blue">安全区域</font><br>指的是在一段代码片段中，引用关系不会发生变化。那么在这个区域内的任意地方开始GC都是安全的。</li></ul><p><b>对于安全区域的线程</b></p><ol><li>在线程执行到安全区域中的代码时，首先<font color="bllue">标识自己已经进入了安全区域。</font></li><li>这样，当在这段时间里JVM要发起GC时，<font color="bllue">就不用管标识自己为Safe Region状态的线程。</font></li><li>线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)<ul><li>如果完成了，线程就继续执行</li><li>否则它就必须等待直到收到可以安全离开Safe Region的信号为止</li></ul></li></ol><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a><font size="5">内存分配和回收策略</font></h2><p>Java体系中的自动内存管理，实际上可以归结为给对象分配内存以及回收分配给对象的内存。前面已经大致介绍了内存回收这方面，下面就说一下给对象分配内存的细节。<br> 对象内存的分配，基本都是分配在堆上。对象主要分配在新生代的Eden区。<br><font color="bllue"><b>对象优先在Eden分配</b></font><br>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li><b>Minor GC</b><br>新生代GC，指发生在新生代的GC，因为Java对象大多都具有朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也较快。</li><li><b>Full GC</b><br>老年代GC，指发生在老年代的GC，Full GC速度一般会比Minor GC慢10倍以上。</li></ul><p><font color="bllue"><b>大对象直接进入老年代</b></font><br>大对象，即<font color="bllue">需要大量连续内存空间的Java对象</font>。最典型的有<font color="red">很长的字符串或数组</font>。可以通过设置”<b><font color="blue">-XX:PretenureSizeThreshold&lt;/font</font></b>“参数，<font color="bllue">令大于这个设置值的对象直接在老年代分配</font>。这样做的目的就是避免在Eden区以及两个Survivor区发生大量内存复制。<br><font color="bllue"><b>长期存活的对象将进入老年代</b></font><br>前面说过，JVM采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些又该放在老年代。为此，<font color="blue">虚拟机给每个对象定义了一个年龄(Age)计数器。</font></p><ul><li>如果对象在Eden区出生并经过一次Minor GC后仍然存在，并且能够被Survivor区容纳，将被移动到Survivor区中，并且对象年龄设为1</li><li>对象在Survivor区中每熬过一次Minor GC，Age就+1，当年龄增加到一定数时(默认15)，就会被移到老年代。</li><li>对象晋升到老年代的阈值，可以通过参数”<b>-XX:MaxTenuringThreshold</b>“设置</li></ul><p><font color="bllue"><b>动态对象年龄判断</b></font><br>为了更好地适应不同程序的内存情况，对象并不是一定要达到阈值年龄才能晋升到老年代。<font color="blue">如果Survivor区中相同年龄所有对象的大小总和大于Survovir空间(一个Survivor大小)的一半，年龄大于或等该年龄的对象就可以直接进入老年代。</font></p><hr>对于JVM的简单介绍就记录到这里，回顾一下主要介绍了JVM内存模型、自动内存管理以及垃圾收集机制。下次会记录一下第六章内容，即JavaClass文件结构。]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础-SQL语句总结-三</title>
      <link href="/2019/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%89/"/>
      <url>/2019/09/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>前面已经的数据库基础还没总结完，马上就要上手做demo了，先把数据库做个总结回顾，方便后面使用。上次记录了基本的DQL语句，这次就记录一下约束、范式以及多表关系方面。</p><hr><a id="more"></a><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之快速排序</title>
      <link href="/2019/09/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面已经说过了四种排序算法，这次来讲一讲一种效率较高，应用也较多的一种排序，那就是<b>快速排序</b>。听名字就知道，这种排序算法速度是比较快的，那它究竟是怎么操作的呢？让我们来看一看吧</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>快速排序其实是对冒泡排序的一种改进，用到了分治和递归思想。通过一趟排序将要排序的数组分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按照此方法对两部分数据分别进行快速排序，整个排序过程递归进行。</p><ol><li>在待排序的数组中选定一个基数(作用后面说)<ul><li>这里基数的选择有很多种方法：<ul><li>数组的第一个元素作为基数</li><li>数组的最后一个元素作为基数</li><li>数组的中间元素作为基数</li><li>随机在数组中选择一个数作为基数</li></ul></li></ul></li></ol><p>我这里是选择<font color="bllue">中间的数作为基数。</font></p><ol start="2"><li>在当前数组的开头和末尾各定义一个指针，暂且命名为l和r</li><li>l指针向右扫描，直到找到小于等于基数的数为止</li><li>r指针向左扫描，直到找到大于等于基数的数为止</li><li>交换arr[l]和arr[r]，重复3，4直到r&lt;=l为止</li><li><font color="bllue">当r==l的时候，l和r指向基数。并且数组中比基数小的元素都在数组的左边，比基数大的元素都在数组的右边。</font></li><li>分别对数组的左边和右边递归进行2、3、4、5步，最后整个数组就被排序。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] arr,int left,int right) &#123;</span><br><span class="line">//左下标，初始值为0</span><br><span class="line">int l=left;  </span><br><span class="line">//右下标，初始值为最后一个元素的下标</span><br><span class="line">int r = right; </span><br><span class="line">//基数</span><br><span class="line">int pivot = arr[(left + right) / 2];   </span><br><span class="line">//while循环让比pivot小的值放到左边，大的放到右边</span><br><span class="line">while (r &gt; l) &#123; </span><br><span class="line"></span><br><span class="line">//在pivot左边一直找，直到找到大于等于pivot的值，才退出</span><br><span class="line">while (arr[l] &lt; pivot) &#123;        </span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在pivot右边一直找，直到找到小于等于pivot的值，才退出</span><br><span class="line">while (arr[r] &gt; pivot) &#123;        </span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">//此时说明pivot左边的值都小于等于pivot，右边都大于等于pivot</span><br><span class="line">if (l &gt;= r) &#123;   </span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//交换</span><br><span class="line">int temp;   </span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line">//如果交换完后发现arr[l]==pivot，让r前移一步，r--</span><br><span class="line">if (arr[l] == pivot) &#123;        </span><br><span class="line">r--; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果如果交换完后发现arr[r]==pivot，让l后移一步，l++</span><br><span class="line">if (arr[r] == pivot) &#123;        </span><br><span class="line">l++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//注意：如果l==r，必须让l++,r--，否则会出现栈溢出</span><br><span class="line">if (l == r) &#123;                     </span><br><span class="line">l++;</span><br><span class="line">r--; </span><br><span class="line">&#125;</span><br><span class="line">//向左递归</span><br><span class="line">if (left &lt; r) &#123;        </span><br><span class="line">quickSort(arr, left, r); </span><br><span class="line">&#125;</span><br><span class="line">//向右递归</span><br><span class="line">if (l &lt; right) &#123;       </span><br><span class="line">quickSort(arr, l, right); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="细节解释"><a href="#细节解释" class="headerlink" title="细节解释"></a>细节解释</h1><p>我把我觉得代码中不好理解的地方说一下</p><ol><li><img src="/2019/09/22/排序算法之快速排序/2.png" alt><b>这两个判断的作用是什么呢？</b><br>举个例子：</li><li>现有一个待排序数组{3,1,1,2}，初始时l=0；r=3；pivot=arr[1]=1;</li><li>第一次扫描过后，得到数组{1,1,3,2}，此时l=0；r=2；</li><li>第二次扫描，因为arr[r]=3&gt;pivot,r左移，r=1；l不变，l=0</li></ol><p><font color="red">这时候问题就来了，这时候arr[l]==arr[r]==pivot，所以l和r会一直互相交换值，但是它们指向的位置不变，即l==r==1一直保持，这样就会陷入死循环</font><br><b>为什么在arr[l] == pivot时是r–而不是l++呢？</b><br><font color="red">前面说过，因为最后r==l时，arr[r]==arr[l]==pivo一定是存在的。当arr[l] == pivot时，说明l已经找到了确定的位置，这时候如果移动l，那么最后l==r时，arrr[r]==arr[l]就有可能不等于pivot。</font><br><img src="/2019/09/22/排序算法之快速排序/3.png" alt><b>为什么会出现栈溢出？</b><br>可以这么理解，当第一趟排序过后，arr[r]==arr[l]==pivot，数组中小于pivot的都在左边，大于pivot的都在右边。这时候要递归对左右序列分别进行快排。通过下面的递归代码可以发现：</p><ol><li>对其左序列进行快排时，以r为新的右边界</li><li>对其右序列进行快排时，以l为新的左边界</li></ol><p><font color="red">这时候r和l指向的值是已经确定了位置的基数值，自然就不需要参与后面的快排。所以要将r前移，l后移，目的就是将已经确定位置的基数值排除在外。</font></p><h1 id="排序速度"><a href="#排序速度" class="headerlink" title="排序速度"></a>排序速度</h1><p>同样的，我们来测试一下快排有多快<br><img src="/2019/09/22/排序算法之快速排序/4.png" alt><br>排序时间<br><img src="/2019/09/22/排序算法之快速排序/5.png" alt><br>进过多次测试发现快排的速度大约在<font color="bllue">20ms左右</font>，比前面的希尔排序还要快一倍，果然是快排，名不虚传。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之希尔排序</title>
      <link href="/2019/09/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面说到了插入排序，并且知道了它是不稳定的。并且测试速度后发现插入排序的速度与冒泡、选择相比还是比较可观的。但是，不知道你有没有发现，插入排序再某些情况下存在着一些弊端。<br>比如有这样的一个数组arr={4,7,9,6,4,1}，数组自身的顺序接近于逆序，当将4、1插入到有序数组中时，需要将有序数组部分所有元素都后移一个位置，这无疑会有一定的时间消耗。那么在这种情况下，就出现了<b>希尔排序</b>，你可以将希尔排序理解为插入排序的增强版。</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>希尔排序，又称为缩小增量排序</p><ol><li>设置一个步长step，通常初始化为arr.length/2，即数组长度的一半</li><li>间隔为一个步长的元素为一组</li><li>分别对同一组的元素进行插入排序</li><li>每一趟过后将step减半，即step/=2(缩小增量)</li><li>重复3和4，直到step为1</li><li>setp为1时，数组已经接近有序，这时对整个数组进行插入排序。</li></ol><p>前面说过，插入排序适用于哪些自身顺序比较良好的数组，而希尔排序通过不断地缩小步长，将一个数组变成一个接近有序的数组后，直到step=1，此时就相当于对一个接近有序的数组进行插入排序。<br><img src="/2019/09/21/排序算法之希尔排序/1.png" alt></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void Shellsort1(int[] arr) &#123;</span><br><span class="line">int count=0;</span><br><span class="line">for (int step = arr.length / 2; step &gt; 0; step /= 2) &#123;</span><br><span class="line">//类比于插入排序</span><br><span class="line">for (int i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">//当前分组中有序部分的最后一个数下标</span><br><span class="line">int insertIndex = i - step;  </span><br><span class="line">//当前分组中待待插入的数</span><br><span class="line">int insertVal = arr[i];         </span><br><span class="line">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">arr[insertIndex + step] = arr[insertIndex];</span><br><span class="line">insertIndex -= step;</span><br><span class="line">&#125;</span><br><span class="line">arr[insertIndex + step] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;希尔排序后的数组&quot;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>算法的时间复杂度<ul><li>平均时间：O(nlogn)</li><li>最差情况：O(n的1.2次方)</li></ul></li></ol><p>这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²)</p><ol start="2"><li>空间复杂度<ul><li>只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1)</li></ul></li><li>稳定性<ul><li>和插入排序不同，<font color="red">希尔排序不是稳定的</font></li></ul></li></ol><h1 id="算法速度"><a href="#算法速度" class="headerlink" title="算法速度"></a>算法速度</h1><p>既然说希尔排序时插入排序的增强版，那就来测试一下希尔排序和插入排序的速度谁更快一些，又快多少呢？<br>同样的，创建一个80000大小的随机数组，来测试希尔排序的排序速度<br><img src="/2019/09/21/排序算法之希尔排序/3.png" alt><br>排序时间(毫秒)为<br><img src="/2019/09/21/排序算法之希尔排序/4.png" alt><br>通过前面插入排序的对比不难发现，希尔排序能够较大的提高插入排序的速度</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之插入排序</title>
      <link href="/2019/09/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面说了两种排序算法，分别是冒泡排序和选择排序，这两种算法都比较容易理解。那么这次来学习第三种排序—-<b>插入排序</b>，这也是一种相对简单的排序算法，理解起来难度也不大。</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>将数组分成两部分：</p><ul><li>一部分是有序数组</li><li>一部分是无序数组。</li></ul><p>在每一趟排序中，从无序数组中拿出一个数来，放到有序数组的正确位置。即每一趟排序过后，无序数组元素减少一个，相应的有序数组元素增加一个。到最后该数组全部变为有序数组。</p><ul><li>初始化有序数组长度为1，即arr[0]为有序数组。</li><li>第一趟排序，将无序数组中第一个元素arr[1]放到有序数组中，此时有序数组包含两个元素</li><li>第二趟排序，将无序数组中第一个元素arr[2]放到有序数组中，此时有序数组包含三个元素</li><li>……</li><li>第n-1趟排序，将无序数组中第一个也是最后一个元素arr[n-1]放到有序数组中，至此数组全部有序<br><img src="/2019/09/21/排序算法之插入排序/1.png" alt>可以看到，最后一趟排序过后，无序数组长度为0，至此数组全部有序。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> * @param arr</span><br><span class="line"> */</span><br><span class="line">public static void insertSort(int[] arr) &#123;</span><br><span class="line">//待插入的数，无序数组第一个元素</span><br><span class="line">int insertIndex; </span><br><span class="line">//待插入的数前面一个数的下标，有序数组最后一个元素</span><br><span class="line">int insertVal;      </span><br><span class="line">for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">//待插入的数为无序数组第一个元素</span><br><span class="line">insertVal = arr[i+1];</span><br><span class="line">//有序数组最后一个元素</span><br><span class="line">insertIndex = i ;    </span><br><span class="line">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">arr[insertIndex + 1] = arr[insertIndex];</span><br><span class="line">insertIndex--;</span><br><span class="line">&#125;</span><br><span class="line">arr[insertIndex+1] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;排序后的数组&quot;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>算法的时间复杂度<ul><li>平均时间：O(n²)</li><li>最差情况：O(n²)</li></ul></li></ol><p>这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²)</p><ol start="2"><li>空间复杂度<ul><li>只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1)</li></ul></li><li>稳定性<ul><li>不难发现，<font color="red">插入排序是稳定的</font></li></ul></li><li>另外，该排序算法在<font color="red">大部分元素已经是有序时比较好</font></li></ol><h1 id="算法速度"><a href="#算法速度" class="headerlink" title="算法速度"></a>算法速度</h1><p>和前面两个排序算法一样，我们来随机创建一个80000大小的随机数组，测试所用的时间<br><img src="/2019/09/21/排序算法之插入排序/3.png" alt><br>最后测得的排序时间为<br><img src="/2019/09/21/排序算法之插入排序/4.png" alt><br>让我们以ms为单位，再测试一次<br><img src="/2019/09/21/排序算法之插入排序/5.png" alt><br>通过结果可以发现，相比于冒泡排序和选择排序，插入排序的速度还是很可观的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自顶向下之计算机网络和因特网</title>
      <link href="/2019/09/20/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
      <url>/2019/09/20/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>最近在读计算机网络方面的书—–<b>《计算机网络自顶向下方法》(第七版)</b>，个人觉得书中概念讲的很清楚，举例也是很形象易懂了，如果你想学计网的话，5星强烈推荐！刚读完第一章，做个小结，方便回头复习。书中有些图有助于理解，建议搭配书本一起学习。</p><hr><a id="more"></a><h1 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h1><p>这一节主要从两个方面来解释什么是因特网</p><ul><li>从因特网得具体构成，也就是从因特网的基本硬件和软件组成方面解释</li><li>从为分布式应用程序提供服务得联网基础设施来描述</li></ul><h2 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a><font size="5">具体构成描述</font></h2><p>因特网是一个世界范围内的网络，一个互联了遍及全世界数十亿计算设备的网络，这些计算设备包括计算机、手机、智能手表、电视…，用因特网术语来说，这些和因特网被称为<font color="red">主机/端系统。</font><br>端系统通过<font color="blue">通信链路</font>和<font color="blue">分组交换机</font>连接到一起</p><ul><li><b>通信链路</b><ul><li>用来传输数据，由不同类型的物理媒体组成，例如同轴电缆、铜线、光纤…</li><li>传输速率：链路传输数据的频率，比特/秒(bit/s)</li></ul></li><li><b>分组交换机</b><ul><li>顾名思义，分组交换机从它一条如通信链路接收到达的分组，并从它的一条出通信链路转发该分组</li><li>两种有名的分组交换机：<font color="blue">路由器</font>和<font color="blue">链路层交换机</font></li><li>链路层交换机通常位于<font color="red">接入网</font>中</li><li>路由器通常位于<font color="red">网络核心</font>中</li></ul></li><li><b>分组</b><ul><li>当端系统向另一台端系统之间发送数据时，发送端系统将数据分段，并为每段加上首部字节</li><li>由此形成的信息包用计算机网络术语来说称为分组</li><li>分组通过网络发送到目的端系统，并在那里被装配成原始数据</li></ul></li><li><b>路径</b><br>  一个分组所经历的一系列通信链路和分组交换机被统称为通过该网络的路径</li></ul><p>也许通过上面的描述，你还是不明白数据在网络中怎么传输的。不着急，我们来举个例子：<br><b>一个工厂</b>需要将大量的<b>货物</b>搬运到数千里以外的某个<b>目的地仓库</b>。在工厂中，<b>货物要分开并装上卡车</b>车队。然后每辆卡车独立的通过<b>高速公路、公路或立交桥</b>组成的运输网络向仓库运送货物。在目的地仓库，卸下这些货物，并且<b>与一起装载的同一批货物的其余部分堆放在一起</b>。</p><ul><li>工厂就相当于源端系统</li><li>货物就相当于数据</li><li>目的地仓库就相当于目的端系统</li><li>在工厂中将货物分开并装上卡车，即将数据分段，为每段加上首部字节，形成分组。因此、分组就相当于卡车。</li><li>高速公路、立交桥就相当于各种通信链路</li><li>分组交换机则相当于路的交叉口</li><li>公路两边的建筑物就相当于端系统</li><li>就像卡车选取运输网路的一条路径前行一样，分组选取计算机网络的一条路径前行</li></ul><p><b><font color="red">这下你明白了么？</font></b><br>端系统通过ISP(Internet Service Provider,因特网服务提供商)接入因特网</p><ul><li><b>ISP</b><br>一个由多台分组交换机和多段通信链路组成的网络。<br>各ISP为端系统提供了不同类型的网络接入，因特网就是将端系统彼此互联，因此为端系统提供接入的ISP也必须互联，后面会详细说到ISP</li><li><b>协议</b><ul><li><font color="bllue">控制着因特网中信息的接受和发送</font>，端系统、分组交换机和其他因特网部件都要运行一系列协议</li><li>TCP(Transmission Control Protocal，传输控制协议)和IP(Internet Protocol，网际协议)是因特网中最为重要的协议</li><li>IP协议定义了在路由器和端系统之间<font color="bllue">发送和接收的分组格式</font></li></ul></li></ul><h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a><font size="5">服务描述</font></h2><p>除了电子邮件、Web冲浪等传统应用外，因特网应用还包括手机和平板的应用程序。例如在线电影、多人游戏、视频会议…因为这些应用&lt;font color=bllue涉及到多个相互交换数据的系统，故它们被称为<b>分布式应用程序</b>。重要的是，这些因特网应用程序都是<b>运行在端系统上</b>的，即它们并不运行在位于网络核心的分组交换机中。<br>假如你写了一个应用程序，运行在不同端系统上的软件需要相互发送数据(例如QQ、微博…)，这时候问题就来了，你怎么才能<font color="bllue">让运行在一个端系统上的应用程序指令因特网向运行在另一个端系统的软件发送数据</font>呢？这个问题引出了另一种描述因特网的方法：即<b>将因特网描述为应用程序的平台。</b><br>与因特网相连的端系统提供了一个套接字接口(在Java中，接口就是规则)，该接口规定了运行在端系统上的应用程序请求因特网向运行在另一个端系统上的特定目的地程序交付数据的方式。</p><ul><li><b>套接字</b><ul><li>由端系统提供</li><li>规定了端系统上的应用程序请求因特网向另一个端系统上的特定目的地程序交付数据的方式。</li><li>一套发送程序必须遵循的规则集合</li></ul></li></ul><p><b>我们继续来做一个类比</b><br>假设张三使用邮政服务向李四发送一封信。那我们知道，张三不能只是写了这封信，然后丢出窗外，这样邮政服务是不会接收的，李四也收不到信。<br>正确的做法是什么呢？张三应该将信装在信封里，在信封上写李四的姓名、住址、邮编；在信封右上角贴上邮票；最后将信封丢进邮政的服务信箱中。这是邮政服务定义的规则，是每个要发信的人必须遵守的。同理，因特网也有一个发送数据的程序必须遵守的套接字接口(规则)，是因特网能向接收数据的程序交付数据。</p><h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a><font size="5">什么是协议</font></h2><p>同样的，为了帮助理解，我们像举个例子类比一下协议这个概念。<br>我们的生活中，无时无刻不在执行协议。假设张三遇到了李四，发生了下面一段对话</p><hr>张三：你好，李四(李四发送报文)<br>李四：你好，张三(发送报文)<br>这时，李四对张三的回应按时着两人可以继续进行交谈(通信)。<hr>但是如果是这样的：张三：你好啊李四<br>李四：别烦我/没有理张三<br>李四的反应表明两人之间的交谈(通信)很勉强或者无法进行，这时张三可能会放弃和李四的交谈。<hr><p>通过上面两段对话，可以知道，发送和接收的报文，以及这些报文发送、接收报文(在第一段中，李四接收报文后对张三进行了回复)或者其他事件出现时所采取的动作(在第二段中，李四没有进行回复)，在一个人类协议中起到了核心作用。<br>如果两个人交谈时，使用不同的协议，例如张三和李四的语言不通，那么他们就无法通信。同样的，<font color="bllue">在网络中为了完成一项工作，要求两个(多个)通信实体运行相同的协议。</font><br>网络的协议和人类协议类似，交换报文和采取动作的实体时设备而不是人</p><ul><li><b>协议</b><br>定义了在两个或多个通信实体间交换报文的&lt;font color=bllue格式和顺序，以及报文发送和或接受一条报文或其他事件发生时所采取的动作。因特网广泛的使用了协议，不同的协议用于完成不同的通信任务，<b>掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式的过程。</b></li></ul><h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><p>前面说过，通常把与因特网相连的计算机或其他设备称为端系统，它们位于互联网的边缘，因此被称为端系统。<br>想象一下，在现实生活中，各种各样的房子/建筑物就相当于各种各样的端系统，建筑物前的公路将数以亿计的建筑物连接在一起，就相当于因特网将无数端系统连接在一起。通常路的尽头都是建筑物，建筑物位于公路系统的边缘，同样的端系统也位于互联网的边缘。<br>端系统也称为主机，因为它们运行应用程序，主机有时又被分为两类：客户端和服务器。</p><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a><font size="5">接入网</font></h2><p>前面说到了位于网络边缘的端系统和应用程序，现在主要说一下<b>接入网</b>，这是指<font color="bllue">将端系统物理连接到边缘路由器的网络</font></p><ul><li><b>边缘路由器</b><br>端系统到任何其他远程端系统路径上的第一台路由器。<br>下面说一下使用接入网的几种环境。</li></ul><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a><font size="5">家庭接入</font></h3><p>家庭接入有大致4种不同的接入链路</p><ul><li>DSL(Digital Subscriber Line，数字用户线)</li><li>电缆</li><li>FTTH(Fiber To The Home，光纤到户)</li><li>拨号和卫星</li></ul><p>下面分别做一下了解</p><h4 id="DSL-数字用户线"><a href="#DSL-数字用户线" class="headerlink" title="DSL-数字用户线"></a><font size="5">DSL-数字用户线</font></h4><p>住户通常从<b>提供本地电话接入的本地电话公司处</b>获得DSL因特网接入。当使用DSL时，本地电话公司也是它的ISP(因特网服务提供商)。<br>每个用户的<font color="blue">DSL调制解调器</font>使用现有的<b>电话线</b>(双绞铜线)与电话公司的数字用户线接入复用器<font color="blue">(DSLAM)</font>交换数据。家庭的DSL调制解调器得到数字信号后将其转换为高频音，通过电话线传输给电话公司，在电话公司的DSLAM处转换回数字信号。<br>这样，<b>电话线同时承载了数据和传统的电话信号</b>，它们通过<b>不同的频率进行编码</b></p><ul><li>高速上行信道：50kHz-1MHz频段</li><li>中速下行信道：4kHz-50kHz频段</li><li>普通双向电话信道：0-4kHz频段</li></ul><p>这种方法使得单根的DSL线路看起来就像有三根一样，因此一个电话呼叫和一个因特网连接能够同时共享DSL链路(后面会说到这种频分复用技术)</p><ul><li><b>用户一侧：</b>一个<font color="blue">分配器</font>把到达家庭的数据信号和电话信号分开，并将数据信号转发给DSL调制解调器</li><li><b>电话公司一侧：</b>DSLAM把数据和电话信号分开，并将数据信号发送到因特网。</li></ul><p><b>以上就是DSL接入方式。适用于短距离接入</b></p><h4 id="电缆接入"><a href="#电缆接入" class="headerlink" title="电缆接入"></a><font size="5">电缆接入</font></h4><p>DSL利用电话公司的本地电话基础设施，而电缆因特网接入利用有线电视公司的有线电视基础设施。住宅从提供有线电视的公司获得电缆因特网接入。<br>电视公司的电缆头端和地区枢纽通过光缆连接，地区枢纽使用传统的同轴电缆到达各家各户，每个地区枢纽通常支持500~5000个家庭。<br>电缆因特网接入需要特殊的调制解调器，即<font color="blue">电缆调制解调器</font>。</p><ul><li><b>家庭端</b><br>类似DSL调制解调器，电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭PC，将数字信号转换为模拟信号。</li><li><b>电视公司的电缆头端</b><br>电缆调制解调器端接系统(CMTS)，类似于DSL中的DSLAM，功能也类似。即将来自住户的电缆调制解调器发送的模拟信号转换回数字信号。</li><li><b>共享广播媒体</b><ul><li>电缆因特网接入一个重要的特征是共享广播媒体。</li><li>由头端发送的每个分组向下行经每段链路到每个家庭，每个家庭发送的每个分组经上行信道向头端传输。因此，如果几个用户同时经下行信道下载一个视频文件，每个用户接收视频文件的实际速率将大大低于电缆总计的下行速率。</li></ul></li></ul><h4 id="FTTH-光纤到户"><a href="#FTTH-光纤到户" class="headerlink" title="FTTH(光纤到户)"></a><font size="5">FTTH(光纤到户)</font></h4><p>从本地中心局直接到家庭提供了一条光纤路径，有两种方案</p><ul><li>直接光纤，从本地中心局到每户设置一个光纤</li><li>从中心局出来的每根光纤实际上由多个家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤，进行这种分配形成了两种光纤分布体系方案<ul><li>主动光纤网络(Active Optical NetWork,AON)，AON本质上就是交换因特网，后面会说到</li><li>被动光纤网络(Passive Optical NetWork,PON)</li></ul></li></ul><p>简单说一下PON</p><ul><li><b>家庭端</b><br>每个家庭具有一个<font color="blue">光纤网络端接器(ONT)</font>，用户将一台家庭路由器和ONT相连,并通过这台路由器接入因特网。ONT由专门的光纤连接到邻近的<font color="blue">分配器</font>，分配器把一些家庭(一般100个)集结到一根共享的光纤。</li><li><b>公司端</b><br>该光纤在连接到本地公司的<font color="blue">光纤线路端接器(OLT)</font>，OLT提供了光信号和电信号之间的转换，经过本地公司的路由器和因特网相连</li></ul><p>在PON体系中，所有从OLT发送到分配器的<font color="bllue">分组在分配器处复制。</font></p><h4 id="拨号和卫星"><a href="#拨号和卫星" class="headerlink" title="拨号和卫星"></a><font size="5">拨号和卫星</font></h4><p>在无法提供上面三种接入的地方，能够使用这两种方式，速度较慢。</p><h3 id="企业和家庭接入"><a href="#企业和家庭接入" class="headerlink" title="企业和家庭接入"></a><font size="5">企业和家庭接入</font></h3><p>在公司和大学校园以及越来越多的家庭环境中，使用<font color="blue">局域网(LAN)</font>将端系统连接到边缘路由器，局域网技术有很多种，目前<font color="blue">以太网是最流行的接入技术</font>(会在后面讲到该技术)。</p><ul><li>以太网用户使用双绞铜线与一台以太网交换机相连</li><li>以太网交换机或者这样相连的网络再与更大的因特网相连。</li></ul><p>还有越来越多的手机等设备<b>无线接入因特网。在无线LAN环境中：</b></p><ul><li>无限用户从一个接入点发送/接收分组；</li><li>该接入点与企业网连接(可能是用了有线以太网)；</li><li>企业网再与有线因特网相连。<br>现在我们知道的<font color="bllue">WiFi，就是基于IEEE802.11技术的无线LAN接入。</font></li></ul><h3 id="广域无线接入：4G和LTE"><a href="#广域无线接入：4G和LTE" class="headerlink" title="广域无线接入：4G和LTE"></a><font size="5">广域无线接入：4G和LTE</font></h3><ul><li><b>4G(第四代广域无线网络)</b><br>我们平常使用的手机网络(联通、电信…)也能够接入因特网，这就用到了与蜂窝电话相同的无线基础设施，通过蜂窝网提供商(电信…)运营的基站来发送和接收分组。<br>和WiFi不同的是，我们在使用4G网络的时候，并不需要在接入点几十米范围内，而是在基站数万米内都可以使用。</li><li><b>LTE(Long-Term-Evolutuon,长期演进)</b><br>来源于3G技术</li></ul><h2 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a><font size="5">物理媒体</font></h2><p>在前面说到因特网一些接入技术的时候，说到了所使用的物理媒体。例如DSL使用了双绞铜线，电缆接入网络使用了光纤和同轴电缆…接下来就简要说一下常用的物理媒体。<br>我们描述下一个bit从一个端系统开始传输，经过一系列链路和路由器，到达另一个端系统的历程。</p><ul><li>源端系统发送这个bit，不久后第一台路由器接收该bit</li><li>第一台路由器转发该bit，不久后第二台路由器接收</li><li>……中间经历了若干个路由器最终到达端系统</li></ul><p>因此，该bit从源到目的地传输时，通过一系列的<b>“发射器-接收器”对</b>。对于每个发射器-接收器对，<b>通过跨越一种物理媒体传播电磁波或光脉冲来发送该比特。</b><br>物理媒体有多种形状和形式，并且对沿途的每一个发射器-接收器对来说不必具有相同的类型。<br><b>物理媒体分为两种</b></p><ul><li>引导型媒体：电波沿着固体媒体前行，如光缆、双绞铜线以及同轴电缆……</li><li>非引导型媒体：电波在空气或外层空间种传播，如无线局域网或数字卫星频道中。</li></ul><p>另外，<b>物理链路(铜线、光缆等)的实际成本与其他网络成本相比通常小很多。</b>下面说几种常见的物理媒体：</p><h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a><font size="5">双绞铜线</font></h3><ul><li>最便宜最常用的引导型传输媒体；</li><li>由两根绝缘铜线组成以规则的螺旋排列，一对电线构成了一个通信链路。</li><li>数据传输速率取决于线的粗细以及传输方和接收方之间的距离。</li></ul><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><font size="5">同轴电缆</font></h3><p>和双绞线类似，由两个铜导体组成，但这两个铜导体是<b>同心而不是并行</b>的，同轴电缆能够达到较高的数据传输速率，在电缆电视系统中相当普遍。特别的，<b>许多端系统能够直接与该电缆相连，每个端系统都能接收由其他端系统发送的内容。</b></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><font size="5">光纤</font></h3><p>一种柔软的、能够引导光脉冲的媒体，每个脉冲表示一个bit。有以下特点：</p><ul><li>比特速率极高</li><li>不受电磁干扰并且光缆信号衰减极低</li><li>很难窃听</li></ul><p>这些特征使得光纤成为<b>长途引导型传输媒体</b>，特别是跨海链路&gt;。</p><h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a><font size="5">陆地无线电信道</font></h3><p>无线电信道承载电磁频谱中的信号，不需要安装物理线路，并且具有<b>穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力。</b>无线电信道的特性依赖于<font color="blue">传播环境和信号传输距离</font>。环境上取决于</p><ul><li>路径损耗</li><li>遮挡衰落(信号跨距离传播通过阻碍物时信号强度降低)</li><li>多径衰落(干扰对象的信号反射)</li><li>干扰(由于其他传输或电磁信号)</li></ul><p>陆地无线电信道大致划分为三类</p><ul><li><b>运行在很短距离：</b>个人设备如无线头戴耳机、无线鼠标…</li><li><b>运行在局域，</b>通常数十到几百米：无线LAN技术使用的就是该局域无线电信道</li><li><b>运行在广域，</b>跨越数万米：蜂窝接入技术使用的就是该广域无线电信道</li></ul><h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a><font size="5">卫星无线电信道</font></h3><p>一颗通信卫星连接地球上两个或多个微波发射/接收器，它们被称为<font color="blue">地面站</font>。该卫星在一个频段上接受传输，使用一个转发器(后面会说到)再生信号，并在另一个频段上发射信号。<b>通常用于无法使用DSL或电缆接入的区域。</b></p><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>前面说完了网络边缘，现在这里说一下<b>网络核心</b>，即<font color="bllue">由互联因特网端系统的分组交换机和链路构成的网状网路。</font></p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><font size="5">分组交换</font></h2><p>在各种应用程序中，端系统彼此交换<b>报文</b>。报文能够包含协议设计者需要的任何东西，可以包含控制功能，也可以包含数据。<br>源将长报文划分为较小的数据块，称之为<b>分组</b>。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。分组以<font color="red">等于该链路最大传输速率的速度</font>通过通信链路。例如，源或分组交换机将一个长为L的分组发送出去，链路的传输速率为R(bit/s)，那么传输该分组的时间为L/R秒。</p><h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a><font size="5">存储转发传输</font></h3><p><b>交换机能够开始向输出链路传输该分组的第一个bit之前，必须接收到整个分组。</b><br>多数分组交换机在链路的输入端使用存储转发传输。</p><h3 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a><font size="5">排队时延和分组丢失</font></h3><p>每台分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个输出缓存/输出队列</p><ul><li><b>输出缓存/输出队列</b><br>用于存储路由器正准备发往那条链路的分组。</li></ul><p>该输出缓存在分组交换中作用很大，如果到达的分组需要传输到某条链路，但发现该链路正在忙于传输其他分组，那么该分组必须在输出缓存中等待。<br>因此，除了存储转发时延以外，分组还要承受输出缓存的<b>排队时延</b>。这些时延是变化的，取决于网络的拥塞程度。</p><ul><li><b>分组丢失</b><br>前面说过，分组可能将会在路由器中的输出缓存中等待，因为<font color="bllue">缓存空间大小是有限</font>的，一个到达的分组可能发现路由器的<b>缓存空间已经被其他等待传输的分组完全充满</b>。在这种情况下，将会出现<font color="bllue">分组丢失/丢包</font>。到达的分组或已经排队的分组之一将被丢弃。</li></ul><h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a><font size="5">转发表和路由选择协议</font></h3><p>路由器从一条通信链路得到分组，然后向与它相连的另一条链路转发分组，那么问题来了，路由器是怎么决定它应当向哪条链路进行转发呢？<br>在因特网中，每个端系统都有一个地址，被称为<b>IP地址</b>。当源主机要向目的主机发送一个分组时，源在该分组的首部包含了目的主机的IP地址。如同邮政地址一样，该地址具有<b>等级结构</b>。分组到达路由器时，路由器<b>检查该分组目的地址的一部分</b>，并向一台相邻的路由器转发该分组。<br>更特别的，每台路由器具有一个转发表</p><ul><li><b>转发表</b><br>用于将目的地址(或目的地址的一部分)映射成输出链路。</li></ul><p><font color="red">当分组到达路由器时，路由器检查分组的目的地址(或一部分)，用这个地址搜索转发表，找到合适的出链路，路由器将分组导向该链路。</font></p><ul><li>转发表的设置<br>因特网具有一些特殊的路由选择协议，用于<b>自动</b>的设置这些转发表。</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><font size="5">电路交换</font></h2><p>在电路交换网络中，端系统会话期间，<b>预留了端系统间路径通信所需要的资源。</b>而在分组交换网络中，这些资源则不是预留的，会话的报文按需使用资源，这样就带来了等待(排队)接入链路。</p><hr><p>举例说明，现有两家餐馆</p><ul><li><b>分组交换</b><br>不需要预定，但不保证能安排顾客，即顾客去的时候可能餐馆满了，就需要排队等待</li><li><b>电路交换</b><br>在去之前必须提前预定，虽然麻烦，但是我们到的的时候能够立即入座点菜。</li></ul><hr>传统的电话网络就是电路交换的例子，在发送方能够发送信息之前，该网络必须在发送方和接收方建立一个<b>名副其实的连接</b>，因此此时沿着该发送方和接收方之间路径上的交换机都将为该连接维护连接状态。该连接被称为一条<b>电路</b>当网络创建这种电路时，也在连接期间为该网络链路上<b>预留了恒定的传输速率</b>(每条链路传输容量的一部分)，能够<b>确保发送方以恒定速率向接收方传输数据。</b><p>例如：A向B发送报文，网络必须在链路中预留一条电路，如果一个链路的传输速率为1Mbps，有四条电路，那么A向B发送报文的速率恒定为250kbps，即使该链路此时只有这一条连接。</p><h3 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a><font size="5">电路交换网络中的复用</font></h3><p>前面说的电路是通过频分复用(FDM)或时分复用(TDM)来实现的，并不是真正的电线电路。</p><ul><li><b>频分复用(FDM)</b><br>链路的频谱由跨越该链路创建的所有连接共享。特别的，在连接期间为每条连接专用一个频段。在电话网络中，这个频段的宽度通常为4kHz。这个频段的宽度称为<b>带宽</b></li><li><b>时分复用(TDM)</b><br>对于时分复用，时间被划分为固定时期的<b>帧</b>，每个帧又被划为为固定数量的<b>时隙</b>。当网络跨越链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用。<br>在TDM中，一条电路的<font color="bllue">传输速度等于帧速率乘一个时隙中的比特数量。</font><br>例如一个帧为1分钟，一个帧有60个时隙(即一个时隙1秒)，如果网络指定第二个时隙为该连接专用，那么在每分钟的第二秒时间内为该链接传送数据，其他的时隙即使没有连接使用，该链接也不能使用。</li></ul><p><b>通过上面的描述我们不难发现，电路交换虽然能够保证数据传输的速率，但是往往会造成资源的浪费，总体上说分组交换要更优一些。</b></p><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a><font size="5">网络的网络</font></h2><p>前面说过，端系统通过一个接入ISP和因特网相连，因为因特网是将数以亿计的端系统相连，因为ISP自身也必须互联，通过创建<font color="bllue">网络的网络</font>可以做到这点。</p><ul><li><b>网络的网络</b><br>可以理解为将ISP连接成网络，因为ISP自身就是一个网络，将许多ISP连接成网络，就实现了与不同ISP相连的端系统相连。</li></ul><p>总的来说，今天的因特网是一个网络的网络，由十多个第一层ISP和数十万个较底层的ISP组成，较低层的ISP与较高层的ISP相连，较高层的ISP彼此互联。<br>用户和内容提供商是较低层ISP的客户，较底层ISP是较高层ISP的客户。也有一下大型的内容提供商(谷歌等)创建自己的网路，直接在一些地方和较低层ISP互联。从而减少这些大型内容提供商向顶层ISP支付的费用。</p><h1 id="分组交换网中的延时、丢包和吞吐量"><a href="#分组交换网中的延时、丢包和吞吐量" class="headerlink" title="分组交换网中的延时、丢包和吞吐量"></a>分组交换网中的延时、丢包和吞吐量</h1><p>因特网能够看成是一种基础设施，为运行在端系统上的分布式应用提供服务。在理想情况下，我们希望它能够在任意两个目标端系统之间随心所欲地移动数据而不会产生数据丢失。然而，这是很难做到的。相反的，计算机网络必定要限制在端系统之间的<b>吞吐量</b>，在端系统之间引入时延、并且也会丢失分组。</p><ul><li><b>吞吐量</b><br>每秒能够传送的数据量</li></ul><h2 id="时延概述"><a href="#时延概述" class="headerlink" title="时延概述"></a><font size="5">时延概述</font></h2><p>前面说过，分组从源到目的地的过程中，当分组从每个节点(主机或路由器)沿着这条路径到后继节点，该分组在每个节点经受了几种不同类型的时延</p><ul><li><b>节点处理时延</b></li><li><b>排队时延</b></li><li><b>传输时延</b></li><li><b>传播时延</b></li></ul><p>这些时延加起来就是<font color="bllue">节点总时延</font>。</p><ul><li><b>节点处理时延</b><br>检查分组首部和决定该分组导向何处所需要的时延是节点处理时延的一部分，通常是<b>微秒或更低的数量级</b></li><li><b>排队时延</b><br>在队列中，当分组在链路上等待传输时，它经受排队时延。一个分组排队时延取决于在它前面正在排队等待向链路传输的分组数量如果队列为空，那么排队时延为0。通常是<b>毫秒到微秒量级</b></li><li><b>传输时延</b><br>将<font color="bllue">所有分组的bit推向链路所需要的时间</font>，单位是bit/s，通常是<b>毫秒到微秒量级</b></li><li><b>传播时延</b><br>当<font color="red">比特被推向链路后</font>，该比特需要向下一个路由器传播。从该链路的起点到路由器B传播所需要的时间是传播时延。<font color="blue">传播时延等于两台路由器之间距离除以传播速率</font>。在广域网中，通常是<b>毫秒量级</b></li><li><b>传输时延和传播时延的比较</b><ul><li><b>传输时延</b><br>由路由器将分组推向链路所需要的时间，<font color="red">和距离无关，和分组大小相关</font>；单位是bit/s。</li><li><b>传播时延</b><br>是分组被路由器推出链路后经过链路传播到下一台路由器所需要的时间，<font color="red">和分组长度无关，和两台路由器之间的距离相关</font>；单位是m/s。</li></ul></li></ul><h2 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a><font size="5">排队时延和丢包</font></h2><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a><font size="5">排队时延</font></h3><ul><li>假设a表示分组到达队列的平均速率(以bps/s为单位)</li><li>R表示传输速率，即从队列中推出比特的速率(以bps/s为单位)</li><li>假定所有的分组都由L个比特组成。</li></ul><p>那么bit到达队列的平均速率为(La)bps/s。最后，假设该队列很大，能够容纳无限数量的bit，那么比率La/R被称为<b>流量强度</b></p><ul><li><b>流量强度</b><ul><li><b>La/R&gt;1</b>，即比特到达队列的平均速率超过从该队列传输出去的速率。这时，队列将会无限增加，排队时延就会趋于无穷大。</li><li><b>La/R≤1</b>，这时，到达流量的性质将影响排队时延。<ul><li>分组周期性到达，即每L/R秒到达一个分组，则每个分组到达时，队列刚好将上一个分组全部推出。此时队列为空，就不会有排队时延</li><li>分组以突发形式到达，即在某个时刻同时到达很多分组。就可能会有很大的平均排队时延</li></ul></li></ul></li></ul><p>因此：<font color="red">设计系统时流量强度不能大于1。</font><br>通常情况下，分组到达队列的时间是随机的</p><ul><li><b>到达速率小于传输能力时</b><br>队列的长度将缩短</li><li><b>流量强度接近于1时</b><br>平均队列长度将会变得越来越长。</li></ul><h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a><font size="5">丢包</font></h3><p>在上面，我们假设了队列能够容纳无穷多的分组，在现实中，链路的队列容量是有限的。随着流量强度接近于1，队列并不是趋于无穷大。到达的分组发现一个满的队列，该分组将会被路由器丢掉。<br><font color="bllue">丢失的比例随着流量强度的增加而增加。</font>因此，一个节点的性能不仅根据时延来度量，也根据丢包的概率来度量。<br>后面会说到，<b>丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源送到了目的地。</b></p><h2 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a><font size="5">端到端时延</font></h2><p>前面的讨论集中在节点时延上，即在单台路由器上的时延，这里考虑从源到目的地的总时延(端到端时延)<br>端到端的时延就是<font color="bllue">源主机的时延和路由器时延之和</font>，即节点时延的总和</p><h2 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a><font size="5">计算机网络中的吞吐量</font></h2><ul><li><b>瞬时吞吐量</b><br>A向B发送数据，任何时间瞬间B接收该文件的速率</li><li><b>平均吞吐量</b><br>A向B发送大小为Fbit的文件，B接收所有Fbit用了Ts，则平均吞吐量为F/T</li></ul><p><b>服务器传送一个文件到客户端，两者之间只有一台路由器</b></p><ul><li>假设Rs为服务器和路由器之间的链路速率</li><li>假设Rc为路由器和客户端之间的链路速录</li><li>假设网络中只有该服务器到客户端的bit在传送</li></ul><p>那么<font color="red">服务器到客户端的吞吐量就是min(Rs,Rc)</font><br>我们想象bit是流体，链路是管道。显然，这台服务器不能以超过Rs的速率发送bit，路由器也不能以超过Rc的速率转发，最终的吞吐量取决去两者中小的那一个。<br><b>服务器传送一个文件到客户端，两者之间有N-1台路由器</b></p><ul><li>那么就有N条链路</li><li>假设这N条链路的速率分别是R1、R2…Rn</li></ul><p>那么<font color="red">服务器到客户端的吞吐量就是min(R1,R2…Rn)</font><br>目前，因特网核心都超量配置了高速率的链路，很少发生拥塞，今天<font color="bllue">在因特网中对吞吐量的限制因素通常是接入网。</font>但是并不绝对，当很多客户端和服务器公用一条共享链路时，由于链路需要同时为多个客户端服务器传输数据。这时共享链路可能称为限制吞吐率的因素。</p><h1 id="协议层次机器服务模型"><a href="#协议层次机器服务模型" class="headerlink" title="协议层次机器服务模型"></a>协议层次机器服务模型</h1><p>各层的所有协议被称为<b>协议栈</b>。因特网协议栈由5个层次组成，从上到下依次是</p><ul><li><b>应用层</b></li><li><b>运输层</b></li><li><b>网络层</b></li><li><b>链路层</b></li><li><b>物理层</b></li></ul><p>下面就分别简要的说一下每一层</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><font size="5">应用层</font></h2><p><b>网络应用程序以及它们的应用层协议存留的地方</b><br>应用层协议包括</p><ul><li><b>HTTP：</b>HyperText Transfer Protocol(超文本传输协议)，提供了Web文档的请求和传送</li><li><b>SMTP：</b>Simple Mail Transfer Protocol(简单邮件传输协议)，提供了电子邮件报文的传输</li><li><b>FTP：</b>File Transfer Protocol(文件传输协议)，提供了两个端系统之间文件传送</li><li><b>DNS：</b>Domain Name System(域名系统)</li><li><b>……</b></li></ul><p>应用层协议分布在多个端系统上，端系统的应用陈旭之间使用协议交换信息分组。这种<font color="bllue">位于应用层的信息分组称为<b>报文</b>。</font></p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><font size="5">运输层</font></h2><p>因特网运输层<b>在应用程序端点之间</b>传送<b>应用层报文</b>。<br>两种应用层协议</p><ul><li><b>TCP：</b><br>向应用程序提供了面向连接的服务，包括应用层报文向目的地传输的确保传递和流量控制(发送方/接收方速率匹配)<br>TCP将长报文划分为短报文，并提供<b>拥塞控制机制</b>，当网络拥塞时，源抑制其传输速率。</li><li><b>UDP</b><br>向应用程序提供了无连接的服务，没有可靠性、没有流量控制、也没有拥塞控制。</li></ul><p><font color="bllue">将运输层的分组称为<b>报文段</b>。</font></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><font size="5">网络层</font></h2><p>因特网网络层<b>负责将网络层分组(数据报)从一台主机移动到另一台主机。</b><br><font color="red">源主机中的运输层协议(TCP/UDP)向网络层递交运输层报文段和目的地址</font>，就像你通过邮政服务寄信时提供的地址一样<br>网络层协议</p><ul><li><b>IP协议：</b><br>该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。</li><li><b>路由选择协议：</b><br>确定路由器的转发表。</li><li><b>……</b></li></ul><p><font color="bllue">将网络层的分组称为<b>数据报</b>。</font></p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a><font size="5">链路层</font></h2><p>因特网的网络层通过源和目的地之间一系列的路由器来路由数据报。<b>为了将分组从一个节点(路由器/主机)移动到下一个节点，网络层必须依靠链路层的服务。</b></p><ul><li>在每个节点，网络层将数据下传给链路层，链路层沿着路径(链路)将数据报传递给下一个节点。</li><li>到达下一个节点，链路层再将数据上传给网络层。</li></ul><p>链路层提供的服务取决于应用于该链路的特定的链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。<br>注意：这里的<font color="red">可靠连接服务不同于TCP的可靠传输服务</font>。<b>TCP提供从一个端系统到另一个端系统的可靠交付</b>。<br>链路层协议</p><ul><li>以太网</li><li>WiFi</li><li>电缆接入网的DOCSIS协议</li></ul><p>因为数据从源到目的地通常会经过几条链路，这些链路可能应用的链路层协议不同。网络层将受到每个不同链路层协议的不同服务<br><font color="bllue">将链路层的分组称为<b>帧</b>。</font></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><font size="5">物理层</font></h2><p><b>链路层的任务是将整个帧从一个节点移动到临近的节点，而物理层的任务是将该帧的一个个bit从一个节点移动到临近的节点。</b><br>该层的协议仍和链路层相关，并且<font color="bllue">进一步和该链路的实际传输媒体相关。</font><br>例如以太网具有很多物理层协议：</p><ul><li><b>关于双绞铜线的</b></li><li><b>关于同轴电缆的</b></li><li><b>关于光纤的</b></li><li><b>……</b></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a><font size="5">封装</font></h2><p>数据从发送端系统的协议栈向下，沿着中间的链路层交换机的路由器协议栈上上下下，然后向上到达接收端系统的协议栈。</p><ul><li>链路层交换机<br>实现了第一层和第二层，即物理层和链路层</li><li>路由器<br>实现了第一层到第三层，即物理层到链路层再到网络层。</li></ul><p>这意味着<b>路由器能实现IP协议，链路层交换机则不能。</b>但是链路层交换机能够识别第二层地址如以太网地址。<br><font color="bllue">主机实现了所有5个层次</font>，因为在发送数据时，需要将数据层层封装，最后封装为帧(链路层分组)，在接收数据时相反。因此主机必须实现所有的5个层次。</p><p><b>每一层的封装</b></p><ul><li><b>在发送主机端</b><br>应用层报文被传送给传输层</li><li><b>运输层</b><br>传输层收取到报文并附上附加信息，该首部信息将被接收端的运输层使用。<font color="blue">应用层报文和运输层首部信息一起构成了运输层分组—-报文段</font>。并将该报文段传递给网络层。</li><li><b>网络层</b><br>增加了<font color="blue">源和目的地端系统的地址</font>等网络层首部信息，<font color="blue">运输层报文段和网络层首部信息一起构成了网络层分组—-数据报</font>。并将该数据报传递给链路层。</li><li><b>链路层</b><br>增加自己的链路层首部信息，<font color="blue">网络层数据报和链路层首部信息一起构成了链路层分组—-帧</font>。</li></ul><p><b>所以我们看到，在每一层，一个分组具有两种类型的字段</b></p><ul><li><b>首部字段</b>：在当前层添加上的</li><li><b>有效载荷字段</b>：该字段通常是来自于上一层的分组</li></ul><p>实际上，封装的过程可能更加复杂。例如，一个大报文可能被划分为多个运输层的报文段(同样的，这些报文段可能被划分为多个网络层数据报)，在接收端，必须从其连续的数据包中重构这样一个报文段。</p><hr><font face="宋体"><b>第一章内容大致就这些，后面的网络攻击就不说了。后续的等看完一章写一章吧，一共16k个字，纯手打。在记录的过程中无形中对第一章内容又回顾了一遍，很明显感觉得到理解的更深入了，希望看完这篇博客的你也能学到一些知识哦。</b></font><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 计算机网络自顶向下方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之选择排序</title>
      <link href="/2019/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面说过了冒泡排序，这次来说一下<b>选择排序</b>。同样的，这次也会从算法思路、代码实现以及算法分析三个思路来剖析选择排序</p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><ol><li>第一次从arr[0]和arr[n-1]中选取最小值，与arr[0]交换</li><li>第二次从arr[1]和arr[n-1]中选取最小值，与arr[1]交换</li><li>……以此类推</li><li>第n-1次从arr[n-2]和arr[n-1]中选取最小值，与arr[n-2]交换</li><li>至此，得到一个从小到大的有序数组，一共进行n-1轮</li></ol><p>对于一个数组<font color="red">arr={3,-1,9,10,-2}</font><br><img src="/2019/09/18/排序算法之选择排序/1.png" alt></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void SelSort(int[] arr) &#123;</span><br><span class="line">int min;</span><br><span class="line">int index;</span><br><span class="line">//一共进行n-1趟排序，当确定了n-1个元素的位置后，最后一个元素的位置自然也就确定了</span><br><span class="line">for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">//假定最大值为arr[i]，下标为i</span><br><span class="line">min = arr[i];</span><br><span class="line">index = i;</span><br><span class="line">//找到i+1到最后一个元素的最大值，记录该元素的值和下标位置</span><br><span class="line">for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">if (arr[j] &lt; min) &#123;</span><br><span class="line">min=arr[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果index发生了变化，说明arr[i]不是最大的，那么就将最大值和arr[i]交换</span><br><span class="line">if (index != i) &#123;</span><br><span class="line">arr[index]=arr[i];</span><br><span class="line">arr[i] = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>算法的时间复杂度<ul><li>平均时间：O(n²)</li><li>最差情况：O(n²)</li></ul></li></ol><p>这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²)</p><ol start="2"><li>空间复杂度<ul><li>只用了一个min和一个index，和n的大小无关，所以是O(1)</li></ul></li><li>稳定性<ul><li>不难发现，<font color="red">选择排序不是稳定的</font></li></ul></li><li>另外，该排序算法在<font color="red">n比较小时较好</font></li></ol><h1 id="和冒泡排序比较"><a href="#和冒泡排序比较" class="headerlink" title="和冒泡排序比较"></a>和冒泡排序比较</h1><p>这里，我创建了一个80000大小的数组对其进行排序，分别使用冒泡排序和选择排序，并记录两种排序耗费的时间<br><img src="/2019/09/18/排序算法之选择排序/3.png" alt></p><ul><li>冒泡排序<br><img src="/2019/09/18/排序算法之选择排序/4.png" alt><br><img src="/2019/09/18/排序算法之选择排序/5.png" alt></li><li>选择排序<br><img src="/2019/09/18/排序算法之选择排序/6.png" alt><br><img src="/2019/09/18/排序算法之选择排序/7.png" alt></li></ul><hr><font size="5,face=宋体">通过上面的对比发现，<font color="red">对同样规模的随机生成的数组进行排序，选择排序要比冒泡排序快很多</font></font><br>通过查看两种排序的实现过程不难发现：<ul><li>冒泡排序，每一趟排序中，相邻元素如果逆序，都要进行交换操作，整个排序过程会<font color="red">进行很多次交换操作</font></li><li>选择排序，每一趟排序中，只需要找到最大值/最小值的元素即其下标，最后只进行一次交换交换操作，整个排序过程<font color="red">最多进行n-1次交换操作</font></li></ul><p>两方法时间上的差异就在这里体现的</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法之冒泡排序</title>
      <link href="/2019/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>正如categories所言：算法之美，是的，算法是美妙的，尤其是好的算法，总会让人感到眼前一亮，让人茅塞顿开。而今天说到的排序算法，是我们日常生活中用的及其之多的一种算法，排序算法种类也有很多，这篇博客记录的是其中较为简单地一种——<b>冒泡排序</b></p><hr><a id="more"></a><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><ol><li>通过对排序序列从前向后(数组下标从小到大)开始，依次比较<font color="red">相邻元素</font>的值</li><li>若发现两相邻元素逆序，则交换两相邻元素的位置，<font color="red">使值较大的元素逐渐从前移到后</font><ul><li>第一趟排序使序列中最大的元素移到最后一个位置</li><li>第二趟排序使序列中第二大的元素移到倒数第二个位置</li><li>……以此类推</li><li>一共需要n-1趟排序(n为序列的大小)</li></ul></li></ol><p>对于一个数组<font color="red">arr={3,-1,9,10,-2}</font><br><img src="/2019/09/18/排序算法之冒泡排序/1.png" alt></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><img src="/2019/09/18/排序算法之冒泡排序/2.png" alt></p><h1 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h1><p>因为每一趟排序都是将未排序部分的相邻元素进行比较，逆序则交换位置，那么反过来，在某一趟排序中，<font color="red">如果没有发生元素交换，说明该数组已经有序</font>，就不用在进行之后的排序<br>对于一个数组<font color="red">arr={3,-1,9,10,20}</font><br><img src="/2019/09/18/排序算法之冒泡排序/3.png" alt></p><ol><li>设置一个boolean类型的flag，初始化为true</li><li>将循环趟数的条件改为flag==true&amp;&amp;i &lt; arr.length</li><li>在进入某一趟排序之前，先将flag设置为false。<ul><li>如果在这一趟排序中，发生了相邻元素的交换，那么将flag重新设置为true</li><li>如果在这一趟排序中，没有发生相邻元素的交换，flag不变</li></ul></li><li>在进行下一趟循环时，判断flag是否为true<ul><li>如果为true，进行下一趟循环</li><li>如果为false，说明在上一趟排序中已经得到有序数组，那么不再进行下一趟排序</li></ul></li></ol><p><b>优化冒泡排序算法代码实现</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void BuSortBatter(int[] arr) &#123;</span><br><span class="line">int temp;</span><br><span class="line">//设置一个flag，判断当前趟是否进行过交换</span><br><span class="line">boolean flag = true;        </span><br><span class="line">for (int i = 1; flag==true&amp;&amp;i &lt; arr.length; i++) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + 1];</span><br><span class="line">arr[j + 1] = temp;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样对于上面的数组<font color="red">arr={3,-1,9,10,20}</font>，使用优化冒泡排序<br><img src="/2019/09/18/排序算法之冒泡排序/5.png" alt><br>这样就达到了优化的目的</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>算法的时间复杂度<ul><li>平均时间：O(n²)</li><li>最差情况：O(n²)</li></ul></li></ol><p>这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²)</p><ol start="2"><li>空间复杂度<ul><li>只用了一个临时变量和一个flag，和n的大小无关，所以是O(1)</li></ul></li><li>稳定性<ul><li>稳定性：即在排序过程中，对于两个大小相等的数A和B，排序前A在B的前面，如果排序后A还在B的前面，<font color="red">即排序前后不改变想等元素的顺序</font>，那么称该排序方法是稳定的</li><li>不难发现，<font color="red">冒泡排序是稳定的</font></li></ul></li><li>另外，该排序算法在<font color="red">n比较小时较好</font><hr></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八皇后问题</title>
      <link href="/2019/09/18/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/18/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><font size="5"><b>八皇后问题</b></font><br>一个古老而著名的问题，该问题是回溯算法的典型案例。在8*8格的国际棋盘上摆放8个皇后，使其相互不能攻击。即：任意两个皇后不能处于同一行、同一列或同意斜线上，问有多少中摆法？</p><hr><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ul><li>第一个皇后先放在第一行第一列</li><li>第二个皇后放在第二行第一列，然后判断是否满足条件<ul><li>不满足：继续放在第二行第二列…依次把所有列放完，找到一个合适的位置</li><li>满足：摆放下一个皇后(递归)</li></ul></li><li>直到第八个皇后也能放在一个满足条件的位置，就算找到一个正确解(递归出口)</li><li>当得到第一个正确解时，就会开始回溯，即将第一个皇后放在第一列的所有正确节点全部找到</li><li>然后回头继续将第一个皇后放在第二列，后面继续循环执行上面的步骤</li></ul><h1 id="一维数组代替二维数组"><a href="#一维数组代替二维数组" class="headerlink" title="一维数组代替二维数组"></a>一维数组代替二维数组</h1><p>理论上，我们应该创建一个二维数组表示棋盘，但实际上可以通过算法，用一个一维数组解决问题<br>例如：arr[8]={0,4,7,5,2,6,1,3}</p><ul><li>数组arr的下标：表示第几行，即第几个皇后</li><li>arr[i]=val：表示第i+1个皇后放在第i+1行的val+1的位置</li></ul><h1 id="检查冲突的方法"><a href="#检查冲突的方法" class="headerlink" title="检查冲突的方法"></a>检查冲突的方法</h1><p><img src="/2019/09/18/八皇后问题/1.png" alt>该方法用于检查当前第n个皇后和前面的n-1个皇后是否发生冲突(即是否在同一行、同一列或同一斜线上)</p><ul><li><font color="red">arr[n] == arr[i]：</font>数组的值表示的是列，这里是判断第i+1个皇后是否和第n+1个皇后在同一列</li><li><font color="red">Math.abs(n-i)==Math.abs(arr[n]-arr[i])：</font>判断第i+1个皇后是否和第n+1个皇后在同一斜线<ul><li><font color="red">Math.abs(n-i)：</font>第i+1个皇后和第n+1个皇后的行数差</li><li><font color="red">Math.abs(arr[n]-arr[i])：</font>第i+1个皇后和第n+1个皇后的列数差<br>如果行数差==列数差，说明两个皇后在同一斜线上</li></ul></li></ul><h1 id="递归回溯方法"><a href="#递归回溯方法" class="headerlink" title="递归回溯方法"></a>递归回溯方法</h1><p><img src="/2019/09/18/八皇后问题/2.png" alt></p><ol><li>首先，创建一个长度为9的数组，0-7用于表示8个皇后，最后一个用于记录摆放方法个数</li><li>当n==MAX=8时：之前说过，n代表第n+1个皇后(例如n=0时代表第一个皇后)，那么n=8应该代表的是第9个皇后，这时候说明前8个皇后都已经摆放好了，即找到了一种摆放方法<ul><li>arr[MAX]++：个数+1；</li><li>打印当前摆放方法</li></ul></li><li>n&lt;MAX说明皇后还没有摆放完，先将当前皇后摆放在第i列，检查这个位置是否和前面已经摆放的皇后位置冲突<ul><li>如果不冲突，递归调用方法，摆放下一个皇后</li><li>如果冲突，i++，回到第3步。(即将当前皇后摆放到下一列，继续判断)</li></ul></li></ol><hr><font size="5" color="red"><b>当找到一种正确方法后，会向上回溯</b></font><br><ol><li>前面7个皇后位置不变，将第8个皇后从当前列往后摆，找到所有正确的摆法</li><li>前面6个皇后不变，将第7个皇后向后摆放1列<ul><li>将第8个皇后从第1列往后摆，找到所有正确的摆法</li><li>回到第2步，直到将第7个皇后摆放到最后1列，找到所有正确的摆法</li></ul></li><li>前面5个皇后不变….</li><li>以此类推，直到最后将第1个皇后摆放到最后1列。这样，就找到了所有正确的解法！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫问题</title>
      <link href="/2019/09/18/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/18/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><font size="5"><b>迷宫问题</b></font><br>有一个迷宫，迷宫中有一个小球，要求给小球一个起始位置和迷宫的终点位置，给小球找到一条路能够到达终点位置。</p><hr><a id="more"></a><h1 id="构建迷宫"><a href="#构建迷宫" class="headerlink" title="构建迷宫"></a>构建迷宫</h1><ul><li>用一个二维数组模拟迷宫</li><li>用1表示围墙和障碍物</li><li>用2表示小球从起始位置到终点位置走过的点<br><img src="/2019/09/18/迷宫问题/1.png" alt><br>以下就是构建好的迷宫<br><img src="/2019/09/18/迷宫问题/2.png" alt></li></ul><h1 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h1><ul><li>定义一个方法、传递一下参数<ul><li>毫无疑问、要将map二维数组传递进去</li><li>将小球的起始位置传递进去</li><li>由于这里默认出口是最右下角，就不传递终点位置了</li></ul></li><li><font color="red">递归出口：</font>前面说到了，用2表示小球走过的点，那么当终点位置map[6][5]==2时，说明小球已经走到了终点，递归结束</li><li>判断当前点map[i][j]是否为0,如果为0<ul><li>先假定通过当前点能到达终点位置，即将当前点设置为2</li><li>设置寻路策略：即每次到达一个点，就会有上下左右四种走法，所谓寻路策略，即指定小球先向哪个方向走，该方向走不通后再向哪个方向走，这里我指定的寻路策略是<font color="red">下右上左</font></li><li>如果该点的四个位置都走不通，那么说明该点不通，此时将当前点设置为3，即map[i][j]=3,表明该点走过，确认走不通</li></ul></li><li>如果不为0，那么当前点的取值情况有三种<ul><li>map[i][j]==1，说明该点为墙，走不通，返回false</li><li>map[i][j]==2，说明该点走过了，就不能再走了，返回false</li><li>map[i][j]==3，说明该点已经确定了走不通，返回false<br><img src="/2019/09/18/迷宫问题/3.png" alt></li></ul></li></ul><h1 id="找到出路"><a href="#找到出路" class="headerlink" title="找到出路"></a>找到出路</h1><p>最后根据我下右上左的寻路策略找到的路线<br><img src="/2019/09/18/迷宫问题/4.png" alt>其中2代表的就是起点到终点的路线，通过不同寻路策略找到的路线可能不同</p><hr><p><font size="5"><b>对于递归解决迷宫问题，我想可以这么理解</b></font><br>每次走到一个点时，都会按照寻路策略的顺序走</p><ul><li>如果某个方向能走通，那就继续往下走</li><li>如果到了某个点时，该点四个方向都走不通，那么就回溯，即回到该点的上一个节点，从上一个点的其他方向继续走</li></ul><p>例如：<br>对于A点，我们按照寻路策略先向下走，走到了B点，这时候发现，B点四个方向都走不通，那么<font color="red">就回退到A点，按照寻路策略向右走</font>。以此类推，直到找到终点和每个点都被标记为3。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰计算器</title>
      <link href="/2019/09/16/%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2019/09/16/%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>今天重新学习了一下栈这一经典的数据结构，突然想起来当时大二为了进实验室用安卓写的一个计算器app，当时也是年轻，虽然写出来了，但是对于中缀转后缀却仍是似懂非懂、迷迷糊糊，所以趁着刚复习完栈这个号时候，准备趁热打铁，把这方面给弄明白了。</p><hr><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="什么是中缀表达式"><a href="#什么是中缀表达式" class="headerlink" title="什么是中缀表达式"></a><font size="5">什么是中缀表达式</font></h2><p>中缀表达式，就是我们平常见到的表达式，例如1+((2+3)*4)-5。<br>它便于我们理解和计算，但是却不利于计算机来运算，因为在运算过程中需要不停的判断操作符优先级</p><h2 id="什么是后缀表达式"><a href="#什么是后缀表达式" class="headerlink" title="什么是后缀表达式"></a><font size="5">什么是后缀表达式</font></h2><p>后缀表达式，又称为逆波兰式，上面的1+((2+3)<em>4)-5。<br>转换成后缀表达式就是123+4</em>+5-，计算机在计算后缀表达式的时候，不用判断操作符的优先级，每次遇到操作符，直接从栈中弹出两个操作数进行相应的运算即可，但是这样的表达式对我们来说写出来就比较困难，尤其是在表达式比较长比较复杂的时候。</p><h1 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h1><p>首先，我先说一下我的大致思路</p><ul><li>将中缀表达式的字符串存储到一个ArrayList中==&gt;这一步主要是方便操作、</li><li>一个存放操作符的栈s1</li></ul><p>注意：网上大多的教程是准备两个栈，一个存放操作符，一个存放的是逆序的后缀表达式，但这里我用ArrayList集合代替了第二个栈，这样做的好处就是可以直接得到后缀表达式，而非逆序的，至于为什么后面会说</p><h2 id="中缀表达式集合"><a href="#中缀表达式集合" class="headerlink" title="中缀表达式集合"></a><font size="5">中缀表达式集合</font></h2><ul><li>遍历字符串</li><li>如果当前字符是操作符，那么直接加入到集合中</li><li>如果当前字符是操作数，那么就要考虑多位数操作数的问题<ul><li>继续向后遍历，如果后面的字符仍是操作数，就将这些数拼接起来</li><li>直到当前字符不是操作数为止，将拼接的字符串加入到集合中<br><img src="/2019/09/16/逆波兰计算器/1.png" alt></li></ul></li></ul><h2 id="判断操作符优先级"><a href="#判断操作符优先级" class="headerlink" title="判断操作符优先级"></a><font size="5">判断操作符优先级</font></h2><p><img src="/2019/09/16/逆波兰计算器/3.png" alt></p><h2 id="后缀表达式集合"><a href="#后缀表达式集合" class="headerlink" title="后缀表达式集合"></a><font size="5">后缀表达式集合</font></h2><p>上一步我们得到了一个集合，集合中存储着中缀表达式内容，这一步就要将中缀表达式转换为后缀表达式并存储到集合中<br>步骤：</p><ul><li>创建变量<ul><li>栈s1用于存放操作数</li><li>集合ls用于存放后缀表达式</li></ul></li><li>遍历中缀表达式集合list，如果是操作数，直接放到ls集合中</li><li>如果是”(“，直接压入s1中</li><li>如果是”)”，将s1中的操作符出栈并加入到ls集合中，直到s1栈顶元素为”(“为止，最后将”(“也出栈(但是不加入ls中)，这一步操作目的是消去”()”</li><li>如果是操作符<ul><li>如果s1栈为空，那么直接入栈</li><li>如果当前操作符优先级<font color="red">大于</font>栈顶操作符优先级，将当前操作符入栈</li><li>如果当前操作符优先级<font color="red">不大于</font>栈顶操作符优先级，那么将栈顶元素出栈并加入到ls集合中，继续和新的栈顶操作符比较，直到栈为空或者当前操作符优先级大于栈顶操作符优先级为止</li><li>将当前操作符压入s1中</li></ul></li><li>集合list遍历完毕后，将s1中所有元素依次出栈加入到ls集合中</li><li>最后得到的ls集合就是后缀表达式</li></ul><p><font color="red"><b>注意：</b></font>这里如果用栈代替集合，那么由于栈先进后出的特性，得到的只能是逆序的后缀表达式，还要进一步的转换才能得到后缀表达式<br><img src="/2019/09/16/逆波兰计算器/2.png" alt></p><h1 id="计算后缀表达式"><a href="#计算后缀表达式" class="headerlink" title="计算后缀表达式"></a>计算后缀表达式</h1><ul><li>创建一个栈stack用于存放操作数</li><li>从左向右扫描后缀表达式集合<ul><li>如果是操作数，直接入栈</li><li>如果是操作符，就从stack中弹出两个操作数进行运算，并将运算结果重新入栈</li><li>集合遍历完毕，stack剩下的元素就是最后的结果<br><img src="/2019/09/16/逆波兰计算器/4.png" alt></li></ul></li></ul><hr><font face="宋体" size="5"><b>这样一个简单地逆波兰计算器就成功了，核心逻辑在于如何利用栈将中缀表达式转换为后缀表达式(逆波兰式)</b></font><hr>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 逆波兰表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的环问题</title>
      <link href="/2019/09/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><font size="5"><b>首先，关于单链表的环，一般涉及到以下几个问题</b></font></p><ul><li>给一个单链表，判断是否有环</li><li>如果存在环，找出环的入口点</li><li>如果存在环，求出环上节点的个数</li><li>如果存在环，求出链表的长度</li></ul><hr><a id="more"></a><h1 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h1><h2 id="解法一：快慢指针法"><a href="#解法一：快慢指针法" class="headerlink" title="解法一：快慢指针法"></a><font size="5">解法一：快慢指针法</font></h2><ol><li>有两个指针fast和slow，开始时两个指针都指向链表头head</li><li>将两个指针同时向后移动<ul><li>fast每次走两步==&gt;fast=fast.next.next</li><li>slow每次走一步==&gt;slow=slow.next</li></ul></li><li>如果没有环，那么fast和slow一定不会相遇；当fast.next==null||slow==null时说明该链表没有环，因为<font color="red">有环的链表没有nul指针</font></li><li>如果有环，那么slow一定会和fast相遇,并且此时slow指针最多绕环一圈，即slow走的步数一定小于等于单链表的节点数<ul><li>可以这么理解，当链表时环形链表时，环是最大的，此时slow刚好绕环一圈回到头指针指向的节点时</li><li>fast的速度是slow的二倍(因为fast每次走2步)，所以fast此时一定走了两圈，也回到了头指针指向的节点，最终会在头节点相遇</li><li>如果链表不是环形链表，那么环的长度就会更短，此时fast一定能在slow走完一圈之前和slow相遇</li></ul></li></ol><p>(可以画图帮助理解)<br><img src="/2019/09/15/单链表的环问题/1.png" alt>方法返回的是相遇的节点</p><h2 id="解法二：HashSet法"><a href="#解法二：HashSet法" class="headerlink" title="解法二：HashSet法"></a><font size="5">解法二：HashSet法</font></h2><ol><li>遍历链表，将当前节点的引用存储到HashSet中</li><li>如果当遍历到某个节点时，HashSet集合中已经存在该节点的引用，那么说明该链表有环，并且<font color="red">第一个重复的节点就是入环口</font><br><img src="/2019/09/15/单链表的环问题/2.png" alt></li></ol><h1 id="找出环的入口点"><a href="#找出环的入口点" class="headerlink" title="找出环的入口点"></a>找出环的入口点</h1><p>如果用HashSet方法来解决第一个问题，那么这个问题就同时得到了解决<br>如果用快慢指针法解决第一题，那么<font color="red">得到fast和slow第一次相遇的节点</font>，</p><p><font color="blue">假设slow和fast相遇时，slow还没有走完链表，即链表不是首尾相接的环形链表</font><br><font color="red"><b>分析</b></font></p><ol><li>假设<ul><li>链表的长度为L</li><li>环的长度为r(即环有r个节点)</li><li>head节点到入环口的距离为a(即从head到入环节点要走a步)</li><li>入环口和相遇点的距离是x(从入环节点到相遇点要走a步)</li></ul></li><li>假设fast和slow相遇时，fast已经在环内循环了n圈，slow走了s步，在环内走一圈的步数=环的长度<ul><li>那么fast走过的步数为：2s步</li></ul></li><li>则有：2<em>s=s+n *r–&gt;s=n</em>r</li><li>又有s=a+x–&gt;因为前面说过slow节点没有走完一圈，所以这就是最简单的步数相加</li><li>所以得到a+x=n*r<ul><li>a+x=(n-1)*r+r</li><li>a+x=(n-1)*r+L-a</li></ul></li><li>a=(n-1)*r+(L-a-x)<ul><li>a：head到入环节点要走a步</li><li>(L-a-x)：从向相遇节点到入环节点要走(L-a-x)步</li></ul></li></ol><p><font color="red"><b>经过上面分析可以总结得到解决方法</b></font></p><ul><li>设置两个临时指针str1和str2<ul><li>str1=head</li><li>str2=slow(slow是第一问得出的相遇节点)</li></ul></li><li>让两个节点同时往后走，直到str1==str2为止<ul><li>str1=str1.next</li><li>str2=str2.next</li></ul></li><li>str1==str2时退出循环，此时的str1/str2就是入环节点<br><img src="/2019/09/15/单链表的环问题/3.png" alt></li></ul><p><font color="blue"><b>特殊情况：即链表首尾相接(环长度最大)</b></font></p><ul><li>此时slow节点和fast节点在head相遇，即slow==head</li></ul><p>根据上面的代码会直接返回head/slow，因此也满足特殊情况</p><h1 id="求出环上节点的个数"><a href="#求出环上节点的个数" class="headerlink" title="求出环上节点的个数"></a>求出环上节点的个数</h1><h2 id="解法一：相遇节点法"><a href="#解法一：相遇节点法" class="headerlink" title="解法一：相遇节点法"></a><font size="5">解法一：相遇节点法</font></h2><ol><li>设置一个临时指针temp=slow(相遇节点)</li><li>让临时指针temp后移–&gt;temp=temp.next，并记录移动次数count</li><li>当temp==slow时，说明temp绕环走了一圈，count就是换的长度</li></ol><h2 id="解法二：快慢指针法"><a href="#解法二：快慢指针法" class="headerlink" title="解法二：快慢指针法"></a><font size="5">解法二：快慢指针法</font></h2><ol><li>设置两个临时指针，str1=str2=slow(相遇节点)</li><li>str1每次走一步、str2每次走两步，并记录str1走的步数count<ul><li>str1=str1.next</li><li>str2=str2.next.next</li></ul></li><li>当str1==str2(再次相遇)时，说明str2刚好比str1多走1圈，此时count就是环上节点的个数<ul><li>假设再次相遇时str1走了s步、str2走了2*s步、环的长度为r</li><li>由分析得到2*s=s+r，所以s=r;<br><img src="/2019/09/15/单链表的环问题/4.png" alt></li></ul></li></ol><h1 id="求出链表的长度"><a href="#求出链表的长度" class="headerlink" title="求出链表的长度"></a>求出链表的长度</h1><p>链表长度L=head节点到入口节点的距离a+环的长度r<br>根据上面两个问题，这个就很好解决<br><img src="/2019/09/15/单链表的环问题/5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> HashSet </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Josefu问题(约瑟夫环)两种解决方法</title>
      <link href="/2019/09/15/Josefu%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF-%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/15/Josefu%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF-%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><b>约瑟夫问题</b><br>设编号为1、2….n的n个人坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出圈，他的下一位又从1开始报数，数到m的人又出圈，以此类推，直到所有人出圈为止，由此产生一个出圈编号的序列</p><hr><a id="more"></a><h1 id="解法一：循环链表"><a href="#解法一：循环链表" class="headerlink" title="解法一：循环链表"></a>解法一：循环链表</h1><ol><li>首先对参数k、m、n进行校验，确保k、m、n在正常范围内</li><li>创建一个辅助指针helper</li><li>让helper指向first前一个节点，即指向最初链表的最后一个节点</li><li>将first和helper向后移动k-1次，即让first指向开始报数的小孩</li><li>当helper==first时，说明圈中只有一个小孩</li><li>helper！=first时，将first和helper同时向后移动m-1次</li><li>将移动m-1此之后first指向的节点出圈</li><li>继续执行5，直到helper==first为止</li></ol><p><img src="/2019/09/15/Josefu问题-约瑟夫环-两种解决方法/1.png" alt><br>其中方法的参数：</p><ul><li>k：第一次开始报数的小孩</li><li>count：每次数几下(m)</li><li>nums：最开始圈中小孩数</li></ul><p>这个约瑟夫问题是基于我自己创建的单向环形链表实现的(或者说我创建的单向环形链表是用来解决约瑟夫问题的)，helper节点最初就指向first前一个节点，所以2和3两步骤可以省略<br>(可以看一下我创建单项循环链表的博客)</p><h1 id="解法二：数组"><a href="#解法二：数组" class="headerlink" title="解法二：数组"></a>解法二：数组</h1><p>对于数组，进行出圈操作的时候就不能向链表一样删除节点了，因为数组的长度是固定的，那么怎么解决呢？我们可以将<font color="red">已经出圈的孩子所在的元素值赋值为0</font>，这样，当我们遍历到元素值为0的节点时，就可以跳过该节点。<br>步骤：</p><ol><li>首先对参数k、m、n进行校验，确保k、m、n在正常范围内</li><li>因为数组下标是从0开始，小孩编号从1开始，所以让开始数数的小孩编号-1==&gt;k=k-1</li><li>根据nums创建数组，模拟nums个小孩组成的圈</li><li>一共有nums个小孩，所以一共要循环报数nums次==&gt;for (int i = 0; i &lt; nums; i++) {}</li><li>每一次报数m次，所以k要移动m-1次(起初报数时，自己也算一次)，当k代表的数组元素a[k]==0时，说明当前孩子已经出圈，所以需要k再次移动，直到a[k]!=0==&gt;for (int j = 0; j &lt; m - 1||arr[k]==0;) {}</li><li>第5步得到的k是该赋值为0的元素，即该出圈的孩子编号-1==&gt;k+1即为当前该出圈的孩子编号</li><li>a[k]=0，并且将k取模移向下一位</li><li>重复567nums次，直到所有孩子都出圈<br><img src="/2019/09/15/Josefu问题-约瑟夫环-两种解决方法/2.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环形链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-环形链表</title>
      <link href="/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>环形链表，顾名思义，就是整个链表构成一个环，将单链表的最后一个节点的next指针指向头节点，这样就构成了循环链表。这里说的循环链表主要用于解决<font color="red">约瑟夫环问题</font>和<font color="red">判断链表是否有环</font>两个算法问题。</p><hr><a id="more"></a><h1 id="环形链表节点"><a href="#环形链表节点" class="headerlink" title="环形链表节点"></a>环形链表节点</h1><p><img src="/2019/09/15/数据结构-环形链表/1.png" alt></p><ol><li>int val：存储数据</li><li>Node next：指向另外一个Node节点</li></ol><h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><font size="5">成员变量</font></h2><p><img src="/2019/09/15/数据结构-环形链表/2.png" alt></p><ol><li>head：环形链表的头指针</li><li>helper：环形链表的尾指针，每次都指向新插入的节点<font color="red">(helper.next=head)</font></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a><font size="5">成员方法</font></h2><h3 id="public-void-Add-int-ele"><a href="#public-void-Add-int-ele" class="headerlink" title="public void Add(int ele)"></a><font size="5">public void Add(int ele)</font></h3><p><img src="/2019/09/15/数据结构-环形链表/3.png" alt>向链表中添加元素</p><ol><li>在添加之前，判断当前链表是否为空</li><li>如果为空<ul><li>将head头指针指向新创建的节点==&gt;head=new Node(ele)</li><li>helper指针也指向新创建的节点==&gt;helper=head</li><li>将新创建节点的next指针指向head，构成一个环==&gt;helper.next=head</li></ul></li><li>如果不为空<ul><li>将helper指针指向节点(尾节点)的next指针指向新节点==&gt;helper.next=new Node(ele)</li><li>将helper指针向后移，保证helper指针仍然指向尾节点==&gt;helper=helper.next</li><li>将尾节点的next指针指向head头节点，形成一个环==&gt;helper.next=head</li></ul></li></ol><p><font color="red"><b>环形链表，其实就是将单链表的尾节点的next指针指向头节点</b></font></p><h3 id="public-void-show"><a href="#public-void-show" class="headerlink" title="public void show()"></a><font size="5">public void show()</font></h3><p><img src="/2019/09/15/数据结构-环形链表/4.png" alt>打印环形链表<br>逻辑比较简单，因为在打印的过程中指针会移动，所以可以<font color="red">创建两个临时变量</font>，这样打印过后head和helper指针都没有发生变化，下次添加元素的时候仍然能够按照顺序添加</p><hr>单链表的两个算法问题会在<font color="red"><b>算法之美</b></font>分类中说到]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环形链表 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-队列</title>
      <link href="/2019/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>/2019/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>队列的特点：<font color="red"><b>FIFO–&gt;First in First out</b></font>，即先进先出<br>这篇文章讲的是数组结构存储队列，队列从功能上来说分为两种</p><ol><li>普通队列</li><li>循环队列。</li></ol><p>后面将会分别用Java手写两个队列类来讲述普通队列和循环队列</p><hr><a id="more"></a><h1 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font size="5">概述</font></h2><p>队列本身是一个有序列表，因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队头和队尾</p><ul><li>front会随着数据输出而改变</li><li>rear会随着数据输入而改变</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><font size="5">成员变量</font></h2><ol><li><font color="blue">private int maxSize;</font>            –&gt;队列最大容量</li><li><font color="blue">private int front;</font>            –&gt;队列头</li><li><font color="blue">private int rear;</font>            –&gt;队列尾</li><li><font color="blue">private T[] arr;(使用泛型)</font>    –&gt;队列存储结构：数组</li></ol><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font size="5">构造方法</font></h2><p><img src="/2019/09/14/数据结构-队列/1.png" alt>这里创建了两个构造方法：</p><ul><li>通过参数确定数组大小，即队列的容量</li><li>无参构造方法默认数组大小为10</li></ul><p><font color="red"><b>front和rear指向的位置</b></font></p><ul><li>front：指向队列头的前一个位置</li><li>rear：指向队列最后一个元素</li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a><font size="5">成员方法</font></h2><h3 id="public-boolean-isFull"><a href="#public-boolean-isFull" class="headerlink" title="public boolean isFull()"></a><font size="5">public boolean isFull()</font></h3><p><img src="/2019/09/14/数据结构-队列/2.png" alt>对于非循环队列来说，判断队列是否已满很简单，只需要<font color="blue">判断rear是否到达数组末尾即可</font></p><h3 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a><font size="5">public boolean isEmpty()</font></h3><p><img src="/2019/09/14/数据结构-队列/3.png" alt>对于非循环队列来说，队列为空就是初始状态，即<font color="blue">rear==front</font></p><h3 id="public-void-Add-T-ele"><a href="#public-void-Add-T-ele" class="headerlink" title="public void Add(T ele)"></a><font size="5">public void Add(T ele)</font></h3><p><img src="/2019/09/14/数据结构-队列/4.png" alt>对于添加元素的方法，有两个步骤</p><ol><li>先判断队列是否已满</li><li>如果队满，抛出异常</li><li>否则，先将rear后移，再进行赋值操作</li></ol><h3 id="public-T-get"><a href="#public-T-get" class="headerlink" title="public T get()"></a><font size="5">public T get()</font></h3><p><img src="/2019/09/14/数据结构-队列/5.png" alt>取队头元素的方法，同样有两个步骤</p><ol><li>判断队列是否为空</li><li>如果队空，抛出异常</li><li>否则，先将front后移指向队头元素，再返回队头元素</li></ol><h3 id="public-void-show"><a href="#public-void-show" class="headerlink" title="public void show()"></a><font size="5">public void show()</font></h3><p><img src="/2019/09/14/数据结构-队列/6.png" alt>打印当前队列所有元素</p><hr>以上就是一个基本的普通数组模拟队列类，不难发现这样的队列是有很大缺陷的<br><font color="blue">无法复用</font>：即只能用一次，当front指向arr[maxSize-1]的时候，就算此时队列中没有元素，也无法向队列中添加数据。下面来说循环队列<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><h2 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a><font size="5">成员变量</font></h2><ol><li><font color="blue">private int maxSize;</font>            –&gt;队列最大容量</li><li><font color="blue">private int front;</font>            –&gt;队列头</li><li><font color="blue">private int rear;</font>            –&gt;队列尾</li><li><font color="blue">private T[] arr;(使用泛型)</font>    –&gt;队列存储结构：数组</li></ol><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a><font size="5">构造方法</font></h2><p><img src="/2019/09/14/数据结构-队列/8.png" alt>这里创建了两个构造方法：</p><ul><li>通过参数确定数组大小，即队列的容量</li><li>无参构造方法默认数组大小为10</li></ul><p><font color="red"><b>front和rear指向的位置和普通队列不同</b></font></p><ul><li>front：指向队列头元素</li><li>rear：指向队列尾元素的后一个位置</li></ul><p>为了便于循环，<font color="red">rear指向的位置自始至终都是空着的，即队列的容量=maxsize-1</font></p><h3 id="public-boolean-isFull-1"><a href="#public-boolean-isFull-1" class="headerlink" title="public boolean isFull()"></a><font size="5">public boolean isFull()</font></h3><p><img src="/2019/09/14/数据结构-队列/9.png" alt>在循环队列中，判断队满的条件<font color="blue">(rear+1)%maxSize==front</font></p><h3 id="public-boolean-isEmpty-1"><a href="#public-boolean-isEmpty-1" class="headerlink" title="public boolean isEmpty()"></a><font size="5">public boolean isEmpty()</font></h3><p><img src="/2019/09/14/数据结构-队列/10.png" alt>在循环队列中，判断队满的条件仍是rear==front，因为rear指向的位置是不存放元素的，当front==rear时，说明队列已经没有元素了</p><h3 id="public-void-Add-T-ele-1"><a href="#public-void-Add-T-ele-1" class="headerlink" title="public void Add(T ele)"></a><font size="5">public void Add(T ele)</font></h3><p><img src="/2019/09/14/数据结构-队列/11.png" alt>在循环队列中，当rear到达队列末尾时，我们需要它从0开始，因此不能+1，要用<font color="blue">取模运算</font></p><h3 id="public-T-get-1"><a href="#public-T-get-1" class="headerlink" title="public T get()"></a><font size="5">public T get()</font></h3><p><img src="/2019/09/14/数据结构-队列/12.png" alt>在循环队列中，对于front也要用取模运算</p><h3 id="public-int-getNum"><a href="#public-int-getNum" class="headerlink" title="public int getNum()"></a><font size="5">public int getNum()</font></h3><p><img src="/2019/09/14/数据结构-队列/13.png" alt>对于(rear - front + mixsize) % mixsize运算，可以这么理解</p><ol><li>当rear&gt;front时候，说明所有的元素都处于rear和front中间，num=rear-front</li><li>当rear&lt;front时候，说明所有元素都处在rear和front两边，即rear比front多走了一个mixsize的长度，num=rear+maxSize-front;</li></ol><p>因此两者加起来就是<font color="blue">(rear - front + mixsize) % mixsize</font></p><h3 id="public-void-show-1"><a href="#public-void-show-1" class="headerlink" title="public void show()"></a><font size="5">public void show()</font></h3><p><img src="/2019/09/14/数据结构-队列/14.png" alt>特别注意循环条件，<font color="red"><b>i从front开始，做带循环的后移(取模)，直到i==rear是遍历完所有元素</b></font></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--稀疏数组</title>
      <link href="/2019/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%C2%9E/"/>
      <url>/2019/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%C2%9E/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要讲的是数组的应用之一–稀疏数组。那么什么是稀疏数组呢？我们来看一个问题：<br>假设你做了一个五子棋游戏，玩儿过的都知道这个游戏有一个叫做复盘的功能，就是你可以将这句游戏先存档，之后再读档的时候就会接着之前的继续下。我们都知道</p><a id="more"></a><ol><li>用二维数组来构造棋盘</li><li>用0表示棋盘上没有落子的位置</li><li>用1和2分别表示黑棋和白棋的位置</li></ol><p>存档：把二维数组通过流保存到硬盘中<br>那么这里面就有一个问题：如果要存档的棋盘中有大片的空白(数组中有大量的元素为0)，直接将原数组存储进去会浪费空间，这时候可以用到稀疏数组来压缩</p><hr><h1 id="稀疏数组的结构"><a href="#稀疏数组的结构" class="headerlink" title="稀疏数组的结构"></a>稀疏数组的结构</h1><h2 id="行"><a href="#行" class="headerlink" title="行"></a><font size="5">行</font></h2><ol><li>稀疏数组的行数取决于原数组非0元素的个数–&gt;<font color="red">row=num+1;</font></li><li>第一行存储着原数组的信息<ol><li>[0][0]=原数组的行数</li><li>[0][1]=原数组列数</li><li>[0][2]=原数组非0元素的个数</li></ol></li><li>剩下的每一行都存储着原数组非0元素的信息<ol><li>[i][0]=元素所在行</li><li>[i][1]=元素所在列</li><li>[i][2]=元素的值</li></ol></li></ol><p>稀疏数组的行数row=num+1：<font color="red">稀疏数组的第一行要用来存储原数组的信息，在还原的时候会用到</font></p><h2 id="列"><a href="#列" class="headerlink" title="列"></a>列</h2><ol><li><p><font color="red">所有的稀疏数组都只有3列</font></p></li><li><p>除了第一行外：</p><ol><li>第一列存储非0元素的行位置</li><li>第二列存储非0元素的列位置</li><li>第三列存储非0元素的值</li></ol></li></ol><p><b>上面说的非0元素，只是在数组中存在的大量重复元素值为0时的情况</b></p><h1 id="数组–-gt-稀疏数组"><a href="#数组–-gt-稀疏数组" class="headerlink" title="数组–&gt;稀疏数组"></a>数组–&gt;稀疏数组</h1><p>假设存在一个数组<br><img src="/2019/09/13/数据结构-稀疏数组/2.png" alt><br><img src="/2019/09/13/数据结构-稀疏数组/1.png" alt></p><ol><li>遍历原数组，获取非0元素的个数<br><img src="/2019/09/13/数据结构-稀疏数组/3.png" alt></li><li>创建稀疏数组<ul><li>稀疏数组的行数row=num+1</li><li>稀疏数组的列数col=3<br><img src="/2019/09/13/数据结构-稀疏数组/4.png" alt></li></ul></li><li>将原数组信息存储到稀疏数组第一行<ul><li>稀疏数组的第一行，存储原数组的行数、列数以及非0元素个数<br><img src="/2019/09/13/数据结构-稀疏数组/5.png" alt>    </li></ul></li><li>遍历原数组，储存其中非0元素的信息<ul><li>每一行的第一列存储元素的行信息</li><li>每一行的第二列存储元素的列信息</li><li>每一行第三列存储元素的值<br><img src="/2019/09/13/数据结构-稀疏数组/6.png" alt>    </li></ul></li><li>最后得到的稀疏数组<br><img src="/2019/09/13/数据结构-稀疏数组/7.png" alt>    </li></ol><h1 id="稀疏数组–-gt-数组"><a href="#稀疏数组–-gt-数组" class="headerlink" title="稀疏数组–&gt;数组"></a>稀疏数组–&gt;数组</h1><ol><li>创建普通数组<ul><li>数组的行数为稀疏数组第一行第一列的值</li><li>数组的列数为稀疏数组第一行第二列的值<br><img src="/2019/09/13/数据结构-稀疏数组/8.png" alt></li></ul></li><li>遍历稀疏数组的每一行<ul><li>当前行的第一列为元素的行位置</li><li>当前行的第二列为元素的列位置</li><li>当前行的第三列为元素的值<br><img src="/2019/09/13/数据结构-稀疏数组/9.png" alt>    </li></ul></li><li>最后得到原数组<br><img src="/2019/09/13/数据结构-稀疏数组/10.png" alt>    <hr><font size="5"><b>通过实际操作我们发现，将数组转换为稀疏数组后，节省的空间还较为客观，当要存储的数组中含有大量的重复元素时，我们可以采用稀疏数组来存储，能够在一定程度上节省空间<b></b></b></font><hr></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码--String类</title>
      <link href="/2019/09/10/JDK%E6%BA%90%E7%A0%81-String%E7%B1%BB/"/>
      <url>/2019/09/10/JDK%E6%BA%90%E7%A0%81-String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>这一篇的String源码基于<font color="red">JDK8</font>版本，来自于慕课网上<a href="https://www.imooc.com/read/47" target="_blank" rel="noopener">文贺老师的JAVA源码专栏(收费)</a>结合<a href="https://www.jianshu.com/p/b3e9deacd155" target="_blank" rel="noopener">张家界的雪</a>以及自己学习String源码的总结，主要的目的在于总结知识，方便后续回顾查看，如转载，请<font color="red"><b>注明出处</b></font></p><hr><a id="more"></a><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>在学习String源码之前，首先要知道String对象再内存中的存放位置，我们都知道JAVA对象一般都是存放在堆中，但是String对象是一个特例，它被<font color="red">存放在常量池中</font><br><img src="/2019/09/10/JDK源码-String类/1.png" alt>可以看到，String类实现了</p><ol><li>Serializable：序列化接口，String对象可以被序列化</li><li>Comparable：表明字符串可以比较</li><li>CharSequence：表明String对象是一个字符序列</li><li>String底层实现是一个char类型的数组并且被final修饰</li></ol><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="public-String"><a href="#public-String" class="headerlink" title="public String()"></a><font size="5">public String()</font></h2><p><img src="/2019/09/10/JDK源码-String类/2.png" alt>值为空串，很少使用</p><h2 id="public-String-String-original"><a href="#public-String-String-original" class="headerlink" title="*public String(String original)"></a><font size="5">*public String(String original)</font></h2><p><img src="/2019/09/10/JDK源码-String类/3.png" alt>这个构造方法在创建的过程中会创建两个对象，一个在堆中，一个在常量池中<br>当调用这个构造方法时String str=new String(“abc”)</p><ol><li>现在堆中new出一个String对象，并将str指向该对象</li><li>查看常量池中是否存在”abc”</li><li>如果不存在，那么就会在常量池中在创建一个String对象</li><li>如果存在，不做操作</li></ol><p>最终<font color="red">str是指向堆中的对象，而不是常量池中的对象</font><br><img src="/2019/09/10/JDK源码-String类/4.png" alt></p><ol><li>str1和str3都是指向常量池中的”abc”对象，所以str1==str3返回true</li><li>str4涉及到了变量的相加，内部实现是先new一个StringBuilder，然后 append(str2),append(“c”);然后让str4引用toString()返回的对象;<br><img src="/2019/09/10/JDK源码-String类/5.png" alt>如图，StringBuilder的toString方法实质上也是new了一个String对象，所以<font color="red">str4指向堆中的另外一个String对象</font>，所以str1==str4返回false</li><li>上面说了，str5指向堆中的一个String对象，所以str1==str5返回false<h2 id="public-String-char-value"><a href="#public-String-char-value" class="headerlink" title="public String(char value[])"></a><font size="5">public String(char value[])</font></h2><img src="/2019/09/10/JDK源码-String类/6.png" alt>如图，该构造方法实质上是<font color="red">调用Arrays工具类的copyof方法</font><h2 id="public-String-char-value-int-offset-int-count"><a href="#public-String-char-value-int-offset-int-count" class="headerlink" title="public String(char value[], int offset, int count)"></a><font size="5">public String(char value[], int offset, int count)</font></h2><img src="/2019/09/10/JDK源码-String类/7.png" alt>如图，该构造方法会<font color="red">先对起始位置进行判断，如果不合法会抛出异常</font>。最后<font color="red">调用Arrays工具类的copyOfRange来实现</font><h2 id="public-String-byte-bytes-int-offset-int-length-String-charsetName"><a href="#public-String-byte-bytes-int-offset-int-length-String-charsetName" class="headerlink" title="public String(byte bytes[], int offset, int length, String charsetName)"></a><font size="5">public String(byte bytes[], int offset, int length, String charsetName)</font></h2><img src="/2019/09/10/JDK源码-String类/8.png" alt>如图，该构造方法用byte数组构造String对象，用指定字符集转换后构造String对象。<br>其中StringCoding.decode(charsetName, bytes, offset, length)方法根据指定编码对byte数组进行解码，返回char数组<br>checkBounds方法是对<font color="red">参数进行检查，该方法为私有，只能在String类中使用</font><br><img src="/2019/09/10/JDK源码-String类/9.png" alt>该构造方法如果<font color="red">不指定charsetName，那么按照系统默认字符集进行解码</font><h2 id="public-String-StringBuffer-buffer"><a href="#public-String-StringBuffer-buffer" class="headerlink" title="public String(StringBuffer buffer)"></a><font size="5">public String(StringBuffer buffer)</font></h2><img src="/2019/09/10/JDK源码-String类/10.png" alt>通过StringBuffer构造String，因为StringBuffer内部也是一个char数组，所以实质上还是调用Arrays.copyOf方法实现，并且由于<font color="red">StringBuffer是线程安全的，所以这里也加了synchronized块保证线程安全</font><br>通过StringBuilder构造String对象和StringBuffer原理相同。不过由于StringBuilder是线程不安全的，所以没有加synchronized块<h2 id="String-char-value-boolean-share"><a href="#String-char-value-boolean-share" class="headerlink" title="*String(char value[] boolean share)"></a><font size="5">*String(char value[] boolean share)</font></h2><img src="/2019/09/10/JDK源码-String类/11.png" alt>这个构造方法是<font color="blue">protected修饰</font>的，它和public String(char value[])的区别在于多了一个boolean参数，并且不支持false<br>只支持true，这样做的原因是为了和public String(char value[])方法进行区分，否则没办法构成重载，查看方法体可以发现，它直接将char数组的的地址传递给String对象，要比注意拷贝快很多<br>但是这样做的弊端很大：<font color="red">String对象和char数组共享同一块内存，破坏了String的不可变性，</font>所以将该构造方法设置为protected保证安全,但是由于性能比较好，节约内存，所以replace、concat、valueof等方法也用到了这个构造方法<hr></li></ol><h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><h2 id="public-int-length"><a href="#public-int-length" class="headerlink" title="public int length()"></a><font size="5">public int length()</font></h2><p>返回char数组的长度</p><h2 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a><font size="5">public boolean isEmpty()</font></h2><p>char数组长度是否为0</p><h2 id="public-char-charAt-int-index"><a href="#public-char-charAt-int-index" class="headerlink" title="public char charAt(int index)"></a><font size="5">public char charAt(int index)</font></h2><ol><li>判断index是否超出char数组长度，超出则抛异常</li><li>否则返回value[index]。</li></ol><h2 id="public-void-getChars-int-srcBegin-int-srcEnd-char-dst-int-dstBegin"><a href="#public-void-getChars-int-srcBegin-int-srcEnd-char-dst-int-dstBegin" class="headerlink" title="public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)"></a><font size="5">public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)</font></h2><p><img src="/2019/09/10/JDK源码-String类/12.png" alt>将String对象指定的字符从dst[]数组的dstBegin位置向后复制,通过System.arraycopy实现，这是一个本地方法(native)。<br>参数：</p><ol><li>srcBegin：复制的起始位置(包括)</li><li>srcEnd：复制的结束位置(不包括)</li><li>dst[]：目的数组</li><li>dstBegin：目的数组dstBegin起始</li></ol><p>如果要<font color="red">复制的字符个数srcEnd-srcBegin&gt;dst.length-dstBegin,会抛出异常</font></p><h2 id="public-byte-getBytes-String-charsetName"><a href="#public-byte-getBytes-String-charsetName" class="headerlink" title="public byte[] getBytes(String charsetName)"></a><font size="5">public byte[] getBytes(String charsetName)</font></h2><p><img src="/2019/09/10/JDK源码-String类/13.png" alt>和前面传递Byte数组的构造方法相反，这里将String对象的value数组按照<font color="red">指定字符集编码成字符数组并返回</font><br>如果<font color="red">不指定字符集，按照默认字符集编码</font></p><h2 id="public-boolean-equals-Object-anObject"><a href="#public-boolean-equals-Object-anObject" class="headerlink" title="public boolean equals(Object anObject)"></a><font size="5">public boolean equals(Object anObject)</font></h2><p><img src="/2019/09/10/JDK源码-String类/14.png" alt>重写了Object的equals方法</p><h2 id="public-boolean-equalsIgnoreCase-String-anotherString"><a href="#public-boolean-equalsIgnoreCase-String-anotherString" class="headerlink" title="public boolean equalsIgnoreCase(String anotherString)"></a><font size="5">public boolean equalsIgnoreCase(String anotherString)</font></h2><p><img src="/2019/09/10/JDK源码-String类/15.png" alt>先判断地址是否相同，地址相同内容肯定相同，再判断长度是否相同，如果长度一样再调用regionMatches方法进行判断，这里用了&amp;&amp;运算符的<font color="red">断路原理</font><br>regionMatches方法有两种形式</p><ol><li>没有boolean参数的</li><li>有boolean参数的</li></ol><p>该方法的作用是区域比较，比较两个字符串指定长度的内容是否相等，从指定位置开始逐一比较字符数组内容是否相等<br><font color="red">两方法的区别</font>在于：如果booloean参数为true，那么当字符不相等时</p><ol><li>先将两字符转换成大写字符比较，还不相等</li><li>将两字符转换成小写比较，还不相等返回false</li></ol><p>和<font color="red">String的内部类实现原理一样</font></p><h2 id="public-int-compareTo-String-anotherString"><a href="#public-int-compareTo-String-anotherString" class="headerlink" title="public int compareTo(String anotherString)"></a><font size="5">public int compareTo(String anotherString)</font></h2><p><img src="/2019/09/10/JDK源码-String类/16.png" alt>这个方法是实现Comparable接口的方法，用于对字符串大小进行比较这个方法取了两个字符串长度较小的那个作为循环次数，对两个字符串进行逐位比较。</p><ol><li>如果不同，就返回两字符串不同那一位字符的差</li><li>如果都相同，就返回两字符串的长度差</li></ol><p>差的计算:<font color="blue">调用方法的字符串-参数字符串</font></p><h2 id="public-int-compareToIgnoreCase-String-str"><a href="#public-int-compareToIgnoreCase-String-str" class="headerlink" title="public int compareToIgnoreCase(String str)"></a><font size="5">public int compareToIgnoreCase(String str)</font></h2><p><img src="/2019/09/10/JDK源码-String类/18.png" alt>该方法实际上是调用了静态内部类对象的忽略大小写的compareTo方法</p><h2 id="public-boolean-startsWith-String-prefix-int-toffset"><a href="#public-boolean-startsWith-String-prefix-int-toffset" class="headerlink" title="public boolean startsWith(String prefix, int toffset)"></a><font size="5">public boolean startsWith(String prefix, int toffset)</font></h2><p><img src="/2019/09/10/JDK源码-String类/19.png" alt></p><h2 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a><font size="5">public int hashCode()</font></h2><p><img src="/2019/09/10/JDK源码-String类/20.png" alt>重写了Object的hashCode方法<br>在JAVA中，hashCode有两个作用：</p><ol><li>Object的hashCode返回对象的内存地址</li><li>重写的hashCode配合基于散列的集合使用<ul><li>在使用散列集合例如HashMap时，要保证key唯一，但是对于大量元素比较时直接比较equals效率低下，可以先判断hashCode，如果hashCode相等，然后判断equals，因为不同的对象其hashCode值可能相同，例如”通话”和”重地”、”Aa”和”BB”</li><li>为了使字符串计算的hashCode尽可能地少重复(降低哈希冲突)，这里采用的是31这个乘数，有两个好处<ul><li>31是个不大不小的质数，是作为hashCode乘子的优秀质数之一</li><li>31可以被JVM优化，31*i=(i&lt;&lt;5)-i(暂时没弄明白JVM优化)</li></ul></li></ul></li></ol><h2 id="public-int-indexOf-int-ch-int-fromIndex"><a href="#public-int-indexOf-int-ch-int-fromIndex" class="headerlink" title="public int indexOf(int ch, int fromIndex)"></a><font size="5">public int indexOf(int ch, int fromIndex)</font></h2><p><img src="/2019/09/10/JDK源码-String类/21.png" alt>作用：找到ch字符从字符串fromIndex位置开始第一次出现的位置<br>方法中的判断条件<font color="red">ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT</font>是什么意思呢？<br>我们知道，在JAVA中，一个<font color="blue">char类型字符占2个字节也就是16位</font></p><ol><li>当参数中的ch在这个范围内时，就在String中从fromIndex开始逐一查找ch第一次上出现的位置</li><li>当参数超过这个范围(即大于65535)时，调用indexOfSupplementary()方法进行比较</li></ol><p>通过查看Character源码可知<br><img src="/2019/09/10/JDK源码-String类/22.png" alt>这个数值就是65535</p><h2 id="public-int-indexOfSupplementary-int-ch-int-fromIndex"><a href="#public-int-indexOfSupplementary-int-ch-int-fromIndex" class="headerlink" title="public int indexOfSupplementary(int ch, int fromIndex)"></a><font size="5">public int indexOfSupplementary(int ch, int fromIndex)</font></h2><p><img src="/2019/09/10/JDK源码-String类/23.png" alt>这个方法是private修饰的，只能由String内部调用，用来处理当参数ch大于2个字节时的查找方法<br>不难发现，它将<font color="red">ch字符拆分成高低位来查找，高位和value[i]比较，低位和value[i+1]比较</font><br><b>lastIndexof逻辑和Indexof基本类似，不多说</b></p><h2 id="public-int-indexOf-String-str-int-fromIndex"><a href="#public-int-indexOf-String-str-int-fromIndex" class="headerlink" title="public int indexOf(String str, int fromIndex)"></a><font size="5">public int indexOf(String str, int fromIndex)</font></h2><p><img src="/2019/09/10/JDK源码-String类/24.png" alt>参数为字符串，实际上比较的时<font color="red">字符串里的char数组</font><br><img src="/2019/09/10/JDK源码-String类/25.png" alt>方法是保护的，<font color="red">只能在包内调用</font></p><ol><li><b>首先分析一下方法的参数：</b><ol><li>char[] source：调用方法的字符串内部数组–&gt;暂且称为<font color="blue">源数组</font></li><li>int sourceOffset：数组的起始位置(一般是0)</li><li>int sourceCount：数组的长度</li><li>char[] target：参数字符串的内部数组–&gt;暂且称为<font color="blue">目的数组</font></li><li>int targetOffset：数组的起始位置(一般是0)</li><li>int targetCount：数组的长度</li><li>int fromIndex：从源数组fromIndex位置开始向后查找</li></ol></li><li><b>前三个if条件判断</b><ol><li>当fromIndex &gt;= sourceCount(即指定的起始搜索位置大于源数组数组的长度)时<ul><li>判断目的数组是否为空串<ul><li>若为空，则返回源数组的长度</li><li>不为空，返回-1</li></ul></li></ul></li><li>当指定起始搜索位置小于0，默认从0开始搜索</li><li>当目的数组为空，并且fromIndex在正常范围内，返回fromIndex</li></ol></li><li>找源数组和目的数组第一个字符相同的位置记为i</li><li>逐一比较接来的字符是否相等，如果遍历完目的数组后仍相等，返回i，不相等进行5</li><li>从源数组第i个位置后找与目的数组第一个字符相等的位置，再比较接下来的每一个字符是否相等</li><li>一直循环查找直到找到i并返回，或源字符串遍历完毕返回-1<br><img src="/2019/09/10/JDK源码-String类/26.png" alt><font color="red">对于几种特殊情况的测试</font><h2 id="public-int-indexOf-String-str"><a href="#public-int-indexOf-String-str" class="headerlink" title="public int indexOf(String str)"></a><font size="5">public int indexOf(String str)</font></h2><img src="/2019/09/10/JDK源码-String类/27.png" alt>默认fromIndex=0，调用上面的indexOf方法</li></ol><h2 id="public-int-lastIndexOf-String-str-int-fromIndex"><a href="#public-int-lastIndexOf-String-str-int-fromIndex" class="headerlink" title="public int lastIndexOf(String str, int fromIndex)"></a><font size="5">public int lastIndexOf(String str, int fromIndex)</font></h2><p>逻辑和上面个一样，都是调用比较char数组的保护方法，需要时查看一下JDK8的源码</p><h2 id="public-String-substring-int-beginIndex"><a href="#public-String-substring-int-beginIndex" class="headerlink" title="public String substring(int beginIndex)"></a><font size="5">public String substring(int beginIndex)</font></h2><p><img src="/2019/09/10/JDK源码-String类/28.png" alt></p><ol><li>对beginIndex进行判断<ul><li>beginIndex&lt;0，抛出StringIndexOutOfBoundsException异常</li><li>大于源数组的长度，抛出StringIndexOutOfBoundsException异常</li><li><font color="red">begin=0，直接返回当前字符串</font></li></ul></li><li>调用<font color="red">String(char[] value,int beginIndex,int count(value.length-beginIndex))</font>来实现</li></ol><h2 id="public-String-substring-int-beginIndex-int-endIndex"><a href="#public-String-substring-int-beginIndex-int-endIndex" class="headerlink" title="public String substring(int beginIndex, int endIndex)"></a><font size="5">public String substring(int beginIndex, int endIndex)</font></h2><p><img src="/2019/09/10/JDK源码-String类/29.png" alt>逻辑和上面一样(<font color="blue">含头不含尾</font>)</p><h2 id="public-String-concat-String-str"><a href="#public-String-concat-String-str" class="headerlink" title="public String concat(String str)"></a><font size="5">public String concat(String str)</font></h2><p><img src="/2019/09/10/JDK源码-String类/30.png" alt>拼接字符串，将str拼接到this串后面</p><ol><li>如果参数串为空串，直接返回this(当前字符串)</li><li>调用Arrays.copyOf方法创建一个新的字符串buf，长度为this.length+str.length，内容为this.value</li><li>调用String类的getChars方法，将str复制到buf串中(从buf串的this.length位置开始)</li><li>调用String类的protected修饰的构造方法，直接将buf串的地址赋值给新创建的字符串对象–&gt;参考前面protected的构造方法</li></ol><p>大致上来说，该方法的实现原理：<br>先创建一个字符数组，复制了两个字符串中的内容，然后通过String(char value[] boolean share)方法来new一个新的字符串<br><font color="red"><b>因为buf串是在方法内部创建的，外部是不可见的，因此不会破坏String对象的不可变性</b></font></p><h2 id="public-String-replace-char-oldChar-char-newChar"><a href="#public-String-replace-char-oldChar-char-newChar" class="headerlink" title="public String replace(char oldChar, char newChar)"></a><font size="5">public String replace(char oldChar, char newChar)</font></h2><p><img src="/2019/09/10/JDK源码-String类/31.png" alt>将字符串中所有的oldChar替换为newChar</p><ol><li>如果OldChar==newChar，直接返回当前字符串</li><li>找到字符串中第一个OldChar，记录位置为i；</li><li>新建一个char数组buf，将字符串赋值给buf数组，从buf的i开始，将所有的OldChar替换为newChar</li><li>通过String(char value[] boolean share)来创建新的字符串对象并返回</li></ol><p><b>说一下为什么要重建一个val数组，用val数组给buf数组赋值，而不直接用value数组赋值呢？</b><br><img src="/2019/09/10/JDK源码-String类/32.png" alt><a href="https://blog.csdn.net/no_hardsoft/article/details/51725822" target="_blank" rel="noopener">上网查阅</a>，val数组是局部变量，value数组是类变量，getfield操作是一个<font color="blue">访问类变量的操作</font><br>当使用value数组循环赋值的时候，<font color="blue">每一次循环都会有一个getfield操作入栈</font><br>使用局部变量val时，<font color="blue">只有一次getfield操作操作，就是将value数组赋值给val的时候</font><br>当数组长度很大的时候，使用局部变量性能会更好一些(大神真不愧是大神，太细节了)</p><h2 id="public-boolean-contains-CharSequence-s"><a href="#public-boolean-contains-CharSequence-s" class="headerlink" title="public boolean contains(CharSequence s)"></a><font size="5">public boolean contains(CharSequence s)</font></h2><p><img src="/2019/09/10/JDK源码-String类/33.png" alt>判断字符串是否包含制定的字符序列，实际上是<font color="red">调用indexOf(String str)方法，查找序列在字符串中出现的位置来判断的</font>，如果不包含返回-1。</p><h2 id="public-String-toLowerCase-toUpperCase"><a href="#public-String-toLowerCase-toUpperCase" class="headerlink" title="public String toLowerCase()/toUpperCase()"></a><font size="5">public String toLowerCase()/toUpperCase()</font></h2><p><img src="/2019/09/10/JDK源码-String类/34.png" alt><br><img src="/2019/09/10/JDK源码-String类/35.png" alt>对字符串进行大小写转换，只对英文字符有效</p><h2 id="public-String-trim"><a href="#public-String-trim" class="headerlink" title="public String trim()"></a><font size="5">public String trim()</font></h2><p><img src="/2019/09/10/JDK源码-String类/36.png" alt>去掉两端空白字符(空格、tab、回车符)</p><ol><li>从左到右循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置st</li><li>从右往左循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置len</li><li>如果st=0并且len=value.length，说明该字符两端没有空字符，直接返回字符串</li><li>否则，调用substring(st, len)方法获取去掉首尾空字符的字串。</li></ol><p><font color="red">通过分析：一个首尾没有空字符的str调用trim方法，返回它本身，所以得到的新String对象地址相同<br>一个开头或结尾存在空字符的str调用trim方法，返回的新String对象是new出来的，两者地址不同</font></p><h2 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a><font size="5">public String toString()</font></h2><p><img src="/2019/09/10/JDK源码-String类/37.png" alt>返回他自身</p><h2 id="public-char-toCharArray"><a href="#public-char-toCharArray" class="headerlink" title="public char[] toCharArray()"></a><font size="5">public char[] toCharArray()</font></h2><p><img src="/2019/09/10/JDK源码-String类/38.png" alt>创建一个resault数组，调用System.arraycopy方法将value复制给resault数组并返回<br><font color="red">不能直接返回value数组，破坏了String的不可变性</font><br>源码中有一行注释：Cannot use Arrays.copyOf because of class initialization order issues，由于类初始化顺序问题，不能使用Arrays.copyOf方法<br>可能的原因：String初始化比Arrays早，但是在JDK中存在其他对象使用了toCharArray()方法，而<font color="blue">这个对象初始化比String晚但是比Arrays早，导致在使用时Arrays还没有初始化完成而报错</font><br>而Syatem.arraycopy不会有这样的问题，因为这是本地方法</p><h2 id="public-static-String-valueOf系列方法"><a href="#public-static-String-valueOf系列方法" class="headerlink" title="public static String valueOf系列方法"></a><font size="5">public static String valueOf系列方法</font></h2><p>直接查看JDK源码即可，很简单，就不赘述</p><h2 id="public-native-String-intern"><a href="#public-native-String-intern" class="headerlink" title="public native String intern();"></a><font size="5">public native String intern();</font></h2><p>本地方法，详细解释请见传送门，讲的挺好<br><a href="https://www.cnblogs.com/wxgblogs/p/5635099.html" target="_blank" rel="noopener">传送门1</a><br><a href="https://www.jianshu.com/p/9f51e4ccb33a" target="_blank" rel="noopener">传送门2</a></p><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p><img src="/2019/09/10/JDK源码-String类/17.png" alt>实际上就是String内部定义的一个比较器，用于忽略大小写比较字符串是否相等，<font color="red">CompareToIgnoreCase方法用到了这个类</font></p><hr><font size="5">到这里String类也大致总结完了，但是对于String类，我想要学的远不止这些，做这些只是整理方便后期学习理解，如果哪里不对或者有其他源码学习途径，欢迎私信我一起讨论交流，让我们一起学习，共同进步</font><br><hr><div align="center">暂时只能通过微博，后续会开微信公众号来一起交流，毕竟现在实力还不够</div>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> String类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础--SQL语句总结(二)</title>
      <link href="/2019/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%BA%8C/"/>
      <url>/2019/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>今天初步的做了一个web的小Demo，才发现数据库操作对于Web开发的重要性，频繁的对数据库进行操作，发现才学完数据库没多久，连基础的CRUD语句都写不出来，真是让人头大。<br>突然想起来之前的SQL语句还有一半没有总结，现在趁着手机没电不能继续做Demo，就花30分钟左右的时间来总结一下剩下的DQL语句和DCL语句吧</p><hr><a id="more"></a><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a><font size="5">语法</font></h2><ol><li>select *from +表名<br> select<pre><code>字段列表</code></pre> from<pre><code>表名列表</code></pre> where<pre><code>条件列表</code></pre> group by<pre><code>分组字段</code></pre> having<pre><code>分组之后的条件</code></pre> order by<pre><code>排序</code></pre> limit<pre><code>分页限定</code></pre><img src="/2019/09/09/数据库基础-SQL语句总结-二/1.png" alt></li></ol><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a><font size="5">基础查询</font></h2><p><font color="red">基于上面这个表进行演示</font></p><ol><li><p>多个字段的查询<br> <b>select 字段名1，字段名2… from 表名</b></p><ul><li>注意：<ul><li>如果查询所有字段，则可以使用*来替代字段列表。</li></ul></li></ul></li><li><p>去除重复：<br>如果要单独查地址栏：SELECT address FROM student; 就会发现有多个香港地址<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/2.png" alt><br>但是在这种情况下我们并一般不希望出现这种情况<br> <b>在select后面加<font color="red">distinct</font>关键字</b>就可以取出要查询的字段中重复的值<br>格式：<font color="red"><b>SELECT DISTINCT address(字段名) FROM 表名;</b></font></p></li><li><p>计算列</p><ul><li>可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</li><li>ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null<ul><li>表达式1：哪个字段需要判断是否为null</li><li>表达式2：如果该字段为null后的替换值。</li></ul></li></ul></li></ol><p>如图，计算英语成绩和数学成绩之和<br><font color="red">SELECT NAME,math,english,math+english FROM student;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/3.png" alt><br>因为英语这一列存在null值，所以就会导致数学和英语的和也为null，<font color="red">这显然是不合理的</font><br>使用<font color="red">ifnull</font>，如果字段为null，就会在相加的时候替换为0；<br>SELECT NAME,math,english,<font color="red">math+IFNULL(english,0)</font> FROM student;</p><ol start="4"><li>起别名：<ul><li>as：as也可以省略<br>上面再计算列的时候，最后的列的值发生了变化，变成了(math+english)，顾名思义，其别名就是将列名换一个自己的名字<br><font color="red">SELECT NAME,math,english,math+IFNULL(english,0)AS 总分 FROM student;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/4.png" alt></li></ul></li></ol><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><font size="5">条件查询</font></h2><ol><li>在<font color="red"><b>where子句后</b></font>面跟查询的条件</li><li>运算符<ul><li>&lt; 、&gt;、&lt;= 、&gt;= 、= 、&lt;&gt;(不等于，相当于！=)</li><li>BETWEEN…AND  </li><li>IN( 集合) </li><li>LIKE：模糊查询<ul><li>占位符：<ul><li>_:单个任意字符</li><li>%：多个任意字符</li></ul></li></ul></li><li>IS NULL  </li><li>and  或 &amp;&amp;</li><li>or  或 || </li><li>not  或 !</li></ul></li></ol><p><font color="blue"><b>实例演示</b></font></p><ol><li>查询年龄大于20岁的：<font color="red">SELECT *FROM student WHERE age&gt;20;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/5.png" alt></li><li>查询年龄在20~30岁之间的(三种方法)<br>SELECT *FROM student <font color="red">WHERE age BETWEEN 20 AND 30;<br>/age&gt;=20&amp;&amp;age&lt;=30;/age&gt;=20 AND age&lt;=30;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/6.png" alt></li><li>查询年龄22岁，18岁，25岁的信息(查询满足指定条件的数据)<br>SELECT *FROM student <font color="red">WHERE age IN(19,22,25);<br>age=22 OR age=19 OR age=25;/age=22 || age=19 || age=25;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/7.png" alt></li><li>查询英语成绩为null–&gt;不能用=和！=来判断是否为null，要<font color="red">用is和is not来判断</font><br>SELECT * FROM student WHERE english <font color="red">IS NULL;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/8.png" alt></li><li>查询姓马的有哪些 <font color="red">模糊查询–like</font><br>SELECT *FROM student WHERE NAME LIKE “马%”;<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/9.png" alt>因为用的%占位符，所以马后面不管有几个字符，都符合条件<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a><font size="5">排序查询</font></h2></li></ol><ul><li>语法：<b>order by 子句</b><ul><li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…</li></ul></li><li>排序方式：<ul><li>ASC：升序，默认的。</li><li>DESC：降序。</li></ul></li><li>注意：<ul><li>如果有多个排序条件，则当<font color="red">前边的条件值一样时，才会判断第二条件。</font></li></ul></li></ul><p><font color="blue"><b>实例演示</b></font></p><ol><li>按照数学成绩排名(默认升序排列)<br>SELECT *FROM student <font color="red">ORDER BY math;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/10.png" alt></li><li>按照数学习成绩升序排名，如果数学成绩一样，就按照英语成绩升序排名。<br>SELECT *FROM student <font color="red">ORDER BY math ASC,english ASC;</font><br><img src="/2019/09/09/数据库基础-SQL语句总结-二/11.png" alt><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a><font size="5">聚合函数</font></h2>将一列数据作为一个整体，进行纵向的计算。<ol><li>count：计算个数<ol><li>一般选择非空的列：主键</li><li>count(*)</li></ol></li><li>max：计算最大值</li><li>min：计算最小值</li><li>sum：计算和</li><li>avg：计算平均值</li></ol></li></ol><p><font color="blue"><b>实例演示</b></font></p><ol><li>某一列数据总行数(<font color="red">如果这一列有null值，那么为null的行不算</font>)<br>SELECT <font color="red">COUNT(english)</font> FROM student;<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/12.png" alt><br>这时候还要用到ifnull计算行数的时候将null临时替换为0，<br>SELECT <font color="red">COUNT(IFNULL(english,0))</font> FROM student;<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/13.png" alt>使用SELECT COUNT(*)  FROM student;来计算行数，只要这一组数据中有一列数据全不为null，就能够正确的计算行数</li><li>计算数学成绩最大值(max)<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/14.png" alt><font color="blue">其余的min、sum以及avg用法和max一样</font><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a><font size="5">分组查询</font></h2><ol><li>语法：group by 分组字段；</li><li>注意：<ol><li>分组之后查询的字段：分组字段、聚合函数</li><li>where 和 having 的区别？<ol><li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li></ol></li></ol></li></ol></li></ol><p><font color="blue"><b>实例演示</b></font></p><ol><li>按照性别分组。分别查询男、女同学的数学平均分,人数<br>SELECT sex , AVG(math)(平均分),COUNT(id)(人数) FROM student GROUP BY sex(性别分组);<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/15.png" alt></li><li>按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组<br>SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;<br><img src="/2019/09/09/数据库基础-SQL语句总结-二/16.png" alt></li><li>按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人<br>SELECT sex,AVG(math) ,COUNT(id) FROM student WHERE math&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2 ;</li></ol><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><font size="5">分页查询</font></h2><pre><code>1. 语法：limit 开始的索引,每页查询的条数;2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数    -- 每页显示3条记录     SELECT * FROM student LIMIT 0,3; -- 第1页    SELECT * FROM student LIMIT 3,3; -- 第2页    SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL&quot;方言&quot;</code></pre><hr><font size="5"><b>通过上面的实例演示，结合DQL查询语句的语法不难发现，如果一次有多个查询条件，那么写的顺序一次是Where、Group By、Having、Order By、Limit的顺序</b></font><br>可以这么来理解：<br><b>where先对数据进行筛选，不满足条件的不进行后面的分组，<font color="blue">这是第一次条件</font><br>Having再对分完组后的数据进行筛选，不满足条件的数据不会被查询到，<font color="blue">这是第二次条件</font><br>前面的都完成后，Order By再对查询到的数据进行排序，<font color="blue">这是第三次条件</font><br>Limit再对排序后的数据进行分页展示，<font color="blue">这是第四次条件</font></b><hr><p>发现数据库这方面的知识要掌握的东西太多，多练习才能掌握，死记硬背是很难的，本来以为30分钟，最后俩小时还没搞定，后面大约还有整个基础部分的一半吧，下次再说吧</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术--Cookie&amp;Session</title>
      <link href="/2019/09/08/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie-Session/"/>
      <url>/2019/09/08/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie-Session/</url>
      
        <content type="html"><![CDATA[<p><b>会话：一次会话中包含多次请求和响应。<br>在一次会话中，浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止<br>会话技术能够在一次会话的多次请求响应间共享数据</b></p><hr><a id="more"></a><h1 id="会话技术的实现方式"><a href="#会话技术的实现方式" class="headerlink" title="会话技术的实现方式"></a>会话技术的实现方式</h1><ul><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ul><h1 id="客户端会话技术–Cookie"><a href="#客户端会话技术–Cookie" class="headerlink" title="客户端会话技术–Cookie"></a>客户端会话技术–Cookie</h1><h2 id="Cookie使用步骤"><a href="#Cookie使用步骤" class="headerlink" title="Cookie使用步骤"></a><font size="5">Cookie使用步骤</font></h2><ol><li> 创建Cookie对象，绑定数据:<font color="blue">new Cookie(String name, String value)</font></li><li>发送Cookie对象::<font color="blue">response.addCookie(Cookie cookie)</font></li><li> 获取Cookie，拿到数据:<font color="blue">Cookie[]  request.getCookies()</font></li></ol><h2 id="Cookie实现原理"><a href="#Cookie实现原理" class="headerlink" title="Cookie实现原理"></a><font size="5">Cookie实现原理</font></h2><p><font color="red">基于响应头set-cookie和请求头cookie实现</font><br></p><ol><li>客户端和服务器第一次请求响应：服务器创建Cookie对象，并在set-cookie响应头将Cookie响应给浏览器</li><li>浏览器接收到服务器带有set-cookie头的响应后，将Cookie存储在浏览器中，当下一次浏览器向服务器发送请求时，会在请求头cookie头中附带这cookie</li><li>这样就实现了多次请求响应之间的数据共享</li></ol><hr><h2 id="Cookie的细节"><a href="#Cookie的细节" class="headerlink" title="Cookie的细节"></a><font size="5">Cookie的细节</font></h2><ul><li><font color="red">一次可以发送多个cookie：</font>在服务器端创建多个Cookie对象，多次调用response的addCookie方法将多个Cookie对象发送，但是如果两个Cookie的值相同，那么后加入的Cookie值会覆盖前面的值</li><li><font color="red">cookie在浏览器中保存时间</font><ul><li>默认情况下，当浏览器关闭后，Cookie数据被销毁(服务器关闭，Cookie仍然存在，因为Cookie存储在浏览器中)</li><li>持久化存储：调用Cookie对象的<font color="blue">setMaxAge(int seconds)</font>方法实现<ul>参数取值情况：<li><font color="red">正数</font>：将Cookie数据写到硬盘的文件中。<font color="red">持久化存储</font>。并指定cookie存活时间，时间到后，cookie文件自动失效</li><li>负数：默认值，即浏览器关闭后Cookie被销毁</li><li><font color="red">零：删除cookie信息</font></li></ul></li></ul></li><li><font color="red">cookie存储中文问题</font>:在tomcat 8 之前 cookie中不能直接存储中文数据。但是在tomcat8之后，支持直接存储中文，但是对于一些特殊字符(如空格等)，仍不能直接存储，需要借助URL编码才行(具体步骤下一篇文章说到)</li><li>cookie的共享<ul><li><font color="red">在一个tomcat服务器中部署了多个项目，在默认情况下，这些项目之间的Cookie是不能共享</font>的<br>但是可以通过Cookie对象的setPath(String path)方法来设置Cookie的共享范围<ul><li>默认情况下，设置的是当前项目的虚拟目录</li><li> 如果要在多个项目之间共享，则可以将path设置为"/"(“/”为服务器路径)</li></ul></li><li>不同服务器之间Cookie的共享<ul><li>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</li><li>例如：设置path为".baidu.com"，那么tieba.baidu.com和news.baidu.com两个不同的服务器之间可以共享数据，因为它们的一级域名是.baidu.com</li></ul></li></ul></li></ul><hr><h2 id="Cookie的特点和作用"><a href="#Cookie的特点和作用" class="headerlink" title="Cookie的特点和作用"></a><font size="5">Cookie的特点和作用</font></h2> <ul> <li>特点 <ul> <li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</li><li><font color="red">Cookie存储的键值对都是String类型</font></li> </ul></li><li>作用<ul><li>cookie一般用于存出少量的不太敏感的数据，这是因为Cookie的存储位置决定的，存储在客户端容易丢失和被篡改。</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ul></li></ul><hr><h1 id="服务器端会话技术–Session"><a href="#服务器端会话技术–Session" class="headerlink" title="服务器端会话技术–Session"></a>服务器端会话技术–Session</h1><h2 id="Session使用步骤"><a href="#Session使用步骤" class="headerlink" title="Session使用步骤"></a><font size="5">Session使用步骤</font></h2><ol><li> 通过resquest获取Session对象：<font color="blue">request.getSession()</font></li><li>调用Session对象的方法存储数据(和request请求转发方法一样)<ul><li><font color="blue">Object getAttribute(String name)</font>：通过键获取值</li><li><font color="blue">void setAttribute(String name, Object value)</font>：将数据存储进Session对象</li><li><font color="blue">void removeAttribute(String name)</font>：通过键移除相应的键值对</li></ul></li></ol><h2 id="Session实现原理"><a href="#Session实现原理" class="headerlink" title="Session实现原理"></a><font size="5">Session实现原理</font></h2><ol><font color="red">Session的实现是依赖于Cookie的。</font><li>客户端第一次向服务器发送请求，服务器在服务器内部开辟一块内存空间，存放Session对象，并给该内存空间指定一个id</li><li>服务器在响应头set-cookie中设置JSESSIONID=id这个键值对发送给客户端</li><li>客户端接收到服务器的相应后，会将保存着Sessionid的Cookie对象保存在浏览器内存</li><li>当客户端下一次向服务器发送请求的时候，会带着Cookie一起(在请求头cookie中有JSESSIONID=id键值对)</li><li>服务器接收到请求后，得到JSESSIONID=id键值对的id后，会在内存中找到对应id的Session对象</li><li>这就是为什么说Session依赖于Cookie的原因以及多次请求响应之间共享数据的原理</li></ol><hr><h2 id="Session细节"><a href="#Session细节" class="headerlink" title="Session细节"></a><font size="5">Session细节</font></h2><ul><li><font color="red">当客户端关闭后，服务器不关闭，两次获取session不是同一个</font>：前面说到过，Session是依赖于Cookie的，Cookie在默认情况下当客户端浏览器关闭后是自动销毁的，因此Cookie中的键值对自然也就销毁了，所以两次获取的Session不是同一个，如果需要两次的Cookie是同一个<ul><li>创建一个Cookie对象，设置cookie的键为JSESSIONID，值为session对象的id</li><li>设置cookie的存活时间</li><li>那么在cookie存活时间内，服务器通过cookie请求头拿到session的id都是一样的，这样通过id找到的Session对象自然也是同一个</li></ul></li><li><font color="red">客户端不关闭，服务器关闭后，两次获取的session不是同一个</font>，因为服务器关闭后相应内存会被释放，Session自然也会被释放<br>但是一般我们需要获取到的Session对象是同一个，确保数据不丢失，<font color="red">tomcat会自动完成Session的钝化和活化</font><ul><li>Session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上</li><li>Session的活化：在服务器启动后，将session文件转化为内存中的session对象。</li></ul></li><li>Session被销毁<ul><li> 服务器关闭</li><li>session对象调用invalidate() 自杀</li><li>session默认失效时间 30分钟,可以tomcat服务器的web.xml配置文件中session-config设置所有项目的失效时间,也可以在项目的wen.xml配置文件单独配置项目的失效时间</li></ul></li></ul><hr><h2 id="Session的特点"><a href="#Session的特点" class="headerlink" title="Session的特点"></a><font size="5">Session的特点</font></h2><ul><li>用于一次会话的多次请求间共享数据，存储在服务器端</li><li><font color="red">session可以存储任意类型，任意大小的数据</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会话技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器中的四种路径</title>
      <link href="/2019/09/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/09/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>在Web开发中，会很频繁的用到各种路径，路径又大致分为四种，分别是相对路径、绝对路径、虚拟路径、资源路径</p><hr><a id="more"></a># 相对路径<font color="red" size="4"><b>通过相对路径不能确定唯一资源</b></font><br>例如：./index.html<br>## <font size="5">相对路径的使用规则</font>以<font color="red" size="4"><i>"./"开头</i></font>,<br>在使用时先确定<font color="red"><b>当前资源和目标资源的之间的相对位置关系</b></font><br>如果两资源位于<font color="blue">同一级目录</font>：./+目标资源名称<br>./可以不加，默认有./<br>如果目标资源<font color="blue">位于上一级目录</font>：../+目标资源名称<hr><h2 id="如何确定当前资源和目标资源的关系"><a href="#如何确定当前资源和目标资源的关系" class="headerlink" title="如何确定当前资源和目标资源的关系"></a><font size="5">如何确定当前资源和目标资源的关系</font></h2><ol><li>对于<font color="blue">src目录下的资源</font>，可以用<font color="red">request.getRequestURL()</font>来得到该资源的位置<br>src下的java资源的URI都是<font color="red">虚拟路径+资源名称</font>无论该java文件位于src下的哪一级目录，只要在src目录里，都是这个形式。<br><b><i>这里说的资源名称并不是实际的java类名，而是@WebServlet中的资源名称，服务器通过这个资源名称找到实际的类。</i></b></li><li>对于<font color="blue">web目录下的资源</font>，如果直接在web目录下，那么资源的URI就是<font color="red">虚拟路径+/文件名称</font><br>如果在web目录下的其他目录，那么资源的URI就是<font color="red">虚拟路径+/目录名称+/文件名称</font>，有几级目录写几级目录。<hr></li></ol><h1 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h1><p><font color="red" size="4"><b>通过绝对路径确定唯一资源</b></font><br><br>例如：<a href="http://localhost/response/responseDemo2或者/response/responseDemo2" target="_blank" rel="noopener">http://localhost/response/responseDemo2或者/response/responseDemo2</a><br><br><font color="red">协议名+ip地址+端口号+虚拟路径+文件资源</font></p><hr><h1 id="两种路径使用规则"><a href="#两种路径使用规则" class="headerlink" title="两种路径使用规则"></a>两种路径使用规则</h1><p><font color="red"><b>规则：判断要定义的路径是给谁用的，即判断请求将来从哪发出</b></font><br></p><ol><li>给客户端浏览器使用<br> 需要加虚拟目录(项目的访问路径,查看项目的xml配置文件)<br> 例如：&lt;\a&gt;标签，&lt;\form&gt;，重定向等从浏览器发出，需要加虚拟路径</li><li>给服务器使用<br>不需要加虚拟目录<br>例如：请求转发就是服务器内部的资源跳转，不需要加虚拟路径，直接写资源名称就可以了</li></ol><hr><h1 id="虚拟路径"><a href="#虚拟路径" class="headerlink" title="虚拟路径"></a>虚拟路径</h1><p>虚拟路径代表的是项目实际部署的位置，服务器通过虚拟路径能够映射到项目实际部署的位置<br>通过查看<b>项目</b>的xml文件可以发现:<br><font color="red">&lt;\Context path=”虚拟路径” docBase=”资源在电脑上存储的位置” /&gt;</font><br>这就是配置文件的内容，我们在浏览器输入的是Contextpath，也就是项目的虚拟路径，服务器就通过该虚拟目录映射到后面项目部署的真实目录</p><h2 id="虚拟路径的好处"><a href="#虚拟路径的好处" class="headerlink" title="虚拟路径的好处"></a><font size="5">虚拟路径的好处</font></h2><ul><li>虚拟目录的名称通常要比物理目录的名称易记，因此更便于用户访问。</li><li> 使用虚拟目录可以提高安全性，因为客户端并不知道文件在服务器上的实际物理位置，所以无法使用该信息来修改服务器中的目标文件。</li><li>使用虚拟目录可以更方便地移动网站中的目录，只需更改虚拟目录物理位置之间的映射，无需更改目录的URL。</li><li>使用虚拟目录可以发布多个目录下的内容，并可以单独控制每个虚拟目录的访问权限。 使用虚拟目录可以均衡Web服务器的负载，因为网站中资源来自于多个不同的服务器，从而避免单一服务器负载过重，响应缓慢。</li></ul><hr><h1 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h1><p>资源路径也不是文件的真实路径，它和真是路径之间存在着映射关系，服务器可以通过资源路径找到文件<br><a href="https://blog.csdn.net/weixin_42387411/article/details/100191979" target="_blank" rel="noopener">link</a><br>这篇文章提到了配置Servlet的方法，一种是通过web.xml来配置，通过这种方法很容易理解资源路径和文件路径的映射关系，服务器通过资源路径映射到实际文件，通过@WebServlet配置原理一样</p><hr><p><b><i>我们在浏览器输入的是项目的URL是由协议名+ip地址+端口号+虚拟路径+文件资源组成，</i></b><br><b><i>服务器会通过虚拟路径找到项目在电脑上部署的位置，通过文件资源路径找到文件在电脑上的实际位置</i></b></p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ServletContext对象</title>
      <link href="/2019/09/08/ServletContext%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/09/08/ServletContext%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><b>ServletContext对象，代表了整个web应用，可以和程序的容器(服务器)来通信</b></p><h1 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h1><ul><li>通过request对象获取:<font color="blue">request.getServletContext()</font></li><li>通过HttpServlet获取:<font color="blue">this.getServletContext();</font></li></ul><a id="more"></a><h1 id="ServletContext对象的功能"><a href="#ServletContext对象的功能" class="headerlink" title="ServletContext对象的功能"></a>ServletContext对象的功能</h1><ul><li> 获取MIME类型(文后将什么是MIME类型):<font color="blue">String getMimeType(String file)</font><br>获取到数据的类型后，可以<font color="red">用于设置响应头content-type</font>的值<br>获取方法：<font color="blue">String getMimeType(String file)；</font></li><li>域对象：共享数据，前面说到，ServletContext代表了整个web应用，<font color="red">因此ServletContext对象中存放的数据整个web应用的资源都可以访问和修改</font><br>方法<font color="blue">和request域对象的三个方法一样，只是两者的作用范围不同</font></li><li><i>动态的获取文件的真实(服务器)路径</i><ul><font color="red" size="4"><b><i>方法：String getRealPath(String path)</i><li>文件直接位于web目录下时：<font color="blue">context.getRealPath("/+文件名称");</font></li><li>文件位于web目录下下的目录a中时：<font color="blue">context.getRealPath("/a/+文件名称");</font></li><li>文件直接位于src目录下时：<font color="blue">context.getRealPath("/WEB-INF/classes+文件名称");</font></li></b></font></ul>以上可以通过查看tomcat项目的层次结构，以<font color="red" size="5"><i>tomcat项目的web目录为基准</i></font></li></ul><hr><font size="5" color="red"><b><i>tomcat项目目录位于IDEA工作空间目录的\out\artifacts下</i></b></font><hr><h1 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h1><p><font color="red" size="4"><i>MIME类型:在互联网通信过程中定义的一种文件数据类型</i></font><br><br>MIME类型的格式：<font color="red">大类型/小类型</font>&nbsp;&nbsp;&nbsp;&nbsp;例如：text/html、image/jpg<br></p><h2 id="getMimeType方法获取MIME类型的原理"><a href="#getMimeType方法获取MIME类型的原理" class="headerlink" title="getMimeType方法获取MIME类型的原理"></a><font size="5">getMimeType方法获取MIME类型的原理</font></h2><p>在web.xml配置文件中，tomcat定义了上千种MIME类型和文件后缀名的对应关系，而ServletContext又可以和服务器通信，所以ServletContext的getMimeType实际上是通过文件的后缀名来映射获取的文件的MIME类型。</p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求转发和重定向</title>
      <link href="/2019/09/08/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2019/09/08/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>目前已经学习了两种资源跳转的方式：分别是request对象的请求转发和response的重定向，那么这两者各自有什么特点以及它们之间的区别是什么呢？</p><hr><a id="more"></a><h1 id="request请求转发"><a href="#request请求转发" class="headerlink" title="request请求转发"></a>request请求转发</h1><p><b>一种在服务器内部的资源跳转方式</b><br>举个例子：浏览器向服务器发出请求，服务器中的AServlet收到了请求，但是AServlet无法单独完成这个请求，如果要完成这个请求，还需要服务器内BServlet的参与，这时候就会用到请求转发，AServlet执行完自己能执行的部分后跳转到BServlet中继续执行，(这中间还涉及到了共享数据，文章后面会将)</p><h2 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a><font size="5">请求转发的特点</font></h2><ul><li><font color="red">浏览器地址栏路径不发生变化</font>：就是说，浏览器请求访问AServlet，Aservlet执行完自己能执行的部分后跳转到BServlet，在这个过程中浏览器地址栏的路径还是AServlet的路径，并不会发生改变</li><li>只能转发到当前<font color="red">服务器内部资源</font>中。</li><li>转发是<font color="red">一次请求</font>：从上面的例子可以看出，整个转发的过程中，<font color="red">无论在服务器内部资源跳转多少次，浏览器只发出过一次请求</font>，而服务请经过多次跳转处理完浏览器的请求后只会做出一次响应</li></ul><hr><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a><font size="5">共享数据</font></h2><p>上面说到了，AServlet和BServlet一起完成浏览器的请求，那么<font color="blue">这两者之间必定是有数据交互</font>的，因为AServlet要告诉BServlet自己做了哪些部分(修改了那些数据..)，并将这些部分共享给BServlet<br><br><i><font color="red" size="4">说共享数据之前，先说一个概念</font></i><br><font color="red">域对象：</font>一个有作用范围的对象，可以在范围内共享数据<br><font color="red">request域：</font>代表一次请求的范围，即在一个请求的范围内各个服务器资源可以共享数据。因为上面说到了请求转发这个过程是一次请求响应的过程，所以<font color="blue">请求转发过程中的多个资源可以共享数据</font><br></p><ol><li>存储数据，在当前资源中调用此方法(<font color="red">转发之前调用</font>)<font color="blue">void setAttribute(String name, Object o)</font><br><font color="red">参数：</font><br>String name：给数据起一个名，在后面取出数据用到<br>Object o：要共享的数据</li><li>在跳转后的资源调用此方法，可以达到共享数据的目的：<font color="blue">Object getAttribute(String name)</font><br><font color="red">参数：</font><br>String name：存储数据时起的名</li></ol>还有一个相关的方法：通过键来移除键值对<font color="blue">void removeAttribute(String name)</font><hr><h1 id="response重定向"><a href="#response重定向" class="headerlink" title="response重定向"></a>response重定向</h1><p><b>一种资源跳转的方式，不限于服务器内部，可以跳转到其他服务器资源(如跳转到百度)</b></p><h2 id="重定向实现步骤"><a href="#重定向实现步骤" class="headerlink" title="重定向实现步骤"></a><font size="5">重定向实现步骤</font></h2><ol><li>设置状态码为302(代表重定向)</li><li>设置响应头<font color="blue">location：</font>response.setHeader("location","目的资源的路径");</li></ol>以上是分步实现，其实一个方法就能够完成上述步骤调用response的sendRedirect方法，方法中传递跳转资源的路径<font color="red">response.sendRedirect("https://www.baidu.com");</font><hr><h2 id="重定向的原理"><a href="#重定向的原理" class="headerlink" title="重定向的原理"></a><font size="5">重定向的原理</font></h2><ol><li>浏览器向服务器发出请求，AServlet接收到了这个请求,AServlet表示无法处理服务器的这个请求，但AServlet却知道BServlet(可以是服务器内部的资源也可以是其他服务器的资源)</li><li>所以AServlet在在响应消息中干了两件事情<ol><li>设置状态码为302，告诉服务器重定向</li><li>告诉浏览器BServlet的路径，(设置响应头location为BServlet的路径)</li></ol></li><li>浏览器收到了AServlet的响应消息后，根据AServlet给出的location路径去访问BServlet</li></ol><hr><h2 id="重定向的特点"><a href="#重定向的特点" class="headerlink" title="重定向的特点"></a><font size="5">重定向的特点</font></h2><ul><li>地址栏发生变化：在资源跳转的过程中，浏览器地址栏会发生变化</li><li>重定向<font color="blue">可以访问其他站点(服务器)的资源</font></li><li>重定向是<font color="blue">两次请求</font>。不能使用request对象来共享数据</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>response输出中文乱码</title>
      <link href="/2019/09/08/response%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2019/09/08/response%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><b>使用response对象设置响应体时有两个步骤：<b></b></b></p><ol><li>获取输出流(字节流或字符流)</li><li>使用输出流，将数据输出到客户端浏览器<br>这时候如果传输的数据是中文，输出到浏览器就会<font color="red">乱码</font><hr><a id="more"></a></li></ol><h1 id="乱码原因"><a href="#乱码原因" class="headerlink" title="乱码原因"></a>乱码原因</h1><p>首先，要知道乱码的根本原因是什么，乱码的根本原因在于<font color="red">编码和解码使用的字符集不一样</font>。那么在从服务器输出数据到客户端的过程中，有几次编码和解码过程？又分别是在哪里执行的？<br><br>在输出数据的过程中，有<font color="blue">一次编码</font>，是<font color="red"><i>tomcat执行</i></font>的，它按照自己的字符集将数据编码后发送给客户端浏览器<br>有<font color="blue">一次解码</font>，是<font color="red"><i>浏览器执行</i></font>的，浏览器将接收的数据按照自己的字符集解码后打印在屏幕上。<br>而<font size="4" color="red"><i>tomcat的默认编码是ISO-8859-1</i></font>，<font size="4" color="red"><i>浏览器的默认编码是操作系统的编码，也就是GBK</i></font>，两者的编码格式不一样，就造成了中文乱码问题<br></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>解决方案不止一种，记录一种比较简单地<br><br>使用response设置响应头的方法来设置<font color="blue"> Content-Type</font></p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p>在获取输出流<font color="red">之前</font>(一定是之前)<br>设置响应头content-type<font color="blue">response.setHeader(“content-type”,”text/html;charset=utf-8”);</font><br>这个方法<font size="4" color="red"><i>不仅可以设置流的编码，还可以告诉浏览器发送数据的编码方式，并建议浏览器使用同样的字符集解码，这样就解决了乱码的问题</i></font><br><br>由于只需要设置content-type这个响应头，所以有另一个方法更为简单<br><font color="blue">response.setContentType(“text/html;charset=utf-8”);</font></p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http协议概述--request和response对象</title>
      <link href="/2019/09/08/Http%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/09/08/Http%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><b>首先要知道request对象和response对象是<font color="red">由服务器创建</font>的，我们只是使用并不创建<br>request对象是来<font color="blue">获取请求消息</font>，<br>response对象是来<font color="blue">设置响应消息</font></b><hr></p><a id="more"></a><h1 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h1><h2 id="request继承结构"><a href="#request继承结构" class="headerlink" title="request继承结构"></a><font size="5">request继承结构</font></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">ServletRequest(接口)–&gt;HttpServletRequest(接口)–&gt;RequestFacade 类(tomcat实现)</font></p><hr><h2 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a><font size="5">request功能</font></h2><h3 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a><font size="5">获取请求消息数据</font></h3><ul><ul><li><font face="宋体"><b>获取请求行数据:</b></font><br>这是一个GET请求方式的请求行：<font color="red">GET /day14/demo1?name=zhangsan HTTP/1.1</font><ul><li>获取请求方式 ：<font color="blue">String getMethod() </font>-->上例得到结果：GET</li><li>获取虚拟目录<font color="red">(常用)</font>：<font color="blue">String getContextPath() </font>-->上例得到结果：/day14</li><li> 获取Servlet路径: <font color="blue">String getServletPath()</font>-->上例得到结果：/demo1</li><li>获取get方式请求参数：<font color="blue">String getQueryString()</font>-->上例得到结果：name=zhangsan</li><li>获取请求URI<font color="red">(常用)</font>(有两个方法)<ul><li><font color="blue">String getRequestURI()</font>-->上例得到结果：/day14/demo1</li><li><font color="blue">StringBuffer getRequestURL()</font><br>上例得到结果 :http://localhost/day14/demo1</li></ul></li><li>获取协议及版本：<font color="blue">String getProtocol()</font>-->上例得到结果：HTTP/1.1</li><li>获取客户机的IP地址：<font color="blue">String getRemoteAddr()</font></li></ul></li><br><li><font face="宋体"><b>获取请求头数据:</b></font><ul><li>通过请求头的名称获取请求头的值<font color="red">(常用)</font>:<font color="blue">String getHeader(String name)</font></li><li>获取所有的请求头名称:<font color="blue">Enumeration<string> getHeaderNames()</string></font></li></ul></li><br><li><font face="宋体"><b>获取请求体数据:</b></font><br><font color="red">只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</font><ul><li> 获取流对象<ul><li>获取字符输入流，只能操作字符数据:<font color="blue">BufferedReader getReader()</font></li><li>获取字节输入流，可以操作所有类型数据:<font color="blue">ServletInputStream getInputStream()</font></li></ul></li></ul></li></ul><hr><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a><font color="red" size="5">其他功能</font></h3><ul>因为对于不同的请求方式，它们的请求参数所在位置不同，GET方式请求参数在请求行中，POST方式请求参数封装在请求体中，所以服务器在获取请求参数的时候，需要分别在doGet和doPost方法中写不同的逻辑代码来获取请求参数，比较麻烦，因此就有一种通用的获取请求参数的方法<li><font face="宋体"><b>获取请求参数通用方式</b></font><ul><li>根据参数名称获取参数值:<font color="blue">String getParameter(String name)</font></li><li>根据参数名称获取参数值的数组<font color="red">(多选框)</font>:<font color="blue">String[] getParameterValues(String name)</font></li><li>获取所有请求的参数名称:<font color="blue">Enumeration<string> getParameterNames()</string></font></li><li>获取所有参数的map集合:<font color="blue">Map'<'string,string[]> getParameterMap()</'string,string[]></font></li></ul><br></li><li><font face="宋体"><b>请求转发:一种在<font color="red">服务器内部</font>的资源跳转方式</b></font><ol><li>通过request对象获取请求转发器对象:<font color="blue">RequestDispatcher getRequestDispatcher(String path)</font></li><li>使用RequestDispatcher对象来进行转发:<font color="blue">forward(ServletRequest re, ServletResponse res)</font></li><font color="red">注意:</font>path是要跳转的资源的路径，</ol></li><li>获取ServletContext(后面博客会详细讲到): <font color="blue">ServletContext getServletContext()</font></li></ul></ul><br><hr><font color="red" face="宋体" size="5"><i>request的请求转发和资源共享以及response的重定向，它们各自的特点和区别会新开一篇博客</i></font><hr><h1 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象<br></h1><p>response功能:<font color="red">设置响应消息</font></p><ul><li><font face="宋体"><b>设置响应行(设置状态码):</b></font><font color="blue">setStatus(int sc)</font></li><li><font face="宋体"><b>设置响应头:</b></font><font color="blue">setHeader(String name, String value) </font></li><li><font face="宋体"><b>设置响应体:</b></font><ol>使用步骤<li>获取输出流<ul><li>字符输出流:<font color="blue">PrintWriter getWriter() </font></li><li>字节输出流:<font color="blue">ServletOutputStream getOutputStream()</font></li></ul></li><li>使用输出流，将数据输出到客户端浏览器<br></li></ol></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http协议概述--请求响应模型</title>
      <link href="/2019/09/08/Http%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/09/08/Http%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><b>Http–Hyper Text Transfer Protocol 超文本传输协议<b><br><font color="red"><b>传输协议</b></font>：定义了客户端和服务器端通信时，发送数据的格式</b></b></p><hr><a id="more"></a># Http协议的特点<ul><li>基于TCP/IP的高级协议,<font color="blue">默认端口是80</font></li><li>基于请求/响应模型的:<font color="blue">一次请求对应一次响应</font></li><li>无状态的：每次请求之间<font color="blue">相互独立，不能交互数据</font></li></ul><h1 id="Http协议的历史版本"><a href="#Http协议的历史版本" class="headerlink" title="Http协议的历史版本"></a>Http协议的历史版本</h1><ul><li><input disabled type="checkbox"> 1.0版本<br>每次请求响应之后都会断开连接，下一次请求响应又会建立新的连接，即<font color="blue">每次请求响应都会建立新的连接</font><br>缺点：连接会被多次建立和多次丢弃掉，影响传输速度，消耗资源<br></li><li><input disabled type="checkbox"> 1.1版本<br>在一次请求响应之后，连接不会立刻断开，而是会等待一定的时间，如果在这一定时间内，还有其他请求，就会默认使用该连接，而不去建立新的连接，这样就实现了<font color="red"><b>连接的复用</b></font><hr>上面说了，Http定义了客户端和服务器通信时传输数据的格式，而传输数据分为两种：<br><b>客户端向服务器传输数据：</b><font color="red">请求消息数据</font><br><b>服务器向客户端传输数据：</b><font color="red">相应消息数据</font></li></ul><h1 id="Http请求消息数据格式"><a href="#Http请求消息数据格式" class="headerlink" title="Http请求消息数据格式"></a>Http请求消息数据格式</h1> <ul><li><font face="宋体"><b>请求行:</b></font><font color="blue">请求方式 请求url 请求协议/版本</font><br>例如：GET /login.html    HTTP/1.1<br><font color="red">请求url=虚拟路径+Servlet资源路径</font></li><li><font face="宋体"><b>请求头：</b></font>客户端浏览器告诉服务器一些信息<br>请求头消息以键值对的方式给出：<font color="blue">请求头名称：请求头值</font><br>常见的请求头：<ul><li>User-Agent：浏览器告诉服务器，使用的<font color="red">浏览器版本信息</font>,可以在服务器端获取该头的信息，<font color="red">解决浏览器的兼容性问题(可以在服务器端对不同的服务器写不同的逻辑代码，然后根据该头的内容获取浏览器名称，执行对应浏览器的代码)</font></li><li>Referer：告诉服务器，当前请求从哪里来？可以用来<font color="red">防盗链和统计工作</font></li></ul></li><li><font face="宋体"><b>请求空行：</b></font>一个空行，用于分割请求头和请求体</li><li><font face="宋体"><b>请求体(正文)：</b></font>封装<font color="red">POST</font>请求消息的请求参数</li></ul><hr>对于请求行中的请求方式，http协议7中请求方式，常用的有2种<ul><li>GET:<br><font color="red">请求参数在请求行</font>中，跟在url后。<br>请求的url长度有限制的<br>不太安全</li><li>POST:<br><font color="red">请求参数在请求体</font>中<br>请求的url长度没有限制的<br>相对安全</li></ul><hr><h1 id="Http响应消息数据格式"><a href="#Http响应消息数据格式" class="headerlink" title="Http响应消息数据格式"></a>Http响应消息数据格式</h1>  <ul><li><font face="宋体"><b>响应行:</b></font><font color="blue">协议/版本 响应状态码 状态码描述</font><br>例如：HTTP/1.1 200 OK<br><font color="red">请求url=虚拟路径+Servlet资源路径</font></li><li><font face="宋体"><b>响应头：</b></font>服务器告诉浏览器一些信息<br>响应头消息以键值对的方式给出：<font color="blue">响应头名称：响应头值</font><br>常见的响应头：<ul><li>Content-Type：服务器告诉客户端本次<font color="red">响应体数据格式以及编码格式</font></li><li>Content-disposition：服务器告诉客户端<font color="red">以什么格式打开响应体数据</font><br><ul>常见有两种取值<li>in-line:默认值,在<font color="blue">当前页面内打开</font></li><li>attachment;filename=xxx：以<font color="blue">附件形式打开响应体，用于文件下载</font><br>注意：这个filename是浏览器在弹出框显示，和服务器中要下载的文件名无关</li></ul></li></ul></li><li><font face="宋体"><b>响应空行：</b></font>一个空行，用于分割响应头和响应体</li><li><font face="宋体"><b>响应体(正文)：</b></font>传输的数据</li></ul><hr><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a><font size="5">响应状态码</font></h2><p>服务器告诉客户端浏览器本次请求和响应的一个状态。<br><br><font color="red"><b>状态码都是3位数字</b></font><br></p><ul><li>1xx：服务器接收客户端消息，但<font color="blue">没有接受完成</font>，等待一段时间后，发送1xx多状态码</li><li>2xx：本次请求响应成功。代表码：200</li><li>4xx：<font color="red">客户端错误。</font><ul><li>404:请求路径没有对应的资源--><font color="blue">路径错误</font></li><li>405:请求方式没有对应的doxxx方法-->比如浏览器请求方式是Post方式，而客户端没有doPost方法</li></ul></li><li>5xx：<font color="red">服务器端错误。</font>代表码：500(服务器内部出现异常)</li></ul> ]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet基础学习</title>
      <link href="/2019/09/08/Servlet%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/08/Servlet%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><b><font size="5">Servlet：server applet</font></b><br>官方给出的解释是<font color="red">运行在服务器端的小程序</font></p><hr><a id="more"></a># Servlet的本质<p>浏览器通过<font color="red">ip和端口</font>来找到服务器，服务器中的资源分为两类</p><ol><li>静态资源，</li><li>动态资源<p>所谓<b>动态资源</b>，就是不同的用户访问到的页面是不一样的，这说明<font color="red">动态资源中肯定有一些逻辑性</font>，来实现不同的用户访问同样的资源看到的是不一样的。而这些逻辑性，就要通过Java代码(Java类)来实现。<font color="red" size="4"><i>也就是说浏览器请求动态资源的时候，访问的就是服务器上的Java类</i></font><br></p>要注意的是：这里说的Java类没有main方法，不能自己运行，需要<font color="red">依赖服务器才能运行</font>，相当于Tomcat(服务器软件)来执行它。那么问题来了，如果要<font color="red">Tomcat能够认识这个类并执行这个类，这个类就需要遵守一定的规则，</font>在Java中，<b>规则==接口</b><br><hr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue" size="5" face="楷体">上面说的规则，就是Servlet，它本质上就是一个接口，定义了Java类被tomcat识别的规则</font><hr></li></ol><h1 id="Servlet的使用"><a href="#Servlet的使用" class="headerlink" title="Servlet的使用"></a>Servlet的使用</h1><ol><li>创建JavaEE项目</li><li> 在<font color="red">src目录内</font>定义一个类，实现Servlet接口</li><li>实现接口中的抽象方法</li><li>配置Servlet(一共有两种方法，这里先记录第一种)<font color="red">在web.xml中配置</font>                                <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;全类名(包名+类名)&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/demo1(Servlet资源路径)&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>在web.xml中加上以上内容</p></li><b><font color="red">Servlet配置原理</font></b><ol><li> 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的url-pattern标签体内容。</li><li>如果有，则通过映射找到对应的servlet-class全类名</li><li>tomcat会将字节码文件加载进内存，并且<font color="red">创建其对象</font><br><font color="red">注意：这个实现了Servlet接口的类是由Tomcat通过反射创建的对象，并不是由程序员创建的</font></li><li>调用对象的方法</li></ol></ol><hr><h1 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h1><ol><li><b>被创建：</b>执行init()方法，<font color="blue">该方法只执行一次</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么Servlet在什么时候被创建呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，在<font color="red">资源第一次被访问时，Servlet被创建</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在web.xml文件中配置改变Servlet被创建的时机<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面说到的<font color="red">servlet标签</font>下配置，具体下面有图</li><li><b>提供服务：</b>执行service方法，可以执行多次<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<font color="blue">每次访问Servlet时，Service方法都会被调用一次。</font></li><li><b>被销毁：</b>执行destroy方法，只<font color="blue">执行一次</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有服务器<b>正常关闭</b>时，才会执行destroy方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy方法在Servlet被<font color="red">销毁之前</font>执行，一般用于释放资源</li></ol><p><b><font color="red">设置Servlet被创建的时机</font></b><br>使用<font color="red">load-on-startup</font>标签，这是一个围堵标签，当<font color="red">标签的值为负数</font>的时候，默认第一次被访问时创建<br>当<font color="red">标签的值为正数或0</font>的时候，服务器启动时创建</p><p><img src="https://img-blog.csdnimg.cn/20190902105855215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="上接设置Servlet被创建的时机"></p><hr><p><b><font color="red">注解配置Servlet</font></b><br><i>在<font color="red">Servlet3.0以后</font>，可以使用注解配置Servlet，相比较在web.xml文件中配置更加方便</i><br><br><b>使用方法：</b><br>在类上加注解<font color="red">@WebServlet(“资源路径”)</font>，这样就可以通过注解的资源路径找到相应的类，直接将类加载进内存<br></p><hr>Servlet体系结构Servlet是一个接口，里面有5个抽象方法，每次继承Servlet接口的时候，都需要重写这5个抽象方法，而实际上，很多时候并用不到其中的有些方法，所以每次都要重写，很麻烦<br><h1 id="Servlet的子类"><a href="#Servlet的子类" class="headerlink" title="Servlet的子类"></a>Servlet的子类</h1><h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><p>GenericServlet也是一个<font color="red">抽象类，</font>将Servlet接口中其他的方法做了<b>默认空实现</b>，<font color="red">只将service()方法作为抽象</font>，将来定义Servlet类时，可以继承GenericServlet，只实现service()方法即可(但实际上，这种方法使用较少)<br></p><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><h3 id="HttpServlet出现原因"><a href="#HttpServlet出现原因" class="headerlink" title="HttpServlet出现原因"></a><font size="5">HttpServlet出现原因</font></h3><p><font color="blue">HttpServlet extends GenericServlet</font><br><b>该类是对Http协议的一种封装和描述</b><br>对于一般的Servlet实现类，在service方法中通过一些操作获取浏览器的数据，但在获取数据之前，需要判断浏览器的请求方式是get方式还是put方式，因为两种方式封装数据的位置和格式是不一样的，对于不同的方式需要进行不同的逻辑处理。<br>也就是说，我们需要在service方法里作两步操作：</p><ol><li><b>判断浏览器请求方式</b></li><li><b>根据不同的请求方式编写不同的逻辑代码</b><hr></li></ol><h3 id="HttpServlet实现原理"><a href="#HttpServlet实现原理" class="headerlink" title="HttpServlet实现原理"></a><font size="5">HttpServlet实现原理</font></h3><p>这个<b>过程比较麻烦，但却是所有的service方法都必须要做<b>的一个过程，因此sun公司就提供了HttpServlet这个类。<br><b>在HttpServlet类的Service方法中，已经写好了判断浏览器请求方式的逻辑代码，我们需要做的就是重写相应doxxx()方法，service方法判断请求方式后，会根据判断的结果调用我们重写的doxxx()方法<b><br><img src="https://img-blog.csdnimg.cn/20190902140302516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019090214065965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上是HttpServlet类service的源码，可以发现，<strong>HttpServlet中的service方法主要用于判断浏览器的请求方式，然后根据不同的请求方式调用相应的doxxx()方法，我们只需要重写这些方法，省略了判断请求方式的步骤</strong></b></b></b></b></p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet类 </tag>
            
            <tag> HttpServlet类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础--SQL语句总结(一)</title>
      <link href="/2019/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%80/"/>
      <url>/2019/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><font size="5">这里主要总结两类SQL语句</font></p><p>DDL和DML，即<font color="red">操作数据库和表</font>的语句以及对<font color="red">表中数据进行增删改操作</font>的语句</p><hr><h1 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h1><p>这类语句又分为两部分</p><ul><li>操作数据库(CRUD)</li><li>操作表(CRUD)</li></ul><hr><a id="more"></a><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ul type="square"><li><b>(Create)创建：</b><br>1. 创建数据库：<font color="blue">create database 数据库名称;</font><br>2. 先判断数据库是否存在，如果不存在，再创建：<font color="blue">create database if not exists 数据库名称;</font><br>3. 创建数据库，并指定字符集：<font color="blue">create database 数据库名称 character set 字符集名;</font><br>4. 创建db4数据库，判断是否存在，并指定字符集为gbk：<font color="red">create database if not exists db4 character set gbk;</font><br></li><li><b>(Retrieve)查询：</b><br>1. 查询所有数据库名称：<font color="blue">show databases;</font><br>2. 查询某个数据库的字符集:<font color="blue">show create database 数据库名称;</font></li><li><b>(Update)修改：</b><br>修改数据库的字符集:<font color="blue">alter database 数据库名称 character set 字符集名称;</font></li><li><b>(Delete)删除：</b><br>1. 删除数据库:<font color="blue">drop database 数据库名称;</font><br>2. 判断数据库存在，存在再删除:<font color="blue">drop database if exists 数据库名称;</font></li><li><b>使用数据库：</b><br>1. 查询当前正在使用的数据库名称:<font color="blue">select database();</font><br>2. 使用数据库:<font color="blue">use 数据库名称;</font></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul type="square"><li><b>(Create)创建：</b><br>1. 创建表：<br><font color="blue">create table 表名(<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名1 数据类型1,<br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名2 数据类型2,<br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名n 数据类型n);</font><br>                    注意：<font color="red">最后一列不加逗号</font><br>2. 复制表：<font color="blue">create table 表名 like 被复制的表名;</font><br>                                        <hr><ul><font color="red" size="5"><b>数据库数据类型</b></font><li>int：整数类型</li><li>double:小数类型</li><li> date:日期，只包含年月日，形如<font color="blue">yyyy-MM-dd</font></li><li>datetime:日期，包含年月日时分秒,<font color="blue"> yyyy-MM-dd HH:mm:ss</font></li><li>timestamp:时间戳类型，包含年月日时分秒    <font color="blue">  yyyy-MM-dd HH:mm:ss</font><br>如果将来<font color="red">不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</font></li><li>varchar：字符串，在使用的时候需要指定长度，例如<font color="blue">varchar(2)表示最大长度2个字符</font></li></ul><hr></li><li><b>(Retrieve)查询：</b><br>1. 查询某个数据库中所有的表名称:<font color="blue">show tables;</font><br> 2. 查询表结构:<font color="blue">desc 表名;</font></li><li><b>(Update)修改：</b><br>1. 修改表名:<font color="blue">alter table 表名 rename to 新的表名;</font><br>2. alter table 表名 character set 字符集名称:<font color="blue">alter table 表名 character set 字符集名称;</font><br>3. 添加一列:<font color="blue">alter table 表名 add 列名 数据类型;</font><br>4. 修改列名称 类型:<font color="blue">alter table 表名 modify 列名 新数据类型;</font></li><li><b>(Delete)删除：</b><br>1. 判断数据库存在，存在再删除:<font color="blue">drop table  if exists 表名 ;</font></li></ul><hr><font size="5" face="楷体" color="red"><i><b>从上面这些语句不难总结得出，无论是数据库还是表，它们的增删改语句都和create、alter、drop、show有关</b></i></font><hr><br><br><hr><h1 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h1><p><font color="red">增删改</font>表中的语句<br><hr></p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p><font color="blue">insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n);</font><br>列名和值要一一对应<br>如果不指定列名，则默认给所有列添加值：<font color="blue">insert into 表名 values(值1,值2,…值n);</font><br><font color="red">除了数字类型，其他类型需要使用引号(单双都可以)引起来</font></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><font color="blue">delete from 表名 [where 条件]</font><br>如果不加条件，则默认删除表中所有数据<br>但是，如果要删除表中所有的话，不推荐使用这种方法，因为效率低<br>推荐使用<font color="blue">TRUNCATE TABLE 表名;</font> 效率更高 先删除表，然后再创建一张一样的表。</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><font color="blue">update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件];</font><font color="red"><br>注意：如果不加条件，则会将表中的记录全部修改</font></p><hr><font size="5" face="楷体" color="red"><i><b>总结：DML语句用来操作表中的数据，主要对数据进行增删改操作，主要有insert 、delete、update三个关键字</b></i></font><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础--数据库概念和SQL简介</title>
      <link href="/2019/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%92%8CSQL%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%92%8CSQL%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>数据库(DataBase)，简称DB，用于存储和管理数据的仓库能够持久化存储数据，实际上，<font color="red"><strong>数据库就是一个文件系统</strong></font>，能够方便的存储和管理数据，使用了统一的方式来操作数据库，即<strong>SQL</strong></p><hr><a id="more"></a><h1 id="MySQL的配置"><a href="#MySQL的配置" class="headerlink" title="MySQL的配置"></a>MySQL的配置</h1><h2 id="MySQL服务启动"><a href="#MySQL服务启动" class="headerlink" title="MySQL服务启动"></a><font size="5">MySQL服务启动</font></h2><ul><li>cmd--> services.msc 打开服务的窗口</li><li>使用管理员方式打开cmd<ul><li>net start mysql : 启动mysql的服务</li><li>net start mysql :关闭mysql的服务</li></ul></li></ul><h2 id="MySQL登录"><a href="#MySQL登录" class="headerlink" title="MySQL登录"></a><font size="5">MySQL登录</font></h2><ol><li>mysql -uroot -p密码</li><li>mysql -hip -uroot -p连接目标的密码</li><li>mysql –host=ip –user=root –password=连接目标的密码</li></ol><h2 id="MySQL退出"><a href="#MySQL退出" class="headerlink" title="MySQL退出"></a>MySQL退出</h2><p> exit/quit命令</p><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><strong>Structured Query Language</strong>：结构化查询语言定义了操作所有关系型数据库的规则，但是不同的数据库操作的方式可能存在不同的地方，可以理解为‘方言’<br>SQL分为四类</p><ol><li><p>DL(Data Definition Language)数据定义语言<br>用来<font color="red">定义数据库对象</font>：数据库，表，列等。关键字：<font color="blue">create, drop,alter</font> 等</p></li><li><p>DML(Data Manipulation Language)数据操作语言<br>用来对<font color="red">数据库中表的数据</font>进行<font color="red">增删改</font>。关键字：<font color="blue">insert, delete, update </font>等</p></li><li><p>DQL(Data Query Language)数据查询语言<br>用来<font color="red">查询数据库中表的记录</font>(数据)。关键字：<font color="blue">select, where</font> 等</p></li><li><p>DCL(Data Control Language)数据控制语言用来<font color="red">定义数据库的访问权限和安全级别</font>，及创建用户。关键字：GRANT， REVOKE 等</p></li></ol><p>一张图来帮助理解四类SQL语句<br><img src="https://img-blog.csdnimg.cn/2019090122091487.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中创建多个Project</title>
      <link href="/2019/09/08/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProject/"/>
      <url>/2019/09/08/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProject/</url>
      
        <content type="html"><![CDATA[<p>我们知道，IDEA是没有workspace这个概念的，它是以Project为单位，一个窗口对应着一个Project，而一个Project对应着很多Model，Model相当于eclipse中的project，那么如何在一个项目中存放多个Project呢？</p><a id="more"></a><h2 id="首先，创建一个空的Project"><a href="#首先，创建一个空的Project" class="headerlink" title="首先，创建一个空的Project"></a>首先，创建一个空的Project</h2><p><img src="https://img-blog.csdnimg.cn/20190901110856188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="给项目命名并点击finish"><a href="#给项目命名并点击finish" class="headerlink" title="给项目命名并点击finish"></a>给项目命名并点击finish</h2><p>会进入到新创建的Project窗口中，接着IDEA就会弹出下面界面，让你为新的Priject创建一个Model：<br><img src="https://img-blog.csdnimg.cn/20190901111135250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这里很重要，<strong>不选择给新的Project创建一个Model</strong>，直接点OK<br>这样，常见出来的没有Model的Project就<strong>相当于</strong>一个空文件夹，(查看创建的Project文件夹，会发现它是没有src的)</p><h2 id="在新的Projrect中，new一个Model"><a href="#在新的Projrect中，new一个Model" class="headerlink" title="在新的Projrect中，new一个Model"></a>在新的Projrect中，new一个Model</h2><p><img src="https://img-blog.csdnimg.cn/20190901111531177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我这里创建的时web项目，如果要创建普通的项目，点击左侧第一个按钮JAVA就可以<br><img src="https://img-blog.csdnimg.cn/20190901111704647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>给新创建的Model起名，通过这里就可以发现，<strong>第一个untitled是创建的project名(由于没有命名，默认就是untitled)，第二个是正在创建的Model名</strong>，点击finish<br>这样就创建成功了一个，按照上面的方法再来一遍<br><img src="https://img-blog.csdnimg.cn/20190901112058507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样就成功地在一个窗口创建了两个Project</p><p>另外<br>IDEA会为这两个web项目分别部署一份配置文件，这样这两个web项目就<strong>可以分别设置不同的端口，虚拟路径等配置</strong><br>运行项目的时候，查看控制台的log：<strong>Using CATALINA_BASE:</strong> 的值，就能找到配置文件的路径<br><img src="https://img-blog.csdnimg.cn/20190901113153885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat部署项目的方式</title>
      <link href="/2019/09/08/Tomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/09/08/Tomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat有三种部署项目的方式"><a href="#Tomcat有三种部署项目的方式" class="headerlink" title="Tomcat有三种部署项目的方式"></a>Tomcat有三种部署项目的方式</h1><h2 id="将项目直接放到Tomcat的webapps目录下"><a href="#将项目直接放到Tomcat的webapps目录下" class="headerlink" title="将项目直接放到Tomcat的webapps目录下"></a><font size="5">将项目直接<strong>放到Tomcat的webapps目录下</strong></font></h2><p>也可以将项目打包成war包，放到webapps目录下，运行时Tomcat会自动解压</p><a id="more"></a><h2 id="利用Tomcat的配置文件sever-xm"><a href="#利用Tomcat的配置文件sever-xm" class="headerlink" title="利用Tomcat的配置文件sever.xm"></a><font size="5">利用Tomcat的配置文件sever.xm</font></h2><pre><code>打开conf目录，找到sever.xml配置文件</code></pre><p>(先关闭Tomcat服务)<img src="https://img-blog.csdnimg.cn/20190831162553805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    找到Host标签，加上一个Context标签，path值可以自己设置<br>    启动Tomcat服务<br>    在浏览器输入<strong>localhost:8080(端口号)/path的值/docBase的值</strong>就能正确访问项目<br>    这种部署方式项目可以放在硬盘上的任意位置，Tomcat会通过path映射到docBase。</p><p><strong>注意：</strong>因为server.xml是Tomcat服务核心的配置文件，是配置Tomcat整体的，在里面配置项目有可能损坏配置文件，导致出错，比较危险，所以一般不推荐使用</p><h2 id="自定义xml配置文件"><a href="#自定义xml配置文件" class="headerlink" title="自定义xml配置文件"></a><font size="5">自定义xml配置文件</font></h2><pre><code>(先**关闭Tomcat**)打开Tomcat下的conf\Catalina\localhost这个目录，在localhost下创建一个xml配置文件， 文件名可以任意起(但是这个文件名就是浏览器搜索时的虚拟路径)，假设是aaa.xml； 在配置文件中：将上图中红框里的Context标签及内容写进去，把后面的path键值对删掉(因为虚拟路径已经指定为xml文件名，所以不需要再指定虚拟路径) 再次启动Tomcat 浏览器搜索**localhost:8080(端口号)/xml文件名/docBase的值**即可</code></pre><p>这种部署方式还有一个好处：</p><ul><li>这是一种热部署的方式，如果不想要这个项目，可以将创建的xml文件删掉，或者后缀名改一下<br>  例如：将aaa.xml改为aaa.xml_bak；无需重新启动Tomcat就能生效(浏览器就访问不到项目资源)</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat启动问题分析</title>
      <link href="/2019/09/08/tomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/08/tomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="问题前提"><a href="#问题前提" class="headerlink" title="问题前提"></a>问题前提</h1><p>在Tomcat目录下的bin目录中双击startup.bat直接打开tomcat时，可能会出现以下两个问题</p><ul><li>Tomcat的窗口一闪而过</li><li>启动报错<a id="more"></a></li></ul><h2 id="Tomcat的窗口一闪而过"><a href="#Tomcat的窗口一闪而过" class="headerlink" title="Tomcat的窗口一闪而过"></a><strong>Tomcat的窗口一闪而过</strong></h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>没有正确配置JAVA_HOME环境变量</strong><br>在安装JDK时，需要将JDK的目录配置到Path变量下，问题就在这里，因为配置的时候，有可能是直接将JDK的目录配置到了Path环境变量<br>双击Path变量，如下图所示<img src="https://img-blog.csdnimg.cn/20190831151212475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样的<strong>做法是错误的</strong>    </p><h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>应该先创建一个JAVA_HOME环境变量<br><img src="https://img-blog.csdnimg.cn/20190831151442686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将JAVA_HOME的值设置问JDK的路径，如下图<br><img src="https://img-blog.csdnimg.cn/20190831151627898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再将JAVA_HOME代替JDK安装路径给Path变量<br><img src="https://img-blog.csdnimg.cn/20190831151900812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将startup.bat关掉，重新启动即可</p><h3 id="分析一下原因"><a href="#分析一下原因" class="headerlink" title="分析一下原因"></a>分析一下原因</h3><p>先以文档的形式打开startup.bat，发现和catolina.bat有关，<br>我们就以<strong>文档形式</strong>打开bin目录下的catolina.bat<br><img src="https://img-blog.csdnimg.cn/20190831152302712.png" alt="在这里插入图片描述"><br>在文档里可以看到，这里用到了环境变量的JAVA_HOME，所以在配置环境变量的时候，必须用JAVA_HOME来设置JDK路径，否则这里<strong>就无法找到JDK</strong>，由于Tomcat是纯java编写的，它的启动和运行要依赖与JDK，所以Tomcat就无法正常运行</p><h2 id="启动报错，然后窗口自动关闭"><a href="#启动报错，然后窗口自动关闭" class="headerlink" title="启动报错，然后窗口自动关闭"></a><strong>启动报错，然后窗口自动关闭</strong></h2><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>有可能是<strong>已经打开了一个Tomcat</strong>(或者有其他程序占用了Tomcat的端口号)，再次启动的时候由于<strong>端口被占用</strong>，所以无法正常启动<br>如果是这种情况，通过查看日志会发现有一个异常：<strong>java.net.BindException:Address already in use</strong></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>找到占用Tomcat端口号(一般是8080)的程序，关闭该程序<br>1、打开cmd窗口，输入 <strong>netstat -ano</strong>命令<br><img src="https://img-blog.csdnimg.cn/20190831161113175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找到Tomcat端口(我的是默认8080)，记录该<strong>端口程序的PID</strong><br>2、打开任务管理器<br><img src="https://img-blog.csdnimg.cn/2019083116142190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找到刚记录的PID对应的程序，把它关掉。<br>这样，Tomcat就能正确启动了</p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 问题分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM模型基础学习</title>
      <link href="/2019/09/08/BOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/08/BOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><p>BOM，全称Browser Object Model，浏览器对象模型<br>它将浏览器的各个组成部分封装成对象</p><hr><a id="more"></a><h1 id="五个对象"><a href="#五个对象" class="headerlink" title="五个对象"></a>五个对象</h1><h2 id="window-窗口对象"><a href="#window-窗口对象" class="headerlink" title="window-窗口对象"></a><font size="4">window-窗口对象</font></h2><h2 id="Location-地址栏对象"><a href="#Location-地址栏对象" class="headerlink" title="Location-地址栏对象"></a><font size="4">Location-地址栏对象</font></h2><h2 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History-历史记录对象"></a><font size="4">History-历史记录对象</font></h2><h2 id="Screen-显示器屏幕对象"><a href="#Screen-显示器屏幕对象" class="headerlink" title="Screen-显示器屏幕对象"></a><font size="4">Screen-显示器屏幕对象</font></h2><h2 id="Navigator-浏览器对象"><a href="#Navigator-浏览器对象" class="headerlink" title="Navigator-浏览器对象"></a><font size="4">Navigator-浏览器对象</font></h2><hr><h1 id="window-窗口对象-1"><a href="#window-窗口对象-1" class="headerlink" title="window-窗口对象"></a>window-窗口对象</h1><p>该对象<strong>无需创建</strong>，可以直接使用对象的方法和属性</p><h2 id="window对象的方法"><a href="#window对象的方法" class="headerlink" title="window对象的方法"></a><font size="5">window对象的方法</font></h2><h3 id="与弹出框有关的方法"><a href="#与弹出框有关的方法" class="headerlink" title="与弹出框有关的方法"></a><font size="5">与弹出框有关的方法</font></h3><h4 id="alert"><a href="#alert" class="headerlink" title="alert()"></a><font size="4">alert()</font></h4><p>显示带有一段消息和一个确认按钮的警告框。</p><h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a><font size="4">confirm()</font></h4><p>显示带有一段消息以及确认按钮和取消按钮的对话框。</p><ul><li><p>如果用户点击确定按钮，则方法返回true</p></li><li><p>如果用户点击取消按钮，则方法返回false</p><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a><font size="4">prompt()</font></h4><p>显示可提示用户输入的对话框。</p></li><li><p>返回值：获取用户输入的值 </p><h3 id="与打开关闭有关的方法"><a href="#与打开关闭有关的方法" class="headerlink" title="与打开关闭有关的方法"></a><font size="5">与打开关闭有关的方法</font></h3><h4 id="close"><a href="#close" class="headerlink" title="close()"></a><font size="4">close()</font></h4><p>关闭浏览器窗口。</p></li><li><p>谁调用我 ，我关谁</p><h4 id="open"><a href="#open" class="headerlink" title="open()"></a><font size="4">open()</font></h4><p>打开一个新的浏览器窗口</p></li><li><p>返回新的Window对象</p><h3 id="与定时器有关的方式"><a href="#与定时器有关的方式" class="headerlink" title="与定时器有关的方式"></a><font size="5">与定时器有关的方式</font></h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a><font size="4">setTimeout()</font></h4><p>在指定的毫秒数后调用函数或计算表达式。</p><ul><li>参数：<ol><li>js代码或者方法对象</li><li>毫秒值</li></ol></li><li>返回值：唯一标识，用于取消定时器<h4 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout()"></a><font size="4">clearTimeout()</font></h4>取消由 setTimeout() 方法设置的 timeout。<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a><font size="4">setInterval()</font></h4>按照指定的周期（以毫秒计）来调用函数或计算表达式。<h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a><font size="4">clearInterval()</font></h4>取消由 setInterval() 设置的 timeout。<h2 id="window对象的属性"><a href="#window对象的属性" class="headerlink" title="window对象的属性"></a><font size="5">window对象的属性</font></h2><h3 id="获取其他BOM对象"><a href="#获取其他BOM对象" class="headerlink" title="获取其他BOM对象"></a><font size="4">获取其他BOM对象</font></h3>history<br>location<br>Navigator<br>Screen<h3 id="获取DOM对象"><a href="#获取DOM对象" class="headerlink" title="获取DOM对象"></a><font size="4">获取DOM对象</font></h3>document</li></ul><hr></li></ul><h1 id="Location-地址栏对象-1"><a href="#Location-地址栏对象-1" class="headerlink" title="Location-地址栏对象"></a>Location-地址栏对象</h1><h2 id="创建-获取"><a href="#创建-获取" class="headerlink" title="创建(获取)"></a><font size="5">创建(获取)</font></h2><pre><code>1. window.location2. location</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><font size="5">方法</font></h2><p>reload()    重新加载当前文档。刷新</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a><font size="5">属性</font></h2><p>href    设置或返回完整的 URL。<br><img src="https://img-blog.csdnimg.cn/2019082814430963.png" alt="在这里插入图片描述"><br>如图，给按钮设置监听器，点击按钮后修改页面的URL为百度页面，就会自动跳转到百度的页面</p><hr><h1 id="History-历史记录对象-1"><a href="#History-历史记录对象-1" class="headerlink" title="History-历史记录对象"></a>History-历史记录对象</h1><h2 id="创建-获取-1"><a href="#创建-获取-1" class="headerlink" title="创建(获取)"></a><font size="5">创建(获取)</font></h2><pre><code>1. window.history2. history</code></pre><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><font size="5">方法</font></h2><h3 id="back"><a href="#back" class="headerlink" title="back()"></a><font size="4">back()</font></h3><p>加载 history 列表中的前一个 URL。</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward()"></a><font size="4">forward()</font></h3><p>加载 history 列表中的下一个 URL。</p><h3 id="go-参数"><a href="#go-参数" class="headerlink" title="go(参数)"></a><font size="4">go(参数)</font></h3><p>加载 history 列表中的某个具体页面。<br>    参数：<br>        正数：前进几个历史记录<br>        负数：后退几个历史记录</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a><font size="5">属性</font></h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a><font size="4">length</font></h3><pre><code>返回当前窗口历史列表中的 URL 数量。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> BOM </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2019/09/08/JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/09/08/JavaScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JS和HTML结合方式"><a href="#JS和HTML结合方式" class="headerlink" title="JS和HTML结合方式"></a><strong>JS和HTML结合方式</strong></h1><h2 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a><font size="5">内部样式</font></h2><pre><code>在html文件内部定义一个script标签、在标签里面写的JS代码</code></pre><p>注意：<strong>和CSS不同的是，JS标签可以有很多个，而且可以写在HTML文件中的任意位置</strong>    </p><h2 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a><font size="5">外部样式</font></h2><pre><code>在html文件内部定义一个script标签，通过script的src属性，来指定JS配置文件的路径JS代码写在JS配置文件中</code></pre><a id="more"></a><h1 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a><strong>数据类型和变量</strong></h1><pre><code>JS数据类型和JAVA类似，分为**原始数据类型**和**引用数据类型**两大类</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><font size="5">数据类型</font></h2><h3 id="number"><a href="#number" class="headerlink" title="number"></a><font size="5">number</font></h3><p>包括整数、小数和NaN类型(不是数字的数字类型 not a numebr)</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a><font size="5">string</font></h3><p>字符/字符串类型</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a><font size="5">boolean</font></h3><p>true/false、</p><h3 id="null"><a href="#null" class="headerlink" title="null"></a><font size="5">null</font></h3><p>一个对象为空的占位符</p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a><font size="5">undefined</font></h3><p>未定义，如果一个表量没有给初始化值，就会被默认赋值为 undefined</p><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828110402952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><font size="5">变量</font></h2><pre><code>一小块存储数据的内存空间JAVA是强类型语言，而JavaScript是弱类型语言</code></pre><h3 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a><font size="5">强类型</font></h3><p>在开辟内存空间时，定义了空间将来存储数据的类型，只能存储固定的类型</p><h3 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a><font size="5">弱类型</font></h3><p>在开辟内存空间时，没有定义空间将来存储数据的类型，可以存放任意类型的数据</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h1><pre><code>在JS中，如果运算数不是运算符要求的类型，那么JS会自动将运算数进行类型转换例如：一元运算符+(正号)和-(负号)是对数字类型进行操作，但是有+&apos;a&apos;这样的运算，就会将字符串类型的&apos;a&apos;转换为number类型</code></pre><h2 id="其他类型转number"><a href="#其他类型转number" class="headerlink" title="其他类型转number"></a><font size="5">其他类型转number</font></h2><pre><code>string--&gt;number：**按照字面值转换**，如果字面值是数字，如&apos;123&apos;，会转换成数字123，如果字面值不是数字，如&apos;abc&apos;，会转换为NaN(不是数字的数字)</code></pre><p>注意：<strong>NaN和整数小数运算，还是NaN;</strong><br>    boolean–&gt;number: true=1    false=0</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><font size="5">比较运算符</font></h2><pre><code>字符串按照字典顺序比较(如c&gt;b),按位逐一比较，直到得出大小**类型不同比较，先进行类型转换**”===“运算符：在比较之前先进行类型判断，如果类型不同，直接返回false</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><font size="5"><strong>逻辑运算符</strong></font></h2><pre><code>！：非运算</code></pre><h2 id="其他类型转boolean"><a href="#其他类型转boolean" class="headerlink" title="其他类型转boolean"></a><font size="5">其他类型转boolean</font></h2><pre><code>    number--&gt;boolean：0和NaN为false，其他都是true    string--&gt;boolean：除了空字符串，都是true    null/undefined--&gt;boolean：false    对象--&gt;boolean：true注意：在JS中，所有的**变量都是关键字var**定义的，var可以省略，但是，**用var定义的是局部变量**，不用var定义的    是全局变量</code></pre><h1 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h1><h2 id="function对象"><a href="#function对象" class="headerlink" title="function对象"></a><font size="5">function对象<font></font></font></h2><p> 方法对象<br><img src="https://img-blog.csdnimg.cn/20190828112256343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="1、创建"></p><h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a><font size="5">Array对象</font></h2><p>数组对象<br> <img src="https://img-blog.csdnimg.cn/20190828112447511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 数组长度可变<br> <img src="https://img-blog.csdnimg.cn/20190828112613787.png" alt="在这里插入图片描述"></p><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a><font size="5">Date对象</font></h2><p><img src="https://img-blog.csdnimg.cn/20190828140543392.png" alt="在这里插入图片描述"></p><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a><font size="5">Math对象</font></h2><pre><code>该对象不用创建，可以直接使用对象的方法和属性，Math.调用常用方法和属性：</code></pre><p><img src="https://img-blog.csdnimg.cn/20190828140726715.png" alt="在这里插入图片描述"></p><h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a><font size="5">Global对象</font></h2><pre><code> 特点：是一个全局对象，这个对象中封装的方法不需要对象就能够直接使用,和Math不同的是，使用它的方法前面不            用加对象名在说该对象的方法之前先说一下**URL编码**：    浏览器将从表单中收集的数据经过URL编码后发送给服务器，服务器再将接收到的URL编码的数据解码。    URL编码的规则：对于汉字，先将汉字按照GBK/UTF8编码成对应的二进制数字，再将每四位二进制数字组合在                一起转换成十六进制数字，这样就将汉字转换成了一串十六进制数字，最后，每两个十六进制数字一组，在前面    +%，这样就组成了URL编码，字母和数字不编码</code></pre><p><img src="https://img-blog.csdnimg.cn/20190828141907481.png" alt="在这里插入图片描述"><br>第二组方法编码的字符更多，会将网址中./等符号也用URL编码<br><img src="https://img-blog.csdnimg.cn/20190828142057995.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器和常用属性</title>
      <link href="/2019/09/08/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/09/08/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a><strong>基础选择器</strong></h2><h1 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a><font size="5">id选择器</font></h1><p><strong>使用此选择器要求HTML相应的标签必须指定了id属性</strong></p><a id="more"></a><p>格式：</p><p>#+标签id属性{<br>    <strong>//对应id标签的属性</strong><br>    如color等<br>}<br><img src="https://img-blog.csdnimg.cn/20190828102502128.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190828102519950.png" alt="在这里插入图片描述"><br>通过HTML标签的id来指定标签，修改样式</p><h1 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a><font size="5">元素选择器</font></h1><p>格式：<br>标签名称{<br>        //通过标签名称找到标签(可能不止一个)并修改内容样式<br>    }<br><img src="https://img-blog.csdnimg.cn/20190828102904335.png" alt="在这里插入图片描述"><br>这个元素选择器会找到HTML中所有的div标签，并将标签内容字体改为红色</p><h1 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a><font size="5">类选择器</font></h1><p> 格式：<br> .+类名{<br>    通过标签的class属性值找到标签<br>     }<br><img src="https://img-blog.csdnimg.cn/20190828103244137.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190828103300130.png" alt="在这里插入图片描述"><br>其中：三个选择器中     <strong>id选择器优先级最高，元素选择器优先级最低</strong></p><h2 id="扩展选择器"><a href="#扩展选择器" class="headerlink" title="扩展选择器"></a><strong>扩展选择器</strong></h2><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828103900651.png)</code></pre><p><img src="https://img-blog.csdnimg.cn/20190828103950418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="CSS常见属性"><a href="#CSS常见属性" class="headerlink" title="CSS常见属性"></a><strong>CSS常见属性</strong></h2><p><img src="https://img-blog.csdnimg.cn/20190828104257512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a><strong>盒子模型</strong></h2><p> <strong>参见JAVA_WEB/HTML&amp;CSS</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基础回顾</title>
      <link href="/2019/09/08/HTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
      <url>/2019/09/08/HTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<p>HTML用于搭建基础页面，展示页面内容，一般和CSS以及JS搭配使用</p><h2 id="HTML标签分类"><a href="#HTML标签分类" class="headerlink" title="HTML标签分类"></a>HTML标签分类</h2><pre><code># 1、围堵标签    顾名思义，就是开始和结束标签，例如&lt; html&gt; &lt; /html&gt;，内容放在标签中# 2、自闭合标签    开始标签和结束标签在一起。例如换行标签&lt; br/&gt;、超链接标签&lt; a&gt;等</code></pre><a id="more"></a><p>标签不区分大小写，建议小写<br>无论是哪种标签，都可以在<strong>开始标签中定义属性</strong>，属性是由<strong>键值对</strong>组成，其中<strong>值需要由引(单/双)号引</strong>起来</p><pre><code>&lt; html&gt;&lt;head&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt;&lt;/body&gt;&lt; /html&gt;</code></pre><h2 id="文件标签"><a href="#文件标签" class="headerlink" title="文件标签"></a><strong>文件标签</strong></h2><h1 id="lt-html-gt"><a href="#lt-html-gt" class="headerlink" title="&lt; html&gt;"></a>&lt; html&gt;</h1><p>文档的根标签</p><h1 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt; head&gt;"></a>&lt; head&gt;</h1><p>头标签，用于指定html文档的一些属性，引入外部资源，如CSS、JS文件等</p><h1 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt; title&gt;"></a>&lt; title&gt;</h1><p> 标题标签</p><h1 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt; body&gt;"></a>&lt; body&gt;</h1><p> 体标签，html代码写在body标签中<br> 以上均为<strong>围堵标签</strong></p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a><strong>文本标签</strong></h2><h1 id="lt-h1-gt-lt-h6-gt"><a href="#lt-h1-gt-lt-h6-gt" class="headerlink" title="&lt; h1&gt;~&lt; h6&gt;"></a>&lt; h1&gt;~&lt; h6&gt;</h1><p>标题标签，从h1到h6字体大小递减    –&gt;围堵标签</p><h1 id="lt-p-gt"><a href="#lt-p-gt" class="headerlink" title="&lt; p&gt;"></a>&lt; p&gt;</h1><p>段落标签：被该标签包裹的文本会换行两次    –&gt;围堵标签</p><h1 id="lt-br-gt"><a href="#lt-br-gt" class="headerlink" title="&lt; br&gt;"></a>&lt; br&gt;</h1><p>换行标签</p><h1 id="lt-hr-gt"><a href="#lt-hr-gt" class="headerlink" title="&lt; hr&gt;"></a>&lt; hr&gt;</h1><p>展示一条水平线<br>    该标签有一些属性：color、width、height、align(对齐方式)来设置水平线的样式</p><h1 id="lt-b-gt"><a href="#lt-b-gt" class="headerlink" title="&lt; b&gt;"></a>&lt; b&gt;</h1><p>字体加粗标签</p><h1 id="lt-i-gt"><a href="#lt-i-gt" class="headerlink" title="&lt; i&gt;"></a>&lt; i&gt;</h1><p>字体斜体标签<br>以上四个均为<strong>自闭合标签</strong></p><h1 id="lt-font-gt"><a href="#lt-font-gt" class="headerlink" title="&lt; font&gt;"></a>&lt; font&gt;</h1><p>字体标签<br>    该标签属性：color、size、face(字体)来改变字体<br>    center：文本居中标签    </p><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a><strong>图片标签</strong></h2><h1 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt; img&gt;"></a>&lt; img&gt;</h1><p>图片标签，是一个自闭合标签，其中有<strong>src属性</strong>，可以指定展示<strong>图片的路径</strong><br>     <strong>相对路径</strong>：<br>         其中如果html文件和<strong>图片所在文件夹目录</strong>是同一级目录，那么<strong>./+图片所在文件夹目录/图片</strong><br>         如果图片所在文件夹目录是html文件上一级目录，那么就用<strong>../</strong></p><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a><strong>列表标签</strong></h2><h1 id="lt-ol-gt-lt-li-gt"><a href="#lt-ol-gt-lt-li-gt" class="headerlink" title="&lt; ol&gt;/&lt; li&gt;"></a>&lt; ol&gt;/&lt; li&gt;</h1><p>有序列表</p><p><img src="https://img-blog.csdnimg.cn/20190828091446194.png" alt="在这里插入图片描述"><br>type属性：指定序号的样式<br><img src="https://img-blog.csdnimg.cn/20190828091536997.png" alt="在这里插入图片描述"></p><h1 id="lt-ul-gt-lt-li-gt"><a href="#lt-ul-gt-lt-li-gt" class="headerlink" title="&lt; ul&gt;/&lt; li&gt;"></a>&lt; ul&gt;/&lt; li&gt;</h1><p>无序列表<br><img src="https://img-blog.csdnimg.cn/20190828091641556.png" alt="在这里插入图片描述"><br>无序列表的type属性有三种：</p><ul><li><p>disc：原点</p></li><li><p>square：正方形点</p></li><li><p>circle：圆圈</p><h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a><strong>链接标签</strong></h2><h1 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt; a&gt;"></a>&lt; a&gt;</h1><p>定义一个超链接<br>  属性：<br> <strong>href</strong><br> 指定访问资源的URL()统一资源定位符)，可以是网址<br> <strong>target</strong><br> 指定打开资源的方式，有两种方式</p><ul><li><p>_ selt:在当前页面打开</p></li><li><p>_ blank：在新空白页面打开</p></li></ul></li></ul><h2 id="和CSS以及JS搭配的标签"><a href="#和CSS以及JS搭配的标签" class="headerlink" title="和CSS以及JS搭配的标签"></a><strong>和CSS以及JS搭配的标签</strong></h2><p> div标签和span标签，两者的区别是div自带换行，而span没有换行功能</p><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a><strong>表格标签</strong></h2><h1 id="lt-table-gt"><a href="#lt-table-gt" class="headerlink" title="&lt; table&gt;"></a>&lt; table&gt;</h1><p> 定义表格，table的开始标签可以指定一些属性</p><ul><li><p>width：表格宽度</p></li><li><p>border：边框</p></li><li><p>cellpadding：定义内容和单元格的距离</p></li><li><p>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条    </p></li><li><p>bgcolor：背景色</p></li><li><p>align：对齐方式</p><h1 id="lt-tr-gt-标签"><a href="#lt-tr-gt-标签" class="headerlink" title="&lt; tr&gt;标签"></a>&lt; tr&gt;标签</h1><p>定义行标签</p><h1 id="lt-td-gt-标签"><a href="#lt-td-gt-标签" class="headerlink" title="&lt; td&gt;标签"></a>&lt; td&gt;标签</h1><p>定义单元格标签</p><h1 id="lt-th-gt-标签"><a href="#lt-th-gt-标签" class="headerlink" title="&lt; th&gt;标签"></a>&lt; th&gt;标签</h1><p>定义表头单元格标签<br><img src="https://img-blog.csdnimg.cn/20190828093432266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190828093456827.png" alt="在这里插入图片描述"></p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a><strong>表单标签</strong></h2><p><strong>注意：表单中的数据要想被提交，必须指定其name属性</strong></p><p>表单：用于采集用户输入的数据，用于和服务器进行交互</p><h1 id="lt-form-gt"><a href="#lt-form-gt" class="headerlink" title="&lt; form&gt;"></a>&lt; form&gt;</h1><p>用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围<br>form标签有以下属性</p><ul><li>action：指定提交数据的URL路径</li><li>method：指定提交方式，有两种比较常用，分别是post和get</li></ul><p>form只是制定了收集用户数据的范围，并没有指定提交形式(输入框、按钮、下拉列表…)<br>因此就会用到<strong>表单项标签</strong><br>表单项标签主要有三种：input标签、select标签、textarea标签</p><h1 id="lt-input-gt-标签"><a href="#lt-input-gt-标签" class="headerlink" title="&lt; input&gt;标签"></a><strong>&lt; input&gt;标签</strong></h1><p><img src="https://img-blog.csdnimg.cn/20190828095605481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190828095805666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示效果<br><img src="https://img-blog.csdnimg.cn/20190828095919345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="lt-select-gt-标签"><a href="#lt-select-gt-标签" class="headerlink" title="&lt; select&gt;标签"></a><strong>&lt; select&gt;标签</strong></h1><p>子元素：option，指定列表项<br><img src="https://img-blog.csdnimg.cn/20190828100135207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示效果<br><img src="https://img-blog.csdnimg.cn/20190828100222610.png" alt="在这里插入图片描述"></p><h2 id="文本域标签"><a href="#文本域标签" class="headerlink" title="文本域标签"></a><strong>文本域标签</strong></h2><p><strong>主要有两个属性：</strong><br>cols：指定列数，每一行有多少个字符<br>rows：默认多少行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码--Byte类</title>
      <link href="/2019/09/08/%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB/"/>
      <url>/2019/09/08/%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/26bedb3ae3c4" target="_blank" rel="noopener">学习过程中参考此篇文章，写的很好</a></p><pre><code>1、观察它继承的父类，实现了那些接口2、找到它的成员变量3、学习构造方法4、学习方法</code></pre><a id="more"></a><h2 id="一、父类和接口"><a href="#一、父类和接口" class="headerlink" title="一、父类和接口"></a>一、父类和接口</h2><p><img src="https://img-blog.csdnimg.cn/20190820165734747.png" alt="在这里插入图片描述"><br>从图中可以知道，Byte类继承了Number类，实现了Comparable接口</p><p>对于Comparable接口，只有一个抽象方法<br><img src="https://img-blog.csdnimg.cn/20190820165913264.png" alt="在这里插入图片描述"><br>这个接口赋予它和它的子类比较的能力，用于排序，比较大小<br>对于一个存储自定义类的数组或集合，只有这个类实现了该接口，重写了接口中的compareTo()方法，重写了排序规则<br>才能使用Arrays类的sort方法进行排序；</p><h2 id="二、成员变量"><a href="#二、成员变量" class="headerlink" title="二、成员变量"></a>二、成员变量</h2><p><img src="https://img-blog.csdnimg.cn/20190820170344112.png" alt="在这里插入图片描述"><br>定义了Byte类型数据的边界值，就是说，Byte类型的值只能在-128~127之间<br><img src="https://img-blog.csdnimg.cn/20190820170442432.png" alt="在这里插入图片描述"><br>TYPE是一个Byte的Class类对象，相当于TYPE=Byte.class；<br><img src="https://img-blog.csdnimg.cn/20190820170619953.png" alt="在这里插入图片描述"><br>这就是Byte类型的基础类型，数据存储的地方(从下面的构造方法可以看出)<br><img src="https://img-blog.csdnimg.cn/20190820170834358.png" alt="在这里插入图片描述"><br>这三个成员变量分别表示Byte数据的位数，字节数和UID(用于序列化和反序列化)</p><h2 id="三、构造方法"><a href="#三、构造方法" class="headerlink" title="三、构造方法"></a>三、构造方法</h2><p><img src="https://img-blog.csdnimg.cn/20190820171029523.png" alt="在这里插入图片描述"><br>Byte的构造方法有两个，可以看出，两个构造方法都会将传入的数据存放到成员变量byte中</p><h2 id="四、私有静态内部类"><a href="#四、私有静态内部类" class="headerlink" title="四、私有静态内部类"></a>四、私有静态内部类</h2><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171705760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)这是Byte类的一个静态内部类，类里面还有一个静态代码块静态代码块会在类第一次被加载的时候执行，并且只执行一次这里的作用就是，创建一个Byte类型的数组，数组的长度是256里面存储着-128~127的数字(Byte类数据所有可能的取值)并且数组是静态的并且final修饰，因为后面的有些成员方法会需要用到Byte对象，所以这样做就避免了重复创建对象和回收对象</code></pre><h2 id="五、成员方法"><a href="#五、成员方法" class="headerlink" title="五、成员方法"></a>五、成员方法</h2><h1 id="1、toString-byte-b-方法"><a href="#1、toString-byte-b-方法" class="headerlink" title="1、toString(byte b)方法"></a>1、toString(byte b)方法</h1><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171318100.png)注意：这个toString()方法不是重写Object的toString方法，因为它有参数作用：将一个byte类型数据转化为String字符串类型实质上是直接调用Integer类的toString方法，radix：10：用10进制表示</code></pre><h1 id="2、valueOf-byte-b"><a href="#2、valueOf-byte-b" class="headerlink" title="2、valueOf(byte b)"></a>2、valueOf(byte b)</h1><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172235507.png)作用：将基本类型--&gt;包装类型，直接从上面的数组中得到</code></pre><h1 id="3、parseByte-String-s-int-radix"><a href="#3、parseByte-String-s-int-radix" class="headerlink" title="3、parseByte(String s,int radix)"></a>3、parseByte(String s,int radix)</h1><p><img src="https://img-blog.csdnimg.cn/20190820172354614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 参数：<br>     String s:要解析的字符串<br>     int radix:指定字符串表示的进制<br>     例如：s=“10000”，radix=2，解析出来的值就是16<br> 作用：<br>     将字符串按照指定进制解析为byte类型<br>     实质上调用的是Integer的parseInt方法，解析成int类型<br>     判断是否超出范围，超出范围就抛异常，否则就返回</p><h1 id="4、parseByte-String-s"><a href="#4、parseByte-String-s" class="headerlink" title="4、parseByte(String s)"></a>4、parseByte(String s)</h1><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172742458.png)不指定进制默认十进制解析</code></pre><h1 id="5、valueOf-String-s-int-radix"><a href="#5、valueOf-String-s-int-radix" class="headerlink" title="5、valueOf(String s,int radix)"></a>5、valueOf(String s,int radix)</h1><p>  <img src="https://img-blog.csdnimg.cn/20190820172830452.png" alt="在这里插入图片描述"><br>参数：<br>    String s:要转换的字符串<br>    int radix：字符串表示的进制，和解析方法一样<br>作用：<br>    将字符串转换为按照指定进制形式表示的Byte类型，<br>先将字符串解析为byte类型，在调用valueOf()方法，从静态代码块初始的数组中找到对应的Byte并返回</p><h1 id="6、valueOf-String-s"><a href="#6、valueOf-String-s" class="headerlink" title="6、valueOf(String s)"></a>6、valueOf(String s)</h1><pre><code>默认10进制</code></pre><h1 id="7、xxxValue-方法"><a href="#7、xxxValue-方法" class="headerlink" title="7、xxxValue()方法"></a>7、xxxValue()方法</h1><pre><code>重写父类的方法，由于byte数值最小，不用担心出现溢出直接用强制类型转换，然后return</code></pre><h1 id="8、hashCode"><a href="#8、hashCode" class="headerlink" title="8、hashCode()"></a>8、hashCode()</h1><p><img src="https://img-blog.csdnimg.cn/20190820174011475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>重写了父类的hashCode方法，对于Byte类型，它的hashCode方法实质上就是返回它的值</p><h1 id="9、equals-方法"><a href="#9、equals-方法" class="headerlink" title="9、equals()方法"></a>9、equals()方法</h1><p> <img src="https://img-blog.csdnimg.cn/20190820174148966.png?x-ossprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 重写了父类的equals方法</p><h1 id="10、compareTo-方法"><a href="#10、compareTo-方法" class="headerlink" title="10、compareTo()方法"></a>10、compareTo()方法</h1><p> <img src="https://img-blog.csdnimg.cn/20190820174320144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 重写了接口中的compareTo方法，直接返回两个对象的差值<br> 调用方法的对象-方法的参数</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Byte </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青蛙跳台阶</title>
      <link href="/2019/09/07/LeetCode-%E7%AC%AC70%E9%A2%98/"/>
      <url>/2019/09/07/LeetCode-%E7%AC%AC70%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>难度： 简单</strong></p><p><img src="https://img-blog.csdnimg.cn/20190816200841350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="题目如图"></p><a id="more"></a><p><strong>1、动态规划</strong><br>可以知道，如果要到达第n阶台阶，有两种方式：<br>第一：从n-1阶台阶跨1步<br>第二：从n-2阶台阶跨2步<br>设到达第n阶台阶的方法总数为sum(n)<br>那么由上面可以知道：<strong>sum(n)=sum(n-2)+sum(n-1)</strong></p><p>可以举例假设一下假设n等于3，那么到达第3阶台阶由两种方法<br>1、从第1阶台阶跨2步上去<br>2、从第2阶跨1步上去</p><p>相应的，到达第1阶台阶只有一种方法，sum(1)=1；<br>到达第2阶台阶也有两种方法：从起始位置跨2步，和先跨1步再跨1步，sum(2)=2；<br>所以sum(3)=3;<br><img src="https://img-blog.csdnimg.cn/20190816202224968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、斐波那契数列</strong><br>通过观察规律可以知道：<br>假设第0阶为1；<br>那么可以得到从第1阶往后分别是：<br><strong>1，2，3，5，8，13…..</strong><br>这是一个很明显的斐波那契数列</p><p>3、递归<br>同样的思路，爬第n阶台阶的方法和等于爬上第n-1阶台阶和爬上第n-2阶台阶方法之和<br>递归出口：n=0的时候返回1，n&lt;0的时候返回0；<br><img src="https://img-blog.csdnimg.cn/20190816202100472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行到44个样例的时候栈爆了…..</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流和字节流</title>
      <link href="/2019/09/07/JAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/09/07/JAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.itcast.cn/news/20181219/14592257466.shtml" target="_blank" rel="noopener">深入理解字符流编码</a></p><p><strong>首先要理解字符流输入的原理：</strong><br>字符流输入其实底层也是字节流输入</p><p>字符–&gt;计算机二进制数字（字节）：编码<br>字节(计算机二进制数字)–&gt;字符：解码</p><a id="more"></a><h2 id="写入时："><a href="#写入时：" class="headerlink" title="写入时："></a>写入时：</h2><pre><code>1、当使用字符流的write方法向文件写入数据的时候，数据会先写进内存缓冲区中，2、内存缓冲区会先字符对比着系统码表编码(中文系统是GBK)为对应的字节：字符--&gt;数字3、调用了flush方法或者是close方法后，内存缓冲区中编码为字节(数字)会写入到文件中</code></pre><h2 id="读取时："><a href="#读取时：" class="headerlink" title="读取时："></a>读取时：</h2><pre><code>使用read方法读取文件的时候，文建会先将存储在计算机中的二进制对照系统码表解码成相应的字符，读入程序</code></pre><h2 id="图片不能用字符流的原因"><a href="#图片不能用字符流的原因" class="headerlink" title="图片不能用字符流的原因"></a>图片不能用字符流的原因</h2><pre><code>因为图片是字节文件，计算机中存储的也是字节数字，所以用字节流输入的时候不需要编码解码的过程，直接将计算机中的字节读取写入就可以了但是用字符流读取的时候，一次读取两个字节，然后将这两个字节按照码表解码成相应的字符，当读取图片的时候，将两个字节拼在一起对比码表解码，码表中可能没有相应的字符，就会将此二进制数据标记为未知字符，在写入的时候，会将未知字符丢掉，所以图片拷贝不成功因为原图片和你拷贝的“图片”在计算机中的字节都是不一样的拷贝的“图片”丢失了很多 **解码后**被标记为“未知字符”的**字节**举个例子：一个图片在计算机中存储的字节是：-121，34，124，53，-65，-43，1....使用字节流读取的时候，一次读取一个字节，会原封不动的读取出来：-121，34，124，53，-65，-43，1....但是当使用字符流读取的时候，一次读两个字节-12134，12453....然后将每次读取到的两个字节对照系统码表解码成相应的字符，但是码表中可能没有相应的字符；例如没有和-12134对应的字符，就会将此二进制数据标记为未知字符(假设标记为￥)；在写入的时候，就会将￥字符给丢掉，所以**最后实际写入的数据为**124，53，-65，-43，1....这样拷贝自然就失败了</code></pre><h2 id="关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接"><a href="#关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接" class="headerlink" title="关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接"></a>关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接</h2><pre><code>**最后**：字符流因为解码编码等原因，比字节流慢很多字符流一般用于传输纯文本文件，尤其是中文文档，不能用于视频，图片等传输图片等视频音频文件要用字节流</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> 乱码 </tag>
            
            <tag> 字符流/字节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树镜像对称</title>
      <link href="/2019/09/07/LeetCode-%E7%AC%AC101%E9%A2%98/"/>
      <url>/2019/09/07/LeetCode-%E7%AC%AC101%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>难度–简单</strong><br>题目<br><img src="https://img-blog.csdnimg.cn/2019081919202426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p><strong>分析：</strong><br>    通过题目可以知道，这个树镜像对称，那么这棵树关于根节点这条线对称<br>    就是说，将它所有的左子树变成右子树，所有右子树变成左子树，它是不变的</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><pre><code>//这里直接传递tree根节点的左右子树会比pre(TreeNode tree,TreeNode tree)好，因为减少一层递归，LeetCode速度直接//快1ms，亲测1、pre(TreeNode tree.left,TreeNode tree.right)        2、如果A.val==B.val    --&gt;return true                3、如果A==null&amp;&amp;B==null    --&gt;return true4、如果A和B不同时为空，说明树是不对称的        --&gt;return false5、遍历A的左子树和B的右子树        //pre(A.left,B.right)6、遍历A的右子树和A的左子树        //pre(A.right,B.left)</code></pre><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>使用队列，比较容易理解，直接上代码(LeetCode官方题解)<br><img src="https://img-blog.csdnimg.cn/20190819195622590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 迭代法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/07/hello-world/"/>
      <url>/2019/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
