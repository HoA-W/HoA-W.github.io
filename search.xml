<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java编程思想之final和多态]]></title>
    <url>%2F2019%2F10%2F13%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8Bfinal%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态是Java语言面向对象的三大特征之一，也是Java很有特色的部分。这里对于多态的基本知识不做赘述，主要关注多态的一些细节知识。 final关键字final通常指的是”这是不可变的”，它可以用来修饰数据、方法、类，下面就分别谈谈这三种用法 final数据 final修饰基本数据类型表示该变量不可改变，在对这个常量定义的时候，必须对其进行赋值。一个既是final又是static的字段只占据一块不可改变的空间，通常被称为编译期常量。 final修饰对象引用表示该对象引用不能再指向其他的对象，即引用指向不可变，但是对象自身数据却是可以改变的。 final数据的初始化对于final字段(成员变量)，要么在定义时初始化，要么在构造器中对其进行初始化。这保证了final字段在使用前总被初始化 final参数Java允许在方法的参数列表中以声明的方式将参数指明为final，这就表示无法在方法中改变参数的值或参数引用所指向的对象12345public static void f(final int i) &#123; //无法对i重新赋值 //i = 0; System.out.println(i); &#125; final方法使用final方法主要是为了把方法锁定，以防止任何继承类修改它的含义，即确保在继承中使方法的行为保持不变，且不会被覆盖 final和private关键字类中所有的private关键字都隐式的指定为final。因为你无法取用private方法，自然也就无法覆盖它。对于final和private，稍后会在多态提到 final类当一个类整体定义为final时，该类就不可被继承，但是final类的字段可以不是final。对于final类中的方法，因为final类是不可被继承的，因此final类的所有方法都不能被覆盖，因此这些方法都隐式的被指定为final。 多态Java中除了static和final方法(private属于final方法)，其他所有方法都是后期绑定。由于static和final方法在编译期进行了解析，那么也就不存在多态，因此可以得出结论：static、private、final修饰的方法不存在多态。 static方法是属于类的方法，对于所有的对象不会有不同的行为 final方法和private方法不能被重写覆盖，自然也就不会产生多态了 不能覆盖私有方法下面一段代码123456789101112131415161718192021class BB extends PrivateTest&#123; public void show() &#123; System.out.println(&quot;privateOverride&quot;); &#125;&#125;public class PrivateTest &#123; private void show() &#123; System.out.println(&quot;private f()&quot;); &#125; public static void main(String[] args) &#123; PrivateTest p = new BB(); p.show(); BB b=new BB(); b.show(); &#125;&#125;============Output：private f()privateOverride 测试可以看出，private方法并没有被覆盖，即父类的private修饰的show()方法对子类是屏蔽的，子类的show()方法相当于是一个全新的方法。 不能覆盖字段下面一段代码123456789101112131415161718192021222324252627282930313233class Div extends FinalField&#123; public int field = 1; public int getField() &#123; return field; &#125;&#125;public class FinalField &#123; public int field = 0; public int getField() &#123; return field; &#125; public static void main(String[] args) &#123; FinalField f = new Div(); //父类的field字段 System.out.println(f.field); //子类的getField方法，返回子类的field字段 System.out.println(f.getField()); Div d=new Div(); //子类的field字段 System.out.println(d.field); //子类的getField方法 System.out.println(d.getField()); &#125;&#125;==============Output：0111 当Div对象(子类对象)向上转型为父类对象时，任何字段访问操作都将由编译器解析，因此不是多态的。可以这么理解，在子类对象中，为父类和子类的field字段分配了两块不同的空间。所以在使用时，不建议给父类和子类字段取相同的名字。 构造器内部的多态下面一段代码12345678910111213141516171819202122232425262728293031323334353637383940class AAA &#123; void draw() &#123; System.out.println(&quot;father.draw()&quot;); &#125; AAA() &#123; System.out.println(&quot;father.draw() before&quot;); //父类构造器调用了draw()方法 draw(); System.out.println(&quot;father.draw() after&quot;); &#125;&#125;class BBB extends AAA&#123; private int i = 1; BBB(int i) &#123; //子类构造器首先执行父类构造器 this.i = i; System.out.println(&quot;BBB+&quot;+i); &#125; void draw() &#123; System.out.println(&quot;son.draw():&quot; + i); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; BBB b = new BBB(5); &#125;&#125;===============Output：father.draw() beforeson.draw():0father.draw() afterBBB+5 在上面这段测试中，子类BBB重写了父类的draw方法。在创建子类对象时，会先执行父类的构造器。那么在父类构造器中调用的肯定是子类的draw方法(多态)，这没有问题。但是我们在创建子类对象时期望的是son.draw():5而不是son.draw():0，因为我们传递的i的参数为i=5，这就出现了错误。这是因为，在所有代码执行之前，虚拟机会将分配给对象的空间初始化成二进制0(JVM虚拟机中讲到过)，而父类构造器中执行draw方法时，子类对i的赋值还没有进行，此时i仍是初始化的0，这样就出现了问题。]]></content>
      <categories>
        <category>Java编程思想</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想之复用类]]></title>
    <url>%2F2019%2F10%2F12%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%A4%8D%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[这次主要介绍一下访问权限修饰符的一些细节和复用类的几种方法 访问权限控制我们都知道，Java中有四种访问权限修饰符，它们从大到小依次为public-&gt;protected-&gt;包访问权限(没有关键字)-&gt;private。 为什么要设置访问权限控制？当你编写一个代码给别人用的时候(例如写一个类库，后面假设就是类库)，你可能会发现类库中的某些代码或者方法有更好的实现方式，因此你可能需要对代码进行反复修改。举个例子，JDK7中的HashMap使用的是数据+链表实现，后来发现链表较长时效率不高，因此就改成了数组+链表+红黑树实现。但是你在修改代码的过程中，你需要确保使用你类库的人不会因为你改动的这些代码而受到影响。这很容易理解，别人可能正在用你的一些方法，而你把这个方法删掉了，那么别人的代码就用不了了。这时候，你就需要确认那些地方是类库使用者用不到的，那些地方是使用者正在使用的。因此Java就提供了访问权限控制，供类库开发人员向使用者指明哪些是可用的，哪些是不可用的。这样就很容易的知道你能够改动哪些部分而不会影响别人的使用。 总的来说，控制对成员的访问权想有两个原因 1. 为了使用户不要触碰那些它们不该触碰的部分，这些部分对类的内部操作是必要的，但是并不属于使用者所需要接口的一部分 2. 也是最重要的，为了让类库设计者可以更改类的内部工作方式而不必担心这样会对使用者产生重大影响 复用类 组合语法(has-a关系)实现很简单，只需要在新的类中产生现有类的对象，由于新的类是由现有类的对象组成，所以这种方法成为组合。例如 12345678class ClassTest&#123;&#125;public class combimation &#123; //在新类中产生ClassTest类对象和String类对象 private ClassTest c = new ClassTest(); private String s = &quot;abc&quot;;&#125; 继承语法(is-a关系)子类继承父类时，会自动得到父类所有的字段和方法(即得到父类所有的部分)，这里也包括private修饰的字段和方法，只是子类不能够直接访问这些private字段和方法。但是可以通过反射来访问。 初始化父类当创建一个子类对象时，该子类对象包含了一个父类的子对象，这个子对象和你直接用父类创建的对象是一摸一样的。两者的区别在于直接用父类创建的对象在外部，而子对象被包裹在子类对象的内部。因此，在初始化子类对象时，对子类对象中的父类子对象的初始化是至关重要的。即在子类构造器中调用基类构造器来执行对子对象的初始化，如果没有写，编译器会自动在子类构造器第一行加上对父类无参构造器的调用(super())。 注意：在构造器中，super和this关键字不能同时使用，因为两者都必须位于第一行。但是如果只写this来调用子类其他构造方法，编译器会自动添加对父类无参构造方法的调用。 12345678910111213141516171819202122class ClassTest&#123; ClassTest() &#123; System.out.println(&quot;父类构造器&quot;); &#125;&#125;class ClassSon extends ClassTest&#123; ClassSon() &#123; System.out.println(&quot;子类构造器&quot;); &#125; ClassSon(int i) &#123;// super(); 同时写super和this会编译报错 this(); //只写一个this，编译器会隐式的添加对父类无参构造方法的调用// super(); &#125;&#125;=============Output：父类构造器子类构造器]]></content>
      <categories>
        <category>Java编程思想</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想之初始化与清理]]></title>
    <url>%2F2019%2F10%2F12%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86%2F</url>
    <content type="text"><![CDATA[为了巩固基础，特意找来了”Java圣经”之称的《Java编程思想》(第四版)来看，准备一边学习一边做笔记，虽然会慢一点，但是感觉会扎实一点。 方法重载方法重载以及其底层原理在前面已经介绍过，就不多说。只需要记住，区分重载方法的规则很简单：每个重载方法都必须有一个独一无二的参数类型列表。 涉及基本类型的重载基本类型能从一个”较小”的类型自动提升至一个”较大的类型”。即byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double。对于char类型，会自动提升至int类型而不是short类型如果传递的实际参数大于方法要求的参数，就必须进行显式类型转换，否则编译不通过。 在构造器中调用构造器一个类有多个不同的构造器，如果想要在一个构造器中调用另外一个构造器，可以使用this(通过传递参数调用不同的构造器)。但是，this()部分必须位于构造器的第一行，这也就意味着尽管可以用this调用以恶搞构造器，但是只能调用一个。并且，除了构造器外，不能在任何其他方法中调用构造器。 12345678910111213public class initTest &#123; public initTest() &#123; this(10); //this代码必须位于第一行 this(1, 9); //只能调用一次 &#125; public initTest(int i) &#123; &#125; public initTest(int a, int b) &#123; &#125;&#125; 成员初始化初始化顺序： 父类静态部分(静态代码块和静态成员变量初始化顺序取决于代码上的顺序) 子类静态部分(静态代码块和静态成员变量初始化顺序取决于代码上的顺序) 父类非静态代码块和父类成员变量(初始化顺序取决于代码上的顺序) 父类构造方法 子类非静态代码块和子类成员变量(初始化顺序取决于代码上的顺序) 子类构造方法 类是在其任何static成员被访问时加载的(构造器是隐式的static)，静态变量和静态代码块只有在第一次创建对象时初始化一次。这是因为静态部分在类加载过程中进行初始化(前面介绍过)，而类只加载一次，因此静态部分也就只初始化一次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class staticfield&#123; public staticfield(String s) &#123; System.out.println(s); &#125;&#125;class Father&#123; static &#123; System.out.println(&quot;父类静态代码块&quot;); &#125; private static staticfield s=new staticfield(&quot;父类静态变量&quot;); public Father() &#123; System.out.println(&quot;Father 构造方法&quot;); &#125; &#123; System.out.println(&quot;Father 普通代码块&quot;); &#125; private staticfield f=new staticfield(&quot;父类成员变量&quot;);&#125;class Son extends Father&#123; private static staticfield s=new staticfield(&quot;子类静态变量&quot;); static &#123; System.out.println(&quot;子类静态代码块&quot;); &#125; public Son() &#123; System.out.println(&quot;Son 构造方法&quot;); &#125; private staticfield f=new staticfield(&quot;子类成员变量&quot;); &#123; System.out.println(&quot;Son 普通代码块&quot;); &#125;&#125;public class staticinit &#123; public static void main(String[] args) &#123; Son s=new Son(); &#125;&#125;=================Output：父类静态代码块父类静态变量子类静态变量子类静态代码块Father 普通代码块父类成员变量Father 构造方法子类成员变量Son 普通代码块Son 构造方法]]></content>
      <categories>
        <category>Java编程思想</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写简单ArrayList集合]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95ArrayList%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[ArrayList集合是Java中最常用的集合类之一，是一个能够扩容的集合，它的底层维护的是一个数组。闲来无事，今天就手写一个简单地ArrayList集合吧。 实现功能 可以自动进行扩容，并允许回收老数组 实现get()和set方法 提供size()、isEmpty()和clear()方法以及remove()方法、两种不同的add()方法 能够使用迭代器Iterator 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class MyArrayList&lt;T&gt; implements Iterable&lt;T&gt;&#123; //初始容量，默认为10 private final int DEFAYLT_VALUE = 10; //集合中元素个数 private int size; //底层数组 private T[] Array; /** * 构造方法 */ public MyArrayList() &#123; //无参构造方法，默认创建大小为10的集合 grow(10); &#125; /** * 清空集合 */ public void clear() &#123; size=0; grow(DEFAYLT_VALUE); &#125; /** * 获取元素个数 * @return */ public int size() &#123; return size; &#125; /** * 判断是否为空 * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 获取指定元素 * @param index * @return */ public T get(int index) &#123; //判断参数正确性 if (index &lt; 0 || index &gt;= size) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return Array[index]; &#125; /** * 修改指定元素 * @param index * @param newValue */ public void set(int index, T newValue) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; Array[index] = newValue; &#125; /** * 添加方法 * @param value */ public void add(T value) &#123; //默认将元素添加到末尾 add(size, value); &#125; /** * 添加方法 * @param index * @param value */ public void add(int index, T value) &#123; //如果参数小于0，默认插到头部 if (index &lt; 0) &#123; index = 0; &#125; //如果参数大于当前集合中元素个数，默认插到尾部 if (index &gt;= size) &#123; index = size; &#125; //如果集合满，那么就以2倍扩容 //+1是为了防止出现0*2==0的情况 if (size == Array.length) &#123; grow(Array.length * 2 + 1); &#125; for (int i = size; i &gt; index; i--) &#123; Array[i] = Array[i - 1]; &#125; Array[index] = value; size++; &#125; public T remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; T removeEle = Array[index]; for (int i = index; i &lt; size; i++) &#123; Array[i] = Array[i + 1]; &#125; size--; return removeEle; &#125; /** * 数组扩容 * @param newSize */ private void grow(int newSize) &#123; if (newSize &lt; size) &#123; return; &#125; T[] oldArr = Array; Array = (T[]) new Object[newSize]; for (int i = 0; i &lt; size; i++) &#123; Array[i] = oldArr[i]; &#125; &#125; //由于容器实现了Iterable接口，所以要重写该方法，返回一个迭代器 @Override public Iterator&lt;T&gt; iterator() &#123; return new ArrayListIterator(); &#125; //该类实现了Iterator接口，重写hasNext()、next()、remove()方法 private class ArrayListIterator implements Iterator&lt;T&gt; &#123; private int cur=0; @Override public boolean hasNext() &#123; return cur &lt; size(); &#125; @Override public T next() &#123; if (!hasNext()) &#123; throw new NoSuchElementException(); &#125; return Array[cur++]; &#125; @Override public void remove() &#123; MyArrayList.this.remove(--cur); &#125; &#125;&#125; 这样，一个极其简化的ArrayList集合就写出来了。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序列和问题]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：给定一个数组，在数组所有的子序列中找到和最大的子序列。我将用4中解法来对该题进行求解 暴力求解 算法思想思路很简单，遍历数组所有的子序列，对每个子序列进行求和，找到最大的和并返回 代码实现 1234567891011121314151617181920212223/** * 暴力求解 * @param arr * @return */public static int maxSubSum(int[] arr) &#123; int maxsum=0; //遍历以数组中所有元素开头的子序列 for (int i = 0; i &lt; arr.length; i++) &#123; //对于每个元素，以该元素开头的所有长度序列都要计算一次 for (int j = i; j &lt; arr.length; j++) &#123; int thissum = 0; //计算序列和 for (int k = i; k &lt;= j; k++) &#123; thissum += arr[k]; &#125; if (maxsum &lt; thissum) &#123; maxsum = thissum; &#125; &#125; &#125; return maxsum;&#125; 时间复杂度三重循环，所以时间复杂度为O(N3) 优化暴力求解 算法思想我们需要知道，f(k+1)=k+f(k)，即对于一个子序列，该子序列的和，等于它前一个子序列的和加上一个元素得到。借此可以消除一层循环 代码实现 1234567891011121314151617181920/** * 优化暴力解法 * @param arr * @return */public static int maxSubSum1(int[] arr) &#123; int maxsum=0; //同样的，遍历以每个元素开头的序列 for (int i = 0; i &lt; arr.length; i++) &#123; int thissum = 0; //找到以arr[i]开头的所有序列中最大和序列 for (int j = 0; j &lt; arr.length; j++) &#123; thissum += arr[j]; if (maxsum &lt; thissum) &#123; maxsum = thissum; &#125; &#125; &#125; return maxsum;&#125; 时间复杂度双重循环，时间复杂度为O(N2) 分治算法 算法思想分治的思想就是把问题分成两个大致相等的子问题，然后递归对它们进行求解这就是”分”；”治”阶段将两个子问题的解修补到一起并可能再做一些少量步骤的附加工作，最后得到整个问题的解。对于这个题，最大子序列可能在三处出现 该子序列全部位于数组的左边 改子序列全部位于数组的右边 该子序列跨越数组中部，即一部分在左边一部分在右边 因此我们可以进行分治递归求解 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 分治算法 * @param arr * @param left 初始值为0 * @param right 初始值为arr.length-1 * @return */public static int maxSubRec(int[] arr, int left, int right) &#123; //递归出口，当左边界等于右边界时只有一个数，直接返回 if (left == right) &#123; return arr[left]; &#125; int center = (left + right) / 2; //左递归，求出数组左边部分最大子序列 int leftsum = maxSubRec(arr, left, center); //右递归，求出数组右边部分最大子序列 int rightsum = maxSubRec(arr, center + 1, right); //求出跨越数组中部的子序列左边部分的最大值 int leftbordersum = arr[center]; int maxleftborder = arr[center]; for (int i = center - 1; i &gt;= left; i--) &#123; maxleftborder += arr[i]; if (leftbordersum &lt; maxleftborder) &#123; leftbordersum = maxleftborder; &#125; &#125; //求出跨越数组中部的子序列右边部分的最大值 int rightbordersum = arr[center + 1]; int maxrightborder = arr[center + 1]; for (int i = center +2; i &lt;= right; i++) &#123; maxrightborder += arr[i]; if (rightbordersum &lt; maxrightborder) &#123; rightbordersum = maxrightborder; &#125; &#125; //leftbordersum+rightbordersum即为数组中间部分的最大值 //返回三者最大值，即为最大子序列和 return Math.max(Math.max(leftsum, rightsum), leftbordersum + rightbordersum);&#125; 时间复杂度O(NlogN) 动态规划我们需要知道，负数不可能是最大子序列的前缀，这不难理解，因为一个负数对于序列和没有任何增益效果反而会使得序列和变小。那么可以推广的到任何负序列也不可能是最大子序列的前缀。由此可以得到动态规划解法 123456789101112131415161718192021222324/** * 动态规划 * 时间复杂度：O(n) * @param arr * @return */public static int maxSubSumdyn(int[] arr) &#123; int maxsum=0; int thissum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; thissum += arr[i]; //当前最大子序列和小于当先序列和时，更新最大子序列和 if (maxsum &lt; thissum) &#123; maxsum = thissum; &#125; //当thissum&lt;0时，说明当前子序列和为负，丢弃该子序列 else if (thissum &lt; 0) &#123; thissum = 0; &#125; &#125; return maxsum;&#125;//该算法中加了一个可以得到最大子序列左右边界的实现 时间复杂度很明显的。只有一重循环，复杂度为O(N)，是线性的 四种解法，动态规划法最优，个人感觉分治算法较为考验细节部分]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下之计算机网络和因特网-运输层]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[运输层位于应用层和网络层之间，是分层网络体系结构的重要部分。该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。其中两个运输层协议TCP和UDP是本次介绍的重点。 概述和运输层服务运输层介绍运输层协议为运行在不同主机上的应用进程提供了逻辑通信功能。运输层协议是在端系统中而不是在路由器中实现的。 在发送端，运输层将从应用程序接收到的报文转换成运输层分组(报文段) 实现的方法是将应用报文划分为较小的块，并为每块加上一个运输层首部从而生成运输层报文段 然后，在发送端系统中，运输层将这些报文段传递到网络层，网络层将其封装为网络层分组(数据报)并向目的地发送 在接收端，网络层从数据报中提取运输层报文段，并将该报文段上交给运输层 运输层则处理接收到的报文段，最后将其中的数据交给应用程序 通过上述过程可以明确：网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的运输层报文段的字段。事实上网络路由器并没有实现运输层协议。 运输层和网络层的关系 在协议栈中，运输层位于网络层上面，网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信 在端系统中，运输层协议将来自应用进程的报文移动到网络边缘(网络层)，反之亦然。但对有关这些报文在网络核心如何移动不做任何规定。中间路由器既不处理也不识别运输层加载应用层报文上的任何信息。 运输层能够提供的服务常常受制于网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供延时或带宽保证的话，那么运输层协议也就无法为进程之间发送的应用程序提供延时和带宽保证。 然而，即使底层网络协议不能再网络层提供相应的服务，运输层协议也能提供某些服务。例如，网络层IP协议是不可靠的，然而应用层协议TCP却是可靠的传输协议。 因特网运输层概述因特网运输层为应用层提供两种不同的运输层协议 UDP协议，它提供了一种无连接的、不可靠的的服务 TCP协议，提供了一种可靠的、面向连接的服务 在对UDP和TCP进行介绍之前，先简要介绍一下因特网网络层，因特网网络层协议中有一个IP协议(网际协议)，IP协议为主机提供了逻辑通信。IP协议的服务模型是尽力而为交付服务。也就是说，IP尽它最大的努力在通信主机之间交付数据，但它并不做任何保证。他不确保报文段的交付、不保证报文段的按序交付，不保证报文段中数据的完整性(可以理解为三无产品…)。即IP为不可靠服务。初步了解了IP服务模型之后，来总结一下TCP和UDP所提供的服务模型 TCP和UDP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。 将主机间的交付扩展到进程间的交付被称为运输层的多路复用和多路分解 UDP和TCP还可以通过在其报文段首部中包括差错检查字段来提供完整性检查 以上两种服务是最低限度的运输层服务，同时也是UDP仅能提供的两种服务。 UDP和IP一样，UDP提供了是一种不可靠服务(不止一次提到过)，它不能保证数据能够完整的从一个进程发送到另外一个进程。 TCPTCP为应用程序提供了几种附加服务 可靠数据传输通过使用流量控制、序号、确认和定时器TCP能够确保正确的、有序的将数据交付给接收进程(后面将会具体说到) 拥塞控制服务前面说到过，该服务是一种提供给因特网的服务，它防止任何一条TCP连接用过多的流量来淹没通信主机之间的链路和交换设备。(后面会着重介绍) 多路分解和多路复用多路复用和多路分解，即将网络层提供的主机间的交付服务扩展到运行在主机上的进程间的交付服务。在发送主机中，发送主机将应用层报文推进套接字，在套接字中为应用层报文加上运输层报文首部字段形成运输层报文段，然后将报文段交付给运输层。同样的在接收主机中，运输层实际上并没有直接将数据交付给进程，而是将数据交付给中间的套接字。 多路分解将运输层报文段中的数据交付到正确的套接字 多路复用在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(用于后面的多路分解)从而生成报文段，然后将报文段传递到网络层。 无连接的多路复用和多路分解如下图在主机A(客户主机)和主机B(服务主机)中各有3个进程，假设每个进程分配了一个套接字(实际上一个进程可能分配多个)。现在A主机的进程1(端口号为7777)，要向B主机上的进程1(端口号为4567)发送一个应用层报文 将应用层报文推进进程1对应的套接字中，形成如图所示的应用层报文段，该报文段中有这样两个字段。然后将该报文段交付给运输层 目的端口号发送进程的端口号 源端口号接受进程的端口号 运输层将接收到的报文段传递给网络层 网络层将接收到的报文段封装为IP数据报，并尽力的交付给B主机(目的主机)。 主机B有多个进程，每个进程都有一个UDP套接字和端口号，当报文段从应用层到达时，主机B通过检查该报文段中的目的端口号，将报文段定向(分解)到对应的套接字中。在本例中，报文段的目的端口号为4567，那么最终会被交付给B主机的进程1套接字 套接字将报文段数据取出并交付给B中的接收进程1。 以上就是无连接的多路分解和多路复用 注意：一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。因此，如果两个UDP报文段有不同的源IP地址或源端口号，但是具有相同的目的IP地址和目的端口号，那么这两个报文段会被定向到同一个目的套接字(目的进程)如下图所示 面向连接的多路复用和多路分解前面说过，UDP的套接字是由一个二元组标识，而TCP的套接字是由一个四元组标识(源IP地址，源端口号，目的IP地址，目的端口号)来标识的。因此，当一个TCP报文段到达一台主机时，该主机使用4个值来将报文段定向(分解)到相应的套接字。和UDP不同的是，两个具有不同的源IP地址或源端口号的TCP报文段将被定向到两个不同的套接字。如图所示 报文段中源端口号的作用：假设A向B发送数据，报文段中的源端口号就是运行在A上的进程的端口号。当B要向A发送数据时，B发送的报文段的目的端口号就从这里取值。 无连接运输：UDPUDP做了运输协议能够做的最少工作。UDP从应用进程得到数据，附上用于多路复用/分解的源和目的端口号，以及两个其他的小字段形成了UDP报文段。然后将报文段交付给网络层。其中，使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有进行握手，正因为如此，UDP被称为无连接运输协议。我们前面说过的DNS应用层协议就是基于UDP运输协议的。当一台主机的DNS应用程序想要进行以恶搞查询时，它构造一个DNS查询报文并将其交给UDP。UDP为此报文添加首部字段封装为UDP报文段并交付给网络层。 UDP的优点 采用UDP时，只要应用进程将数据传递给UDP，UDP就会将数据封装成UDP报文段并立即交付给网络层。而TCP并非如此，TCP有一个拥塞控制机制，当源和目的主机间的一条或多条通信链路变得极为拥塞时来遏制TCP发送方。这样会导致报文段的延时发送。 无需建立连接：TCP在开始数据传输之前会经历三次握手。而UDP却并不需要任何准备即可进行数据传输。因此UDP不会引入建立连接的时延。这也是DNS建立在UDP而非TCP上的原因 无连接状态：TCP需要在端系统中维护连接状态。该连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号参数。而对于UDP而言，不需要维护连接状态，也不需要跟踪这些参数 分组首部开销小：每个TCP报文段首部为20字节，而UDP报文段首部只有8个字节。 另外，虽然UDP是不可靠的数据传输协议，但这并不意味着使用UDP的应用不能实现可靠数据传输，可以通过在应用程序自身建立可靠性机制来完成。例如谷歌的Chrome浏览器使用的QUIC协议在UDP之上的应用层协议中是西安了可靠性。 UDP报文段的结构如图，一个UDP报文段的结构及其首部字段的作用： UDP检验和UDP提供了差错检验功能。它的检验和字段用于确定当UDP报文段从源到目的地移动时，其中的bit是否发生了变化。发送方的UDP对报文段中所有16bit字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果放在UDP报文段中的检验和字段中。例如假定有3个16bit的字 1234567891011121314151617180110 0110 0110 00000101 0101 0101 0101 1000 1111 0000 1100前两个16bit字的和：0110 0110 0110 00000101 0101 0101 0101 ————————————————————1011 1011 1011 0101再加上第三个16bit字1011 1011 1011 01011000 1111 0000 1100————————————————————(在这次加法中有溢出，它要被回卷)0100 1010 1100 0010将该结果进行反码运算得到1011 0101 0011 1101==&gt;这就是检验和 在接收方，将全部的4个16bit字(包括检验和)加在一起。如果该UDP报文段没有差错，那么在接收方的和应该是1111 1111 1111 1111。 可靠数据传输原理《计算机网络自顶向下方法》p134-144，转换图很多很详细，就不赘述了。归纳一下可靠数据传输协议的要点 检验和用于判断报文段是否有差错，如果有差错则重传 序号 定时器当发生丢包或者接收方确认超时时进行重传 肯定和否定确认分组对检验和无误的分组返回肯定ACK确认，对有误的分组返回否定NAK确认。 流水线可靠数据传输协议rdt3.0是一个正确的可靠数据传输协议(见书p141)，但是由于他是一个停等协议，所以性能不能够令人满意。停等协议，即发送方发送一个分组后，只有等到接收方的肯定确认才能发送下一个分组，性能较低。解决的方法就是不以停等方式运行，允许发送方发送多个分组而无需等待确认。即流水线技术如图，如果要使用流水线技术，那么就不得不考虑： 每个输送中的分组(不包括重传的)必须有一个唯一的序号。 协议的发送方和接收方两端不得不缓存多个分组，对于接收方，至少应该缓存哪些已发送但没有收到接收方确认的分组，接收方也需要缓存正确接收的分组(后面会说到)。 怎样处理丢失、损坏以及延时过大(超时)的分组 回退N步(Go-Back-N，GBN)解决流水线的差错回复有两种基本方法是：回退N步和选择重传。现在就介绍一下回退N步。在回退N步协议中，允许发送发发送多个分组而不需等待确认。但是在流水线中未确认的分组数不能超过某个最大允许数N。如图，显示了发送方看到的GBK协议的序号范围。可以将分组序号范围分成4段 [0，base-1]段内的序号对应已经发送并被确认的分组(收到接收方的ACK)。 [base，nextseqnum-1]段内的序号对应已经发送但没有被确认的分组(没有收到接收方的ACK) [nextseqnum，base+N-1]段内的序号能用于立即要被发送的分组。 [base+N，~]的序号处于窗口外面，不能被分组使用 随着协议的运行，分组被确认后base向前移动，该窗口在序号空间向前滑动。因此N被称为窗口长度，GBN协议也被称为滑动窗口协议。那么问题来了，为什么要限制这些已发送但未被确认的分组数目为N而不允许这些分组无限制数目(即N无穷大)呢？后面会说到TCP的流量控制和拥塞控制机制是限制窗口长度不能为无限大的的原因。 对于GBN协议，GBN发送方必须响应三种类型的事件 上层的调用当上层调用rdt_send()时(可以理解为应用层将数据交付给GBN协议)，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。 如果窗口未满，则产生一个分组并将其发送，相应的更新变量 如果窗口已满，将数据返回上层，隐式的指示上层该窗口已满，上层可能过会儿再试。 收到一个ACK在GBN协议中，对序号n的分组采取累计确认的方式。表明接收方以正确接收序号在n之前(包括n)的所有分组。 超时事件协议的名字”回退N步”来源于出现丢失和延时过长分组时发送方的行为。当发送分组时，定时器开始计时，如果超时，则发送方重传所有已发送但还没确认的分组。 对于GBN协议，GBN接收方的动作 如果一个序号为n的分组被正确接收到，并且按序(即上一次收到的分许序号为n-1)，则接收方为分组n发送一个ACK分组，并将分组中的数据交付给上层。 在其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。 从接收方的动作可以发现，当分组k已接收并被交付时，所有序号比k小的分组必然已经接收并交付。因此说GBK使用累计确认。如图给出一个长度为4的GBN协议运行情况 向上面给出的运行情况一样，GBN协议中，接收方丢弃所有失序的分组。 优点：接收方不缓存任何失序的分组，需要维护的唯一信息就是下一个按序接收分组的序号。 缺点：丢弃一个正确分组，后续对该分组的重传可能会丢失或出错，从而导致更多的重传。 选择重传对于GBN协议，当窗口长度和带宽延时较大时，单个分组的差错会引起大量分组的重传，但是许多分组并没有重传的必要。这样会导致更大的时延。顾名思义，选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。SR接收方将确认一个正确接受的分组而不管其是否按序。失序的分组n将被缓存，直到n之前的所有分组都被收到。这时才可以将这一批分组按序交付给上层。SR发送方事件和动作 从上层收到数据。从上层收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方窗口内，则将该数据打包并发送；否则和GBN一样，返回给上层。 超时。每个分组都有自己的逻辑定时器，和GBN不同(GBN公用一个定时器)，因为超时后只能发送一个分组。 收到ACK。 如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。 如果该分组序号等于send_base(发送方基序号)，则窗口向前移动到最小的已发送但未确认分组序号处。 如果窗口移动了并且有未发送的分组序号位于窗口内，则发送这些分组。 SR接收方事件和动作 序号在[rec_base，rec_base+N-1]内的分组被正确接收。此时，收到的分组落在接收方窗口内，给发送方回一个ACK。 如果该分组以前没有收到过，缓存该分组。 如果该分组序号等于接收窗口的基序号(rec_base)，则将从该分组开始(包括该分组)的连续的缓存的分组交付给上层(例如之前收到了3，4，5，这一次收到了2，那么就将2，3，4，5一起交付给上层，并将rec_base移动到6)。 序号在[rec_base-N,rec_base+N-1]内的分组被正确收到。此时，必须产生一个ACK，即使该分组是接受方以前已经确认过的分组。因为可能虽然接收方确认了该分组，但是发送方并没有收到(ACK丢失)，如果不再次确认，这就导致发送方的send_base一直停在该分组序号处，窗口无法移动 其他情况，忽略该分组。 另外，由于分组的序号取模运算。因此窗口的长度必须小于序号空间的一半。假设序号空间为[0~3]，窗口长度为3(大于序号空间的一半) 123//有可能会出现这种情况：当收到分组0时，无法判断该分组是新的分组还是重传的分组。0，1，2，3，0，1，2，3如图8所示 面向连接的传输：TCP前面已经介绍了可靠数据传输的基本原理，现在就可以学习TCP了 TCP连接TCP在两个进程发送数据之前，这两个进程必须先相互”握手”，即它们必须相互发送一些预备报文段，以建立确保数据传输的参数。 双全工服务如果一台主机中的进程A和另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从A流向B的同时，也从B流向A。 点对点TCP连接是点对点的，即在单个接收方和单个发送方之间的连接。对于TCP而言，两个主机是一对。 TCP连接建立的大致过程 客户端首先发送一个特殊的TCP报文段，该报文段不承载数据 服务器用另一个特殊的TCP报文段来响应，该报文段不承载数据 客户端再用第三个特殊报文段作为响应，该报文段可以承载数据 建立起TCP连接后，两进程就能够互相发送数据。如图所示发送进程将数据推进套接字，TCP将数据导入TCP的发送缓存，发送缓存是三次握手期间设置的缓存之一。接下类TCP就会不时的从发送缓存中取出一块数据，并传递到网络层。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(MSS)，MSS通常根据本地发送主机发送的最大链路层帧长度(最大传输单元，MTU)来设置。设置该MSS要保证一个TCP报文段加上TCP/IP首部长度(通常40字节)将适合单个链路层帧。注意，MSS是指报文段里应用层数据的最大长度，而不是包括首部的TCP报文段的最大长度。 TCP报文段结构TCP报文段结构如图所示 目的端口号和源端口号用于多路复用和多路分解 检验和字段用于报文段的差错检验 序号字段和确认号字段被TCP发送方和接收方用来实现可靠数据传输 接收窗口字段用于流量控制，指示接收方愿意接受的字节数量 首部长度以32bit的字为单位，一般为10个字(20字节) 标志字段 ACK用于指示确认字段中的值是有效的，即该报文包含一个对已被成功接收报文段的确认 RST\SYN\FIN用于连接的建立和拆除 CWR\ECE明确拥塞通告中用到这两个字段 序号和确认号 序号TCP首部字段中最重要的两个字段。TCP把数据看成是一个有序的字节流。一个报文段的序号就是该报文段首字节的字节流编号。如图所示 确认号前面说过，TCP是双全工的，因此A在向B发送数据的同时，也许在接收B的数据。从B到达的每一个报文段中都有一个序号用于从B流向A的数据。主机A发送的报文中的确认号就是主机A期望从主机B接收到的下一个字节的序号(也就是下一个报文段的序号)。假设A已经收到了来自B的编号为0-535的所有字节，同时它打算给B发送一个报文段。那么该报文段的确认号就是A期望从B接收到的下一个字节的序号，也就是536。此外如果TCP收到了来自B的数据流0-535和900-1000。此时A到B的下一个报文段的确认号仍然是536而不是1001。即TCP只确认该流中第一个丢失的字节，所以TCP被称为提供累计确认。可靠数据传输前面说过，IP是不可靠的，TCP在IP不可靠的尽力而为服务上创建了一种可靠数据传输服务。TCP的可靠数据传输服务保证一个进程从其接收缓存中接收到的数据和发送进程发送的数据一模一样。为了简化讨论，先假设数据只从A到B，TCP发送方的动作 从应用程序接收数据从应用程序接收数据，生成具有序号seq的TCP报文段，如果定时器没有运行那么启动定时器 定时器超时重传序号最小的未收到确认的报文，重启定时器 收到ACK收到ACK，ACK的确认号为y，如果y&gt;sendBase，那么sendBase==y。其中sendBase为发送方为最早未被确认的字节序号。如果仍有未被确认的报文段，TCP还要重启定时器以上是TCP过程中两种特殊情况，还有一种情况和第二种类似，如果主机B的ACK=100和ACK=120没有超时，但是ACK=100丢失，即只有ACK=120按时到达了主机A，那么主机A不会重传任何报文，因此TCP的累计确认机制，发送方收到ACK=120后，就能够知道B已经收到了119以及之前的所有字节。 超时间隔加倍这是大多TCP实现中的一种改进，每当超时事件发生时，就像前面提到的，TCP发送方重传具有最小序号但还未被确认的报文段。但是每次TCP重传时都会将下次的超时间隔设为先前值得两倍。例如假设初始的TCP超时间隔为0.75s，那么第一次超时事件发生后，TCP重传报文段，并将超时间隔设置为1.5秒，以此类推……这样修改是因为，定时器过时很可能是因为网络拥塞引起的，分组并没有真的丢失。在拥塞的时候，如果发送方持续的重传分组，会导致拥塞更为严重，所以TCP采用超时间隔加倍的方式使延时的分组尽可能少的被重传。 快速重传前面说到的超时间隔加倍也可能存在一个问题，当一个分组真的丢失时，超时间隔过长就会导致端到端的时延，因此TCP设计了快速重传机制。TCP发送方通常可在超时事件发生之前通过冗余ACK来较好的检测到丢包的情况。冗余ACK就是对同一个报文段重复确认的ACK。如果TCP发送方接收到对相同数据的3个冗余ACK(即一共接收到4个ACK)，它就认为跟在这个已经被确认3次之后的报文段之后的报文段已经丢失(即序号为冗余ACK报文段确认号的报文段)。此时TCP进行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。 流量控制前面提到过，TCP连接的两侧主机都为该连接设置了一个缓存，当TCP接收到正确按序的字节后，就将数据放入缓存，相应的进程会从缓存中读取数据。事实上，接收方应用也许正忙于其他任务，甚至要很长时间后才去读取该数据，如果某些应用程序读取数据时相对缓慢，而发送方发送的太多太快，发送的数据很容易使得接收缓存溢出而导致数据丢失。流量控制服务就是用来消除发送方使接收方缓存溢出得可能性。TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制(即TCP报文段中接收窗口字段)。通俗的说，接收窗口是一个变量，用于给发送方一个指示–该接收方还有多少可用的缓存空间。由于TCP是双全工通信，因此连接连端各有一个接收窗口。现假设A通过TCP连接向B发送一个大文件。主机B为该连接分配了一个TCP接收缓存(用RcvBuffer表示其大小)。主机B上的进程不断地从该缓存中读取数据。我们定义一下变量 LastByteRead主机B上的进程从缓存中读取的最后一个字节的编号 LastByteRcvd从网络到达并放入B接收缓存中的数据流最后一个字节的编号。 由于TCP不允许缓存溢出，因此必须有(LastByteRcvd-LastByteRead)&lt;=RcvBuffer接收窗口用rwnd表示，根据缓存可用空间来设置：rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)如图所示主机B通过把当前的rwnd的值放入它发给主机A的报文段接收窗口字段中，通知A它在该连接的接收缓存中还有多少可用空间，开始时rwnd=RcvBuffer在主机A中，主机A跟踪两个变量，LastByteSent和LastByteAcked，这两个变量的差LastByteSent-LastByteAcked就是A发送到连接中但未被确认的数据量，通过将该差值控制在rwnd以内，就可以保证B中接收缓存不会溢出。因此，主机A在该连接的整个生命周期保证LastByteSent-LastByteAcked&lt;=rwnd。 以上的流量控制还存在一个小问题：即当主机B的接收缓存已满，使得rwnd为0。再将rwnd=0发送给A之后，假设B没有任何数据要发送给主机A，那么当B的应用进程将接收缓存中的数据读取完之后，主机A并不知道B的接收缓存已经有新空间了。即主机A被阻塞而不能在发送数据。为了解决这个问题，TCP规范中要求：当主机B的接收窗口rwnd=0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文中将包含一个非0的rwnd值。这样主机A就能够知道B的接收窗口有空闲空间从而继续发送数据。 TCP连接管理下面主要介绍TCP连接是如何建立和拆除的，即三次握手、四次挥手是如何进行的。 三次握手 客户端TCP首先向服务器发送一个特殊的TCP报文段。该报文段不包含数据内容，但是报文段首部的SYN字段(回顾TCP报文段结构)被置1，因此该报文段又被称为SYN报文段。另外，客户端会随机选择一个初始序号(client_isn)，放在SYN报文段的序号字段中 服务器接收到客户端的SYN报文段后，就为该TCP连接分配TCP缓存和变量，并向客户端TCP发送允许连接的报文段。这个报文段也不包含应用层数据，SYN字段也被置为1(该报文段被称为font color=red&gt;SYNACK报文段)。服务器也会选择一个初始序号sever_isn，放在该SYNACK报文段的序号字段中。另外，该SYNACK报文段的确认号字段放的是client_isn+1。这个报文段实际上表明了：我收到了你的SYN分组，该分组的初始序号为client_isn，我同意建立连接。我的序号为sever_isn。 在收到SYNACK报文段后，客户端给该TCP连接分配缓存和变量。并且向服务器发送另外一个报文段；该报文段对服务器的SYNACK报文段进行了确认(将sever_isn+1放到确认号字段中)，因为连接已经建立，因此该报文段SYN置0，并且该报文段可以携带应用层数据。 四次挥手当TCP连接结束后，主机中的资源(缓存和变量)将被释放(来自网络) 客户的应用进程要关闭此连接，那么客户TCP发送一个FIN标志位置1的FIN报文段，并进入FIN_WAIT_1状态。等待一个来自服务器对FIN报文段的ACK报文段 服务器接收到来自客户端的FIN报文段，发出确认报文段ACK，进入CLOSE_WAIT状态。此时客户端向服务器方向的连接就释放了。该连接处于半关闭状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。 客户端收到来自服务器的ACK报文段后进入FIN_WAIT_2状态，等待来自服务器的FIN报文段 处于CLOSE_WAIT状态服务器如果仍有数据要发送，就继续发送数据。当服务器将该发送的数据发送完后，发送一个FIN报文段并进入LAST_ACK状态 处于FIN_WAIT_2状态的客户端收到来自服务器的FIN报文段后，发送一个ACK报文段进行确认并进入TIME_WAIT状态，该状态持续一段时间后自动退出，之后客户端释放资源 服务器收到来自客户端的ACK之后，直接释放资源。从图上可以看出，服务器释放资源要比客户端早一些 以上就是四次挥手的过程(由于书上描述的不够详细，从网上查阅资料结合书本得出) 关于”三次握手、四次挥手”的一些问题 为什么连接时三次握手，而关闭时却需要四次回收？ 在建立连接时，服务器收到客户端的SYN报文段时，发送的是SYNACK报文段，即SYN+ACK，该报文段即包含了对客户端SYN报文段的应答也包含了自己的连接请求SYN。 在关闭连接时，当服务器收到客户端的FIN报文段后，可能还有数据没有发送完毕仍然需要发送，并不能立刻关闭。因此并不会发送一个类似于SYNACK的FINACK，而是先发送ACK报文段对客户端的FIN报文段进行确认(告诉客户端你的FIN我收到了，此时客户端到服务器方向连接关闭)，然后发送需要发送的数据，等到数据发送完毕之后，再发送自己的FIN报文段(请求关闭到客户端方向的连接)。 为什么客户端在发送完对服务器的FIN报文段的ACK后需要一个TIME_WAIT状态而不能直接关闭？这是因为，有可能该ACK在网络中丢失，而服务器没有收到来自客户端的ACK报文段，那么服务器将重新发送FIN报文段，客户端需要对该重传的FIN再次进行ACK确认。 为什么不能用两次握手？这是为了防止已失效的连接请求报文段突然又到达了服务器。 客户端向服务器发送一个请求连接的SYN报文段1，但是该报文段由于网络延时较长，导致客户端认为该报文段丢失，然后重新发送SYN报文段2 SYN报文段2成功到达了服务器，最后成功的建立了TCP连接 客户端和服务器在完成数据传输后关闭了该TCP连接。 但是问题来了，前面延时的SYN报文段1经过较长一段时间后又到达了服务器。服务器会认为这是客户端新发起的TCP连接，因此向客户端发送一个ACK报文段，如果没有第三次握手，那么连接就已经建立了，但是事实上客户端并没有任何数据要发送给服务器，因为SYN报文段1对于客户端来说是一个过期的报文段。这样就白白浪费了资源。 拥塞控制原理在介绍拥塞控制原理之前，先简要介绍一下拥塞的原因和代价 拥塞的代价 如果网络中发生拥塞，那么路由器中会形成分组队列，首先会导致延时。 当分组队列过长时，由于路由器缓存有限，进而会造成分组丢失。 由于TCP是可靠数据传输服务，因此必须对丢失的分组进行重传。 当分组在路由器中延时过长导致超时，即使分组没有丢失那么TCP发送方也会重传分组，这就会导致路由器转发不必要的重复分组。 如果一个分组经过了很多个路由器后，在之后的路由器中因为超时或者路由器缓存溢出而丢失导致发送方对该分组进行重传，那么这就意味着该分组经过的每个上游路由器所用的资源都浪费了。 TCP拥塞控制TCP使用的是端到端的拥塞控制，这是因为IP层不向端系统提供显式的网络拥塞反馈。TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其向连接发送流量的速率。如果发送方感知到从它到目的地之间没什么拥塞，就加快发送速率，反之，就抑制发送速率。那么问题来了 TCP发送方如何限制它向连接发送数据的速率呢？ TCP发送方如何感知从他到目的地之间的路径上存在拥塞呢？ 当发送方感知到拥塞时，采用什么算法来改变发送速率呢？ TCP限制向其连接发送流量的方式在前面提到过，TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口(cwnd)，它对一个TCP发送方能像网络中发送流量的速率进行了限制。一个发送方中未被确认的数据量不会超过cnwd和rnwd中的最小值，即(LastByteSent-LastByteAcked)&lt;=min{cwnd，rndw}在这里为了和流量控制区分开，我们假设接收窗口无限大(这样就不存在缓存溢出，也就不存在流量控制了)，因此在发送方未被确认的数据量就受限于cwnd，还假设发送方总是有数据要发送。这样的约束控制了发送方未被确认的数据量，间接的控制了发送方的发送速率。 TCP发送方感知网络拥塞的方式我们将TCP丢包事件定义为：要么出现超时，要么收到来自接收方的三个冗余ACK。 当出现过度拥塞时，在沿着这条路径上的一台或多台路由器缓存溢出，引发一个数据报(网络层分组，包含TCP报文段)丢失。丢失的分组接着会引起丢包事件，发送方就认为在网络中(发送方到接收方的网络路径)出现了拥塞。 当网络没有拥塞时，即没有出现丢包事件。在此情况下，TCP发送方将收到对未确认报文段的ACK。TCP将这些确认的到达作为网络正常的指示，并使用确认来增加窗口长度(发送速率)，(这不难理解，当发送方觉得网络很好的时候，理所当然的就会尝试提高发送速率)。注意，窗口增大的速率取决于ACK确认报文到达的速率。TCP使用确认来触发增大它拥塞窗口长度的被称为自计时方式。 那么TCP又是怎样确定发送速率呢？如果发送速率太快，会导致拥塞，太慢又导致带宽不能充分得到利用。TCP使用下列三种指导性原则 一个丢失的报文段意味着拥塞，因此当丢包事件发生时应当降低TCP发送方的速率 一个确认报文段(ACK报文段)意味着网络中一切顺利，因此对先前未确认的确认到达时，能够增加发送方速率 带宽检测。TCP调节其传输速率的策略是增加其速率以影响到达的ACK，除非出现丢包事件，此时才减小传输速率。该行为类似于一个要求并得到越来越多糖果的孩子，知道最后告知他不行。孩子后退一点，然后过一会儿再次开始要糖果。 概述了TCP拥塞控制后，现在开始介绍TCP拥塞控制算法细节，该算法主要包括3个部分： 慢启动 拥塞避免 快速恢复 前两种是TCP的强制部分 慢启动一条TC连接开始时，cwnd初始值同设置为一个MSS(最大传输单元)，这使得初始发送速率大约为MSS/RTT(平均往返时间)。对于TCP发送方而言，可用带宽可能远远大于该速率，因此发送方希望希望迅速找到可用带宽的数量cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。如图所示从图中可以看出，没过一个RTT，发送速率就会翻倍。因此TCP发送速率起始满，但在慢启动阶段以指数增长。那么这种指数增长什么时候结束呢？有三种方式分别对应三种情况 出现由超时指示的丢包事件时(拥塞)TCP发送方将cwnd重新置为1，将ssthresh(慢启动阈值标记)设置cwnd/2(这里的cwnd是置1之前的值)，并重新开始慢启动过程。 当cwnd&gt;=sshthresh时当cwnd一直翻倍增长，超过ssthresh时，直接进入到拥塞避免模式(后面会说到)，这是因为，在第一种情况检测到拥塞时将sshthresh设置为拥塞时cwnd的一半，当cwnd再次达到ssthresh时，如果继续翻倍，那么很有可能继续造成拥塞，因此应采取更为缓慢的增长方式，即拥塞避免模式。 快速恢复如果检测到3个冗余的ACK，这时TCP将执行快速重传，并进入快速回复模式 拥塞避免一旦进入拥塞避免，cwnd的值大约是上次拥塞值得一半，即距离拥塞并不远。因此TCP使用一种较为保守的方式增加cwnd，每个RTT将cwnd的值增加一个MSS。如何结束拥塞避免模式得线性增长呢？ 出现由超时指示的丢包事件时(拥塞)和慢启动一样，将MSS设置为1个MSS，ssthresh设置为cwnd/2，重新进入慢启动模式 收到3个冗余ACK包将ssthresh设置为cwnd/2，然后将cwnd增加3个MSS(可以理解为3个冗余ACK各增加一个)，进入快速回复模式 快速回复在此状态下，对收到的每一个冗余ACK，cwnd值增加一个MSS。如何结束拥塞避免模式得线性增长呢？ 收到对未确认报文段的ACK将cwnd设置为ssthresh值，进入到拥塞避免模式 出现由超时指示的丢包事件时(拥塞)和慢启动一样，将ssthresh设置为cwnd/2，将cwnd置为1个MSS，重新进入慢启动模式 TCP拥塞控制的状态转换如图所示我们不难发现一些规律 引起状态转换一共有四种事件，分别是 超时 窗口长度超过阈值 收到正常ACK 收到累计3个冗余ACK 当累计收到3个冗余ACK时，必定会转换到快速回复模式，并有ssthresh=cwnd/2和cwnd=ssthresh+3 MSS操作 关于运输层的简要学习就到这里，主要介绍了多路复用/分解，滑动窗口协议、选择重传、TCP的可靠数据传输、超时间隔加倍以及快速重传、流量控制和拥塞控制机制等。下次介绍网络层相关知识。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络自顶向下方法</tag>
        <tag>传输层</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法之二分查找]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找在日常生活中的应用也非常广泛，除了一般的线性查找，还有专门针对有序数组得二分查找、插值查找、斐波那契查找等查找算法。今天介绍的就是著名的二分查找算法。 算法思路二分查找要求待查找数据是有序的。每次取出数据的中间项midValue，和要查找的数searchValue相比较 如果midValue&lt;searchValue，那么就在midValue得左边继续查找 如果midValue&gt;searchValue，那么就在midValue得右边继续查找 如果midValue==searchValue，返回midValue下标。 算法使用递归实现，当left(左边界)&gt;right(有边界)时，说明数据得每一个元素都已经被访问过仍然没有找到，返回-1。 代码实现 只查找一个值，找到后就返回，无论是否有重复值 123456789101112131415161718192021222324252627282930313233/** * 二分查找 * 找到一个就返回，不管是否重复 * @param arr 待查找数组 * @param left 左边界索引，初始值为0 * @param right 右边界索引，初始值为length-1 * @param value 要查找的值 * @return 返回值得下标，没找到返回0 */public static int binarySearch(int[] arr, int left, int right, int value) &#123; //递归出口当left&gt;right时说明说明数组每一个元素都已经遍历完但是没有找到，直接返回-1 if (left &gt; right) &#123; return -1; &#125; int mid = (right + left) / 2; int midValue = arr[mid]; //向右递归 if (value &gt; midValue) &#123; return binarySearch(arr, mid + 1, right, value); &#125; //向左递归 else if (value &lt; midValue) &#123; return binarySearch(arr, left, mid - 1, value); &#125; else &#123; return mid; &#125;&#125; 查找数据中所有值为value的下标，返回一个下标集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 二分查找 * 找出所有值为value的下标 * @param arr 带查找数组 * @param left 左边界索引，初始值为0 * @param right 右边界索引，初始值为length-1 * @param value 要查找的值 * @return 值得下标集合 */public static List&lt;Integer&gt; binarySearch1(int[] arr, int left, int right, int value) &#123; //当left&gt;right时说明说明数组每一个元素都已经遍历完但是没有找到，直接返回-1 if (left &gt; right) &#123; return null; &#125; int mid = (right + left) / 2; int midValue = arr[mid]; //向右递归 if (value &gt; midValue) &#123; return binarySearch1(arr, mid + 1, right, value); &#125; //向左递归 else if (value &lt; midValue) &#123; return binarySearch1(arr, left, mid - 1, value); &#125; else &#123; //再找到mid值时不马上返回，向mid索引值的两边扫描 //将所有值为value的下标值添加到ArrayList集合中，最后返回集合 //向左查找 int goLeft=mid-1; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (left &gt; 0 &amp;&amp; arr[goLeft] == value) &#123; list.add(goLeft); goLeft--; &#125; //向右查找 while (mid &lt; arr.length &amp;&amp; arr[mid] == value) &#123; list.add(mid); mid++; &#125; return list; &#125;&#125; 插值查找请注意，当我们需要在数组{1,2,3….100}中查找1或100时，用二分会查找次数相对多一些，这时候可以用到插值查找插值查找思路也非常的简单，和二分查找唯一的区别在于mid(每次查找分界点)的选用不同。 二分查找每次都去中间的数据作为分界点即mid=left+(right-left)/2 而插值查找mid的选取是自适应的，和要查找的值findValue有关mid=left+(right-left)*{(findValue-arr[left])/(arr[right]-arr[left])} 代码实现12345678910111213141516171819202122232425/** * 插值查找 * @param arr 待查找数组 * @param left 左边界索引 * @param right 有边界索引 * @param findValue 待查找的值 * @return 数组下标，没找到返回-1 */public static int insertValueSearch(int[] arr, int left, int right, int findValue) &#123; //必须确保findValue在数组最大值和最小值中间，否则会导致数组越界 if (left &gt; right || findValue &lt; arr[left] || findValue &gt; arr[right]) &#123; return -1; &#125; int mid = left + (right - left) * (findValue - arr[left]) / (arr[right] - arr[left]); int midValue = arr[mid]; if (midValue &lt; findValue) &#123; return insertValueSearch(arr, mid + 1, right, findValue); &#125; else if (midValue &gt; findValue) &#123; return insertValueSearch(arr, left, mid - 1, findValue); &#125;else &#123; return mid; &#125;&#125; 算法分析这样一来，当要查找的数位于数据靠两边的位置时，查找次数会相对少一些。该算法适用于待查找数据较为连续时。当数不连续时有时甚至比二分查找次数更多一些。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>查找</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之基数排序]]></title>
    <url>%2F2019%2F10%2F07%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这次要介绍的是最后一种排序算法，个人觉得也是最一种神奇的排序算法、当然更是最典型的空间换时间排序算法。它就是基数排序 算法思路 首先要额外申请10个桶(一维数组，和待排序数组arr一样大)，可以用二维数组来实现。 取出arr的每个元素个位数字m，根据元素的个位数字将元素放到下标为m的桶中(例如：123个位数为3，就将123放到下标为3的桶中) 将10个桶中的数依次再放回arr数组中 取出arr的每个元素十位数字，继续进行以上操作 知道最大元素的每个位都遍历完为止。 该算法按照个、十、百位等依次将元素进行排序，最终得到有序数组。 代码实现123456789101112131415161718192021222324252627282930313233343536373839/** * 基数排序 * @param arr 待排序数组 */public static void radixSort(int[] arr) &#123; //用作桶的数组 int[][] temp = new int[10][arr.length]; //计数数组，用于记录每个桶中有多少个数 int[] count = new int[10]; //找到最大的元素 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //获取最大元素的位数，即循环次数 int maxLength = (max + &quot;&quot;).length(); for (int r = 0, i = 1; r &lt; maxLength; r++, i *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素相应位的数 int digitElement = (arr[j] / i) % 10; //放到对应的桶中 temp[digitElement][count[digitElement]++] = arr[j]; &#125; //每一轮开始将arr下标置0 int index = 0; //遍历10个桶，将桶中元素放回arr数组中 for (int k = 0; k &lt; 10; k++) &#123; int countIndex = 0; //将每个桶中的元素依次放回arr数组中 while (count[k] &gt; 0) &#123; arr[index++] = temp[k][countIndex++]; count[k]--; &#125; &#125; &#125;&#125; 分析 时间复杂度 O(n*k) 空间复杂度 O(n+k) 稳定性 基数排序是稳定的 算法速度既然说基数排序是典型的空间换时间，那么它的性能究竟如何呢？来测试一下 12345678910111213141516171819//生成了一个800w的随机数组进行排序public static void main(String[] args) &#123; //随机生成一个数组，对其进行排序 int[] arr = new int[8000000]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = random.nextInt(800000); &#125; System.out.println(&quot;====================&quot;); long start = System.currentTimeMillis(); radixSort(arr); long ends = System.currentTimeMillis(); System.out.println(&quot;插入排序共花费：&quot; + (ends - start) + &quot;毫秒&quot;);&#125;=============Output：500毫秒左右 在800w时，速度仅为快排的一半。但是由于该算法空间复杂度过高，因此在8000w时就OOM了。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下之计算机网络和因特网-应用层]]></title>
    <url>%2F2019%2F10%2F07%2F%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[应用层是五层协议中的最顶层，网络应用是计算机网络存在的理由，如果我们不能构想出来任何有用的应用，也就没必要去设计支持他们的网络协议了。接下来就介绍一些应用层的一些相关知识。 应用层协议原理开发网络应用的核心在于能够写出运行在两个不同的端系统和通过网络彼此通信的程序。例如，在WEB应用中，有两个相互通信的不同的程序：一个是运行在用于主机上的浏览器程序，另一个是运行在服务主机上的WEB服务器程序。 网络应用程序体系结构应用程序体系结构由研发者设计，规定了如何在各种端系统上组织该应用程序。有两种主流的体系结构 客户-服务器体系结构在该体系中，有一个总是打开的主机被称为服务器，它服务于来自许多被称为客户端主机的请求。该体系有两个特点 客户端和客户端不直接通信 服务器具有周知的固定的IP地址 P2P体系结构对专用服务器有最小的或者没有依赖，应用程序在间断连接的主机对直接直接通信，这些主机对称为对等方。 进程通信用操作系统的术语来说，进程通信的实际上是进程而不是程序 进程可以被认为是运行在端系统上的一个程序。 当多个进程运行在相同的端系统上时，它们使用进程通信机制相互通信。进程通信的规则由端系统上的操作系统确定。在这里，我们主要关注运行在不同端系统上的进程间通信。在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信： 发送进程生成并向网络中发送报文 接收进程接受这些报文并可能通过回送报文进行相应 客户和服务器进程网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对于每一对通信进程，我们称其中一个为客户，另一个为服务器 客户在一对进程之间的会话通信中，发起通信的进程被标识为客户 服务器在会话开始时等待联系的进程被标识为服务器 进程和计算机之间的接口前面说过，多数应用程序是由通信进程对组成，每对两个进程间相互发送报文。从一个进程到另一个进程发送报文必须通过下面的网络。进程通过一个称为套接字的软件接口像网络发送报文和从网络接收报文。 套接字是同一台主机内应用层和运输层之间的接口(关于套接字在前面一篇文章已介绍过)，又被称为应用程序和网络之间的应用程序编程接口。 进程寻址为了向特定目的地发送邮件，需要一个地址。类似的，在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，这样发送方才能通过这个地址找到接收进程。为了标识该进程，需要定义两种信息 主机的地址在因特网中，主机地址由IP地址标识。现在，只需要了解IP地址是一个32bit的数并且能唯一标识该主机。 目的主机中指定接收进程的标识符知道了主机的地址后，分组就能够到达改主机。但是，主机中运行着不止一个进程，发送进程还必须指定运行在接受主机上的接收进程。我们用目的端口号来标识进程。 发送进程通过IP地址和目的端口号，就能准确地将定位运行在目的主机上的接收进程。 可供应用程序使用的运输服务前面说了，套接字是应用程序和运输层协议之间的接口。在发送端的应用程序将报文推进该套接字，在套接字的另一侧，运输层协议负责从接收进程的套接字得到该报文。运输层协议不止一种，当开发一个应用时，要选择一种可用的运输层协议。一个运输层协议能够为调用它的应用程序提供呢？接下来将从四个方面对应用程序服务要求进行分类 可靠数据传输前面说过，分组在计算机网络中可能丢失。有时候，数据丢失会带来巨大的损失，如金融应用程序，文件传输等。为了支持这些应用，必须做一些工作以确保由应用程序的一端发送的数据正确、完全的交给另一端。如果一个列协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输。运输层协议能够潜在的想应用程序提供的一个重要服务是进程到进程的可靠数据传输服务。当一个运输层协议不提供可靠数据传输时，由进程发送的某些数据就可能到达不了接收进程。像多媒体应用如视频音乐等应用是允许少量数据丢失的。 吞吐量可用吞吐量就是发送进程能够向接收进程交付比特的速率。运输层协议能够以某种特定的速率提供确保的可用吞吐量，使用这种服务，该应用程序能够请求r bit/s的确保吞吐量，并且该运输协议能够确保可用吞吐量总是至少为r bit/s。这对一些即时应用如视频会话很有吸引力。具有吞吐量要求的应用被称为带宽敏感应用。相对的，弹性应用能够根据当时可用的带宽或多或少的利用可供使用的吞吐量，如电子邮件等。 定时运输层协议也能提供定时保证。这种服务对于交互式应用很有吸引力，在多方游戏和虚拟互动环境中，在做出动作并看到来自环境的相应之间，较长的延迟极大的影响体验。 安全性在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接受主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。这样就能够防止数据在发送的过程中被观察到。 因特网提供的运输服务上面考虑了计算机网络能够提供的通用运输服务，现在就具体介绍由因特网提供的运输层服务类型。因特网(或者说TCP/IP网络)为应用程序提供了两个运输层协议，即TCP和UDP TCPTCP服务包括面向连接和可靠数据传输服务。当某个应用程序调用TCP作为运输协议时，该应用程序就能获得来自TCP的这两种服务。 面向连接的服务在应用层数据报文开始流动之前，TCP让客户端和服务器相互交换控制层信息(握手过程)。握手阶段后，一个TCP连接就在连个进程的套接字之间建立了。这是一条双全工连接，即连接双方的进程可以在连接上同时进行报文收发。当应用程序结束报文发送时，该连接被拆除。 可靠的数据传输服务通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。 TCP协议具有拥塞控制协议，该服务不一定能贵进程带来直接好处，但能为互联网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。 UDPUDP是无连接的，提供一种不可靠数据传输服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。并且接收进程的报文也有可能是乱序到达的。 前面说了四种运输协议的服务，那么对因特网运输协议来说，TCP提供了可靠数据传输并且能通过SSL提供安全性服务(后面会说到)。然而对于定时和吞吐量，因特网协议虽然没有提供任何保证，但是却能够为时间敏感应用提供满意的服务。 应用层协议应用层协议是网络应用的一部分(很重要的一部分)。前面介绍了通过把报文发送进套接字实现网络进程间的相互通信，但是如何构造这些报文？报文中字段的含义是什么等等问题……应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了如下： 交换的报文类型，如请求报文和响应报文等 各种报文类型的语法 字段的含义 确定一个进程何时以及如何发送这些报文，对报文进行响应的规则 Web和TTTPWeb具有按需操作，当我们需要时，就能得到想要的内容。这不同于广播和电视，它们迫使用户只能收听观看它们提供的内容。 HTTP概况Web的应用层协议是超文本传输协议(Hyper Text Transfer Proyocol，即HTTP)，它是Web的核心。HTTP由两个程序实现：一个客户端程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。在介绍HTTP之前，先来了解几个Web术语 Web页面是由对象构成的，一个对象只是一个文件。诸如一个HTML文件、一个图片等等。且它们可以通过一个URL地址寻址。 URL地址每个URL地址包括两部分：存放对象的服务器主机名和对象地址。 HTTP定义了Web客户向Web服务器请求Web页面的方式以及服务器向客户传送Web页面的方式。HTTP使用TCP作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字访问TCP。客户向它的套接字发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。一旦客户向它的套接字发送了一个请求报文，该报文就脱离了客户控制并进入TCP控制。 无状态协议服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，即HTTP是一个无状态协议。同时Web服务器总是打开的并且拥有一个固定的IP地址。 非持续连接和持续连接在许多因特网应用程序中，客户和服务器在很长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。那么问题来了，每个请求/响应对是经一个单独的TCP连接发送还是所有的请求/响应对经同一个TCP连接发送呢？前面的方法被称为非持续连接，后面的被称为持续连接。 非持续连接对于非持续连接，每一次请求响应都要维持一个新的TCP连接。即一个请求/响应对对应着一个TCP连接。假设有一个Web页面包含一个HTML文件和10个png文件，那么发送该页面就要创建11个TCP连接。这种方式有一些缺点 必须为每一个请求/响应对建立和维护一个全新的TCP连接，对于每一个TCP连接，在客户端和服务器端中都要分配TCP缓冲区和保持TCP变量(后面会说到)，这给Web服务器带来了严重的负担 对于每个TCP连接的都要经历”三次握手”的过程，因此响应时间变长。 持续连接HTTP1.1使用了持续连接。服务器在发送响应后保持TCP连接打开。在相同的客户和服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条TCP连接经过一段时间间隔(可设置该间隔)仍未被使用，HTTP服务器就关闭该连接。 HTTP报文格式HTTP报文有两种：请求报文和响应报文 请求报文 请求行 方法字段：包括GET、POST等 URL字段 HTTP版本字段 请求头由一系列键值对组成(具体键值对在HTTP协议概述大致介绍过) 请求空行就是一个空行，用于分隔请求头和请求体 请求体 使用GET方法时请求体为空，此时请求参数跟在URL后面 使用POST方法时，请求参数被封装在请求体中。 响应报文和请求报文类似，响应报文也有4部分 响应行(状态行) 协议版本字段 状态码 对应状态信息 响应头同样的，由一系列键值对组成 响应空行用于分隔响应头和响应体 响应体包含了客户请求的对象。如HTML文档、jpg图片以及视频等 Web缓存Web缓存器也叫Web代理服务器。它能够代表初始服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘空间，并在存储空间中保存最近请求过的对象的副本。如图，当浏览器正在请求对象http://www.aaa.com/campas.gif时 浏览器会创建一个到Wen缓存器的TCP连接，并向Web缓存器中对象发送一个HTTP请求 Web缓存器进行检查，查看本地是否存储了该对象的副本。如果有，Web缓存器就像客户浏览器用响应报文返回该对象 如果Web缓存器中没有该对象，它就创建一个与该对象初始服务器(www.aaa.com )的TCP连接。并在这个连接上发送一个该对象的HTTP请求。在接收到该请求后，初始服务器向Web缓存器发送具有该对象的响应报文。 Web缓存器收到来自初始服务器的对象时，在本地存储空间存储一份副本，并通过客户-缓存器的TCP连接向客户的浏览器用HTTP响应报文发送该副本。 通过上面的描述可以发现，Web缓存器既是客户又是服务器。 在因特网上部署Web缓存器的原因 Web缓存器可以大大减少对客户请求的响应时间，特别是客户与服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时。 Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。减少通信量，该机构就不必增加带宽，减少了成本。 Web缓存器能够从整体上大大降低因特网上的wen流量，从而改善了所有应用的性能。 条件GET方法前面说了Web缓存的一系列好处，但是也引入了一个新的问题：即存放在缓存器中的对象副本可能是陈旧的。换句话说，保存在服务器中的对象自改副本缓存在客户上以后可能已经被修改了。好在，HTTP协议有一种机制，允许缓存器证实它的对象是新的。这就是条件GET方法。如果 请求报文中使用GET方法 并且请求报文中包含一个”If-Modified-Since”请求头字段 那么该HTTP请求就是一个条件GET请求报文。 前面说过，当缓存器将对象转发到浏览器时，也在本地缓存了该对象。重要的是，缓存器缓存对象的同时也缓存了最后修改日期。 下次再次请求该对象时，该对象仍然在缓存器中。由于该对象再这期间可能被修改，所以该浏览器发送一个条件GET执行最新检查。 该请求里面有一个If-Modified-Since字段，该字段的值，正是上次缓存的最后修改日期。该条件GET报文告诉服务器，仅当自指定日期之后该对象没有被修改过，才发送该对象。 如果没有修改过，Web服务器向缓存器发送一个响应报文(该响应报文中响应体为空)，状态行为304 Not Modified。告诉缓存器可以使用该对象 缓存器将本地缓存的对象发送给浏览器。 DNS(Domain Name System)域名系统因特网上的主机和人类一样，可以用多种方式进行标识。主机的一种标识方法是用它的主机名，也可以用IP地址进行标识 DNS提供的服务主机名是一种方便人们记忆的标识方式，而路由器则更喜欢定长的、有结构层次的IP地址。为了折中这些偏好。我们需要一种能进行主机名到IP地址转换的目录服务，这就是域名系统的主要任务。DNS是： 一个由分层的DNS服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 DNS是基于UDP协议的应用层协议，端口号为53。通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。当用户访问一个主机名时 将主机名发送给DNS应用的客户端 DNS客户端向DNS服务器发送一个包含主机名的请求 DNS客户最终会收到一份回答报文，其中包含主机名对应的IP地址 浏览器收到IP地址后，它能够向位于该IP地址的80端口的HTTP服务器进程发起一个TCP连接 从上面可以看到，DNS的使用会带来额外的网络时延，有时可能时延很长。但是幸运的是，我们想获得的IP地址通常就缓存在一个”附近”的DNS服务器中，这有助于减少DNS的网络流量和DNS平均时延。除了进行主机名到IP地址的转换以外，DNS还提供了一些其他的服务 主机别名有着复杂主机名的主机能拥有一个或多个别名。主机别名通常比主机规范名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的主机规范名以及IP地址。 负载分配DNS也用于再冗余的服务器(如冗余的Web服务器)之间进行负载分配。繁忙的站点被冗余分布在多个服务器上，每台服务器运行在不同的端系统上，都有不同的IP地址。这些IP地址集合同一个主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址集合进行响应，但在每个回答中循环这些地址次序。因为这些客户通常总时向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。 DNS工作机理概述下面主要讨论DNS的主机名到IP地址转换服务。假设运行在用户主机上的某应用程序(Web浏览器等)需要将主机名转换为IP地址。 这些应用程序将调用DNS的客户端，并指明需要被转换的主机名 用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有的DNS请求和回答报文使用UDP协议经53号端口发送 用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。 这个映射结果被传递到调用DNS的应用程序。 从用户主机上调用应用程序的角度看，DNS是一个提供简单地直接转换的黑盒子。事实上，这个黑盒子相当复杂，它由分布在全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成。 分布式、层次数据库DNS使用了大量的DNS服务器，它们以层次的方式组织，并且分布在全世界范围内。没有一台服务器拥有因特网上所有主机的映射。DNS服务器分为三种 根DNS服务器有400多个根服务器分布在全世界，用于提供TLD服务器的IP地址 顶级域DNS(TLD)服务器每一个顶级域(如com、org、net等)和所有的国家顶级域(如cn、uk等)都有TLD服务器，用于提供权威服务器的IP地址 权威DNS服务器在因特网上具有公共可访问主机(例如Web服务器、邮件服务器等)的每个组织都必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。 另外，还有一种很重要的DNS服务器，即本地服务器。它并不属于DNS服务器层次结构，但是它很重要。每个ISP都有一个本地DNS服务器，当主机和某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。主机的本地DNS服务器通常”邻近”本主机。如图请求主机如果要得到服务器主机的IP地址，假设服务器主机名为( aaa.bbb.com) 主机向本地服务器发送一个DNS查询报文，该报文含有被转换的主机名 本地服务器将该报文转发到根服务器 根服务器注意到其com前缀并向本地服务器返回负责com得TLD得IP地址列表 本地服务器再向这些TLD服务器之一发送查询报文 该TLD服务器注意到bbb.com前缀，并用权威DNS服务器的IP地址进行响应，该权威服务器是bbb.com 最后，本地服务器直接向bbb.com重发查询报文,bbb.com用aaa.bbb.com的IP地址进行响应。这样就得到了服务器主机的IP地址。 DNS缓存在上述映射中，为了得到一台主机名的映射，共发送了8份DNS报文，这无疑是增加了查询流量和查询时延。实际上，为了改善时延性能并减少DNS报文数量，DNS广泛使用了缓存技术。DNS缓存的原理很简单，在一个请求链中，当某DNS服务器接收到一个DNS回答(如包含某主机名到IP的映射)时，它能将映射缓存在本地服务器中。如果DNS服务器缓存了一台主机名/IP对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机名的权威服务器。 要注意的是，主机名和IP地址之间的映射不是永久的，DNS服务器会在一段时间后(一般设置为2天)丢弃该缓存信息 本地服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。事实上，除了少数DNS查询外，根服务器被绕过了。 DNS记录和报文DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录(Resource Record，简称RR)，RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条RR。资源记录是一个包含了{Name，Value，Type，TTL}这些字段的四元组。 TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间 Name和Value的值取决于Type Type=A那么Name是主机名，Value是该主机名对应的IP地址。即一条A类型的资源记录提供了标准主机名到IP地址的映射。 Type=NS那么Name是一个域，而Value是一个权威服务器的主机名，该权威服务器能够获取该域中主机IP地址的。 Type=CNAME则Value是一个别名为Name的主机对应的规范主机名。 Type=MX则Value是一个别名为Name的邮件服务器的规范主机名。 如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会包含一条用于该主机名的类型A记录。 如果DNS服务器不是用于主机名的权威服务器 那么该服务器将包含一条NS记录，该记录对应包含主机名的域； 它还将包含一条类型A记录，该记录提供了上面NS记录中Value字段(权威服务器主机名)的IP地址 DNS报文前面说到了DNS查询和回答报文，DNS只有这两种报文并且两种报文格式相同。 前12个字节是首部区域 标识符(16比特)用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和收到的回答 问题区域包含正在进行的查询信息，该区域包括 名字字段包含正在被查询的主机名字 类型字段指出有关名字的正被询问的问题类型，如主机地址是一个和名字相关(类型A)还是和邮件服务器相关(类型给MX) 回答区域包含了对最初请求的名字的资源记录，在回答区域可以包含多条RR，因此一个主机名能够有多个IP地址的(前面讨论的冗余Web服务器) 权威区域包含了其他权威服务器的记录 应用层大致介绍到这里就结束了，主要介绍了HTTP和DNS两个应用层协议，至于书中的P2P、SMTP等其他协议就不赘述了。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>应用层</tag>
        <tag>HTTP</tag>
        <tag>DNS</tag>
        <tag>计算机网络自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之归并排序]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说完了用递归实现的快速排序，这次介绍一下另外一种新的递归排序算法–归并排序。归并排序不仅用到了递归，更重要的是其分治的思想。 算法思路将待排序数组递归分成左右两部分，使得左右两部分数组分别有序，最后合并左右两数组得到有序的数组。对于长度为n得数组，一共只需要进行n-1次合并。以数组{8, 4, 5, 7, 1, 3, 6, 2}为例 第一次{8，4}的左右两部分合并为有序数组得到{4，8} 第二次{5，7}的左右两部分合并为有序数组得到{5，7} 第三次{4，8，5，7}的左右两部分合并为有序数组得到{4，5，7，8} 第四次{1，3}的左右两部分合并为有序数组得到{1，3} 第五次{6，2}的左右两部分合并为有序数组得到{2，6} 第六次{1，3，2，6}的左右两部分合并为有序数组得到{1，2，3，6} 最后一次{4，5，7，8，1，2，3，6}的左右两部分合并为有序数组得到{1，2，3，4，5，6，7，8}，最终得到有序数组 12345678910//对数组&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;进行排序每一轮排序后的输出初始数组[1, 2, 3, 4, 5, 6, 7, 8]第一次归并过后[#4, 8#, 5, 7, 1, 3, 6, 2]第二次归并过后[4, 8, #5, 7#, 1, 3, 6, 2]第三次归并过后[#4, 5, 7, 8#, 1, 3, 6, 2]第四次归并过后[4, 5, 7, 8, #1, 3#, 6, 2]第五次归并过后[4, 5, 7, 8, 1, 3, #2, 6#]第六次归并过后[4, 5, 7, 8, #1, 2, 3, 6#]第七次归并过后[#1, 2, 3, 4, 5, 6, 7, 8#]排序后数组[1, 2, 3, 4, 5, 6, 7, 8] 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 归并算法 * @param arr 原始数组 * @param left 左边界 * @param right 有边界 * @param temp 中间数组 */public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; //中间索引 //向左递归 mergeSort(arr, left, mid, temp); //向右递归 mergeSort(arr, mid + 1, right, temp); //调用方法合并 merge(arr, left, right, mid, temp); &#125;&#125;=======================================================================================/** * 每一次完成归并的方法 * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param right 右边索引 * @param mid 中间索引 * @param temp 中转数组 */public static void merge(int[] arr, int left, int right, int mid, int[] temp) &#123; int i = left; //初始化左边有序序列的初始索引 int j = mid + 1; //初始化右边有序序列的初始索引 int t = 0; //初始化temp数组的当前索引 //先把左右两边的数据按照规则填充到temp数组中，直到左右两边的有序序列有一方处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t++; i++; &#125;else &#123; temp[t] = arr[j]; t++; j++; &#125; &#125; //把有剩余的一边依次全部填充到temp数组中 while (i &lt;= mid) &#123; temp[t++] = arr[i++]; &#125; while (j &lt;= right) &#123; temp[t++] = arr[j++]; &#125; //将temp数组元素拷贝到arr数组中 t=0; int tempLeft = left; while (tempLeft &lt;= right) &#123; arr[tempLeft++] = temp[t++]; &#125;&#125; 分析 时间复杂度 最好情况：nlogn 最差情况：nlogn 空间复杂度 一个temp数组，所以为O(n) 稳定性 归并排序是稳定的 算法速度同前面一样，用一个大小为80000的随机数组进行测试 12345678910111213141516public static void main(String[] args) &#123; //随机生成一个数组，对其进行排序 int[] arr = new int[8000000]; int[] temp = new int[arr.length]; Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = random.nextInt(800000); &#125; System.out.println(&quot;====================&quot;); long start = System.currentTimeMillis(); mergeSort(arr, 0, arr.length - 1, temp); long ends = System.currentTimeMillis(); System.out.println(&quot;归并排序共花费：&quot; + (ends - start) + &quot;毫秒&quot;);&#125;======测试结果稳定在16-20毫秒左右]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F10%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是23种设计模式中最简单的一种。简单地说，单例模式就是整个程序中有且只有一个实例。该类负责创建自己的对象，同时确保只有一个对象。 单例模式分为两种 懒汉式线程不安全，即在使用时在进行初始化。 饿汉式线程安全，容易产生垃圾，因为类加载时就将对象初始化。 饿汉式饿汉式的实现很简单，类的实例作为该类的静态的成员属性和一个静态的public成员方法用于获取该属性，类加载时就已经生成了类的实例，调用静态方法可以获取该实例。代码如下 12345678910111213public class Singleton1 &#123; //私有化构造方法 private Singleton1() &#123; &#125; //饿汉式，类加载时就已经创建 private static Singleton1 s = new Singleton1(); //通过静态方法获取单例 public static Singleton1 getInstance() &#123; return s; &#125;&#125; 显而易见，getInstance方法里面的操作是原子性的，因此饿汉式单例模式是线程安全的 懒汉式线程不安全的实现代码如下 12345678910111213public class Singleton2 &#123; private Singleton2()&#123;&#125;; private static Singleton2 instance; //线程不安全的单例模式 public static Singleton2 getInstance() &#123; if (instance == null) &#123; instance=new Singleton2(); &#125; return instance; &#125;&#125; 由于懒汉式是线程不安全的，因此有两种实现方式 给相应部分加上同步代码块，使之变成线程安全这里用的是双重检查加锁123456789101112131415161718//双重检查加锁public class Singleton2 &#123; private Singleton2()&#123;&#125;; private static volatile Singleton2 instance; //一个线程安全的单例模式 public static Singleton2 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton2.class) &#123; if (instance == null) &#123; instance=new Singleton2(); &#125; &#125; &#125; return instance; &#125;&#125; 以上实现代码只需要在第一次实例化单例的时候会执行到同步代码部分。 利用内部类实现使用静态内部类123456789101112public class Singleton3 &#123; private Singleton3() &#123; &#125; private static class inner&#123; private static Singleton3 instance=new Singleton3(); &#125; public static Singleton3 getInstance() &#123; return inner.instance; &#125;&#125; 可以看出，在获取方法中的操作也是原子性的，因此是线程安全的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2019%2F10%2F01%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[由于计算机的存储设备与处理器的运算速度有几个数量级差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要用到的数据复制到缓存中，让运算能够快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就不用等待患难的内存读写了。 基础介绍上面说的基于高速缓存的存储交互很好的解决了处理器和内存的速度矛盾，但是又引入了新的问题：缓存一致性。在多个处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存。那么当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各自缓存数据不一致，如果发生这种情况，那同步回主内存时又以以谁为准呢？为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。 内存模型可以理解为在特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。处理器、高速缓存以及主内存间的交互关系 指令重排序为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但是并不保证程序中各个语句的执行顺序和输入代码中的顺序一致。Java虚拟机的即时编译器中也有类似的指令重排序优化。 Java内存模型(JMM)Java虚拟机规范中定义了一种Java内存模型(Java Memory Model)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致性的内存访问效果。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和内存中取出变量这样的底层细节。这里说的变量,和Java编程中所说的变量有所不同，它包括了实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，因为这两者是线程私有的。Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存(和前面说的处理器高速缓存类似)，线程的工作内存中保存了被该线程使用到的变量的主内存的拷贝副本。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成。线程、主内存以及工作内存三者关系 内存间交互关于一个变量如何从主内存拷贝到工作内存、如何从工作内存同不会主内存之类的实现细节，Java内存模型中定义了8种操作来完成，这8种操作都是原子性的。 lock(锁定)作用于主内存的变量，把变量标识为一条线程独占状态 unlock(解锁)作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定 read(读取)作用于主内存的变量，他一个变量的值从主内存传输到线程的工作内存 load(载入)作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use(使用)作用于工作内存的变量，把工作内存的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时将会执行这个操作 assign(赋值)作用于工作内存的变量，把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作 store(存储)作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write(写入)作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中 同样Java内存模型还规定了在执行上述8种操作时必须满足一下条件 不允许read和load，store和write这两对操作之一单独出现，即如果执行了read操作，那么就必须执行load(但两个操作不一定要连续执行)。即不允许一个变量从主内存读取但工作内存不接受，或者从工作内存发起回写但主内存不接受的情况。 不允许一个线程丢弃它最近的assign(赋值)操作，即变量在工作内存中改变了之后必须把该变化同步回主内存 不允许线程无原因地(没有发生过assign操作)把数据从工作内存同步回主内存 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量。也就是说，对一个变量实施use、store操作之前，必须先执行过了assign和load操作 一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值 对一个变量执行unlock之前，必须先把此变量同步回主内存中(执行store、write操作) Java指令重排序在执行过程中为了提高性能，编译器和处理器经常会对指令进行重排序，重排序分成三种类型 编译器优化的重排序，编译器在不改变单线程程序语义前提下，可以重新安排语句的执行顺序。 指令级并行的重排序，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(可以理解为指令A不用到指令B的数据)，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序，由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是在乱序执行。 从Java源码到最终实际执行的指令序列，会经过下面三种重排序 参考博客Java内存模型大致能介绍就这些，关于并发和多线程最近开始看书，有了初步的理解后逐步介绍。深入理解JVM虚拟机这本书也算是初步看完了，继续努力。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的语法糖]]></title>
    <url>%2F2019%2F09%2F30%2FJava%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[语法糖，是指在计算机中添加某种语法这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，语法糖能够增加程序的可读性。Java中常用的语法糖有泛型、变长参数、自动拆箱/装箱等。下面就介绍一下这些语法糖的原理。 泛型和类型擦除泛型时JDK1.5的新增特性，本质是参数化类型的应用。即将所操作的数据类型指定为一个参数，这种参数可以用在类、接口、方法的创建中，分别被称为泛型类、泛型接口和泛型方法。Java中的泛型被称为伪泛型，它只在Java源码中存在，在编译后的字节码文件中就已经被替换为原生类型了(裸类型)，并且在相应地方插入了强制转型代码。因此对于运行期的Java语言来说，ArrayList和ArrayList就是同一个类，所以Java中泛型实现方法被称为类型擦擦除。举一个Java泛型的例子 1234567public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;hello&quot;, &quot;你好&quot;); map.put(&quot;how are you&quot;, &quot;吃了没&quot;); System.out.println(map.get(&quot;hello&quot;)); System.out.println(map.get(&quot;how are you&quot;));&#125; 对于上面代码，编译成Class文件，然后再反编译进行反编译后，会变成下main这样 1234567public static void main(String[] args) &#123; Map map = new HashMap(); map.put(&quot;hello&quot;, &quot;你好&quot;); map.put(&quot;how are you&quot;, &quot;吃了没&quot;); System.out.println((String) map.get(&quot;hello&quot;)); System.out.println((String) map.get(&quot;how are you&quot;));&#125; 从代码可以看到，程序中所有的泛型又变回的原生类型，并且加上了强制转型。这说明，在编译后的字节码文件中是没有泛型的，即反省在编译过程中已经被擦除。既然知道了泛型的实现原理，那么看一看下面这段代码 123456789public class Test1 &#123; public static void method(List&lt;String&gt; list) &#123; System.out.println(&quot;List&lt;String&gt; list&quot;); &#125; public static void method(List&lt;Integer&gt; list) &#123; System.out.println(&quot;List&lt;Integer&gt; list&quot;); &#125;&#125; 毫无疑问，上面这段代码是无法通过编译的，这是为什么呢？因为编译期对泛型进行类型擦除后，这两个方法实际上是一模一样的，不构成重载。因此自然无法通过编译。让我们再回顾一下Signature属性，它能够存储一个方法在字节码层次上的特征签名，这个属性中保存的参数并不是原生类型，而是包括了参数化类型的信息。另外，通过Signature属性可以看出，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据还是保留了泛型信息，这也是我们能通过反射取得参数化类型的根本依据。 自动装箱、拆箱和遍历循环 自动装箱实际上调用的是包装类的valueOf()方法； 自动拆箱调用的则是包装类的xxxValue()方法。下面以Integer和int为例 1234567int i=1;//自动装箱Integer.valueOf(i)=======================Integer=new Integer(4)//自动拆箱i=Integer.intValue() 遍历循环for-each使用的则是Iterator迭代器来实现。 12345678List&lt;Integer&gt; list=new ArrayList;for(int i:list)&#123;&#125;//实际上是通过迭代器实现for(Iterator localIterator=list.iterator();localIterator.hasNext;)&#123;&#125; 使用包装类要注意两点 包装类的”==”再不遇到算术运算的情况下不会自动拆箱 包装类的”equals()方法”不处理数据转型的关系 给出下面一段测试代码 1234567891011121314151617181920public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); //true ,-128~127之间用到Integer内的缓存池 System.out.println(e == f); //false //遇到算术运算，自动拆箱 System.out.println(c == (a + b)); //true //equals不会处理数据转型 System.out.println(c.equals(a + b));//true System.out.println(g.equals(a + b));//false //遇到算术运算自动拆箱，进行数据转型 System.out.println(g == a + b); //true&#125;]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机四]]></title>
    <url>%2F2019%2F09%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[这一节主要介绍一下虚拟机是怎么执行Class文件的字节码以及《深入理解JVM虚拟机》后面一些知识，因为后面很多都不是很理解，所以结合在一起记录，如果以后再次翻看弄懂了一些，就再另外记录吧。 执行引擎是Java虚拟机最核心的组成部分之一，Java虚拟机在执行Java代码时可能会有解释执行(通过解释器执行)和编译执行(通过编译器执行)两种选择，或者两者都有。所有Java虚拟机的执行引擎都是一致的 输入过程：输入字节码文件 处理过程：字节码解析，执行相应指令 输出过程：输出执行结果 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。每一个方法从调用开始到执行完成的过程，对应着栈帧在虚拟机中从入栈到出栈的过程。栈帧中包括 方法的局部变量表 操作数栈 动态连接 方法返回地址等 另外前面说到过，在编译阶段，局部变量表和操作数栈的大小都已经确定并写在Code属性中，因此一个栈桢分配多少内存不会受到运行时数据的影响。对于执行引擎来说，只有线程栈顶的栈帧才是有效的，称为当前栈帧，与栈帧相关联的方法称为当前方法。虚拟机使用局部变量表完成参数值到参数列表的传递过程，如果是一个实例方法，那局部变量表第0位索引的Slot默认用于传递方法所属对象实例的引用，在方法中可以通过this关键字来访问这个隐含的参数。其余参数按照参数表顺序排列，占用从1开始的Slot。参数表分配完毕后再根据方法体内定义变量的顺序和作用域分配其余Slot。局部变量表的Slot是可以重用的，如果当前字节码PC计数器已经超过了方法体中的某个变量的作用域，那么该变量对应的Slot就可以交给其他变量使用。 对于类变量(sttaic)，会有两次赋值 一次是在准备阶段赋初始值 一次是在初始化阶段赋予程序设置的值因此初始化阶段不为类类变量赋值也可以直接使用。 对于局部变量，如果定义了但没有赋初始值是不能使用的。 对于类成员变量，也会有两次赋值 第一次是new指令过后，&lt; init&gt;方法执行之前，对象的字段(即成员变量)已经被赋初始化值 第二次是在&lt; init&gt;方法(实例构造器)，赋予字段程序设置的值因此对于成员变量，不赋初值也能直接使用 操作数栈和局部变量表一样，操作数栈的大小在编译后就已经确定，记录在Code属性中。操作数栈的每一个元素可以是任意的Java数据类型。当一个方法开始执行时，方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈出栈操作。Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，这里指的就是操作数栈。 动态连接每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用。前面说到，Class文件的常量池中有大量符号引用，字节码中的方法调用指令就常以常量池中指向方法的符号引用作为参数，这些符号引用 一部分会在类加载阶段或第一次使用时转换为直接引用，即静态解析 另外一部分将在每次运行期间转换为直接引用，这部分称为动态连接 方法返回地址当一个方法开始执行，有两种方式可以退出这个方法。 执行引擎遇到任意一个方法返回的字节码指令。这时可能会有返回值传递给调用该方法的方法，至于是否有返回值或者返回值类型取决于返回指令的类型。这种退出方式被称为正常完成出口。此时调用该方法的方法PC计数器的值可以作为返回地址。 方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码产生的异常(throw语句)只要在方法的方法表中内有搜索到匹配的异常处理器(即不属于Java代码中catch语句列举的异常)，就会导致方法退出。这种退出方式被称为异常完成出口。是不会给上层调用方法任何返回值的。此时，返回地址是通过异常处理器来确定的。 方法调用方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法(因为Java中重写和重载机制)，不涉及方法的执行。前面说过，一切调用在Class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址(直接引用)，这就导致Java方法调用时，需要在类加载期，甚至是运行期才能确定目标方法的直接引用。 解析在类加载的解析阶段，会将一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序运行之前就有一个确定的调用版本，并且这个调用版本在运行期间是不可变的。即编译器可知，运行期不可变，这类方法主要有两类 静态方法与类型直接关联 私有方法外部不可被访问 实例构造器 父类方法这四类方法适合在类加载阶段进行解析。这四类方法又被称为非虚方法，其他方法都是虚方法。除此之外final方法也是非虚方法。 解析调用是静态过程在编译期就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为直接引用。这时第一次的解析结果会被缓存在运行时常量池中，并将常量标识为已解析，从而避免重复解析。 分派调用可能是静态的也可能是动态的 静态分派Java具备三大特征：继承、封装和多态。分派将会揭示重写和重载在Java虚拟机中是如何实现的。来测试一下下面一段代码，然后看一看结果 123456789101112131415161718192021222324252627282930313233public class StaticDispath &#123; static abstract class Human&#123; &#125; static class Man extends Human &#123; &#125; static class Woman extends Human &#123; &#125; public void sayHello(Human human) &#123; System.out.println(&quot;Human&quot;); &#125; public void sayHello(Man human) &#123; System.out.println(&quot;Man&quot;); &#125; public void sayHello(Woman human) &#123; System.out.println(&quot;Woman&quot;); &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman=new Woman(); StaticDispath s=new StaticDispath(); s.sayHello(man); s.sayHello(woman); &#125;&#125; 执行结果有三个重载的方法，为什么会选择执行参数类型为Human的重载呢？先介绍一下两个概念 1Human man = new Man(); 上面这段代码中的”Human”被称为静态类型，new后面的”Man”被称为实际类型。 静态类型仅仅在使用时发生变化，而变量本身的静态类型不会改变，并且静态类型在编译期可知 实际类型在运行期才能确定变化的结果，编译器在编译时并不知道实际类型是什么 例如 12345678//在这里实际类型从Man变成了Woman，而静态类型仍是HunmanHuman man=new Man()man=new Woman()//这时候静态类型仅仅在使用时发生了变化，但是man和woman仍旧是Human类型。//如果这样调用，那么输出结果就是Man和Woman而不是Human了。s.sayHello((Man)man);s.sayHello((Woman)woman); 虚拟机(确切的说是编译器)在重载时通过参数的静态类型(即参数字面值)作为判定依据而不是实际类型。并且静态类型是编译期可知的，因此，在编译期Javac编译器会根据参数的静态类型选择使用哪个重载方法。所有依赖静态分派来定位方法执行版本的分派动作称为静态分派。静态分派的典型就是方法重载 动态分派同样的，还用一段代码来做测试12345678910111213141516171819202122232425262728293031public class DynamicDispatch &#123; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man=new Woman(); man.sayHello(); &#125;&#125;abstract class Human&#123; protected abstract void sayHello();&#125;class Man extends Human&#123; @Override protected void sayHello() &#123; System.out.println(&quot;man&quot;); &#125;&#125;class Woman extends Human &#123; @Override protected void sayHello() &#123; System.out.println(&quot;woman&quot;); &#125;&#125; 很简单的一段代码，用到了重写，运行结果这里显然不是根据静态类型来决定的，因为静态类型都是Human的两个变量在调用sayHello时执行了不同的方法，并且man两次调用sayHello方法输出结果不同。来看一下字节码 123416: aload_117: invokevirtual #6 // Method Human.sayHello:()V20: aload_221: invokevirtual #6 // Method Human.sayHello:()V 其中aload_1和aload_2就是将man和woman两个对象的引用入操作数栈，这两个对象是将要执行的sayHello方法的所有者。17和21行的invokevirtual是方法调用指令，从字节码角度来看，无论是指令(都是invokevirtual指令)还是参数(注释显示了参数是Human.sayHello的符号引用)都完全一样，两行指令一模一样。但是执行的结果却不同。这就要从invokevirtual的多态查找过程说起，该指令运行使得解析过程大致分为一下几个步骤 找到操作数栈顶的第一个元素指向的对象的实际类型(在这里man的实际类型是Man，woman的实际类型是Woman)，记为C。 如果在C中找到了与常量中的描述符和简单名称都相符(Human.sayHello:()V)的方法，则进行访问权限校验，如果通过返回该方法的直接引用，否则抛出异常。 否则，按照继承关系从下往上依次对C的父类进行第二步操作 如果始终没有找到，抛出异常。 从上面过程可以发现，该指令第一步就是在运行期间找到执行方法所有者的实际类型，所以两次invokevirtual虽然参数一模一样，但是却将符号引用解析到了不同的直接引用上，这就是Java重写的本质。这种运行期间根据实际类型确定具体实行哪个方法的分派过程称为动态分派。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机三]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前面已经介绍了JVM的内存布局、自动内存管理、垃圾回收以及Class文件结构，那么虚拟机又是怎么加载Class文件的？Class文件的信息进入到JVM中会不会发生变化呢？那么这次就记录一下虚拟机类加载机制。 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析以及初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 在Java中，类型的加载、连接、初始化过程都是在程序运行期间完成的，这种做法会令加载时性能开销增加一些，但是却为Java程序提供了高灵活性。例如，对于一个接口，可以等到运行时在指定其实际的实现类。可以通过类加载器在程序运行时从其他地方加载一个二进制流作为代码的一部分。 类加载时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期如下加载==&gt;连接(验证==&gt;准备==&gt;解析)==&gt;初始化==&gt;运行==&gt;使用==&gt;卸载其中验证、准备、解析三个阶段统称为连接。并且加载、验证、准备、解析、初始化这5个阶段的顺序是确定的。那么什么情况下需要执行类加载的第一个过程：加载呢？对于初始化阶段，虚拟机严格规定了有且只有5种情况必须立即对类进行初始化(初始化之前自然要先进行加载、连接操作) 遇到new、getstatic、putstatic、invokestatic这四条指令时，如果类没有进行过初始化，则需要先对类进行初始化。可以概括为一下几个方面： 使用new关键字实例化对象时 读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)时 调用一个类的静态方法时 使用java.lang.reflect包的方法进行反射调用时，如果类没有进行过初始化，则需要先对类进行初始化。 初始化一个类时，如果发现其父类还没有进行过初始化，则需先对其父类进行初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(含main方法的类)，虚拟机会先初始化这个类 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStati或REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先对类进行初始化。 上面5种场景的行为称为对一个类的主动引用。除此之外，所有引用类的方法都不会触发其初始化，称为被动引用，如： 通过子类引用父类的静态字段，子类不会被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。 通过数组来引用类，不会触发此类的初始化。 常量在编译期进入调用类的常量池，本质上讲没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。 (具体示例代码见书P211。)接口的类加载过程和类有所不同，主要体现在第3点，一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候才会初始化。 类加载过程下面说一下类加载的全过程：加载、验证、准备、解析和初始化。 加载加载时类加载过程的一个阶段，在加载阶段，虚拟机可以完成三件事 通过一个类的全限定名获取此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表此类的java.lang.Class对象，作为方法区此类各种数据的访问入口。 相比于类加载过程的其他阶段，一个非数组类的加载阶段(确切的说是加载阶段中获取类的二进制字节流的操作)是开发人员可控性最强的。因为我们可以使用系统的的引导类加载器来完成，也可以使用自定义的类加载器完成。对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类和类加载器仍有密切的关系。数组类的元素类型(去掉所有[])最终要靠类加载器去创建。一个数组类C的创建过程如下 如果数组的组件类型(去掉一对[]的类型)是引用类型，那就递归采用前面说的加载过程去加载这个组件类型，数组C将在加载组件类型的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型(如int[] a或二维数组等)，Java虚拟机将会把数组标记为与引导类加载器关联 数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那数组可见类型默认public。 加载完成后，虚拟机外部的二进制字节流就被加载进方法区中。然后在内存中实例化一个java.lang.Class对象，(对于HotSpot而言，该对象存放在方法区中) 验证加载阶段和连接阶段的部分内容是交叉进行的，如一部分字节码文件格式的验证动作。验证时连接阶段的第一步，是虚拟机对自身保护的一项重要工作。这一阶段的目的是为了确保Class文件的字节流中包含的信息符合虚拟机要求，并且不会危害虚拟机自身安全。该阶段分为四步： 文件格式验证 元数据验证 字节码验证 符号引用验证 文件格式验证验证字节码是否符合Class文件格式，并且能被当前版本虚拟机处理，可能包含一下验证点 是否以魔数”0xCAFEBABE”开头 主次版本号是否在当前虚拟机处理范围 常量池常量是否有不被支持的常量类型(检查tag标志)…. 实际上，该阶段的验证点有很多，该阶段的主要目的是保证输入的字节流能够正确的解析并存储与方法区内，格式上符合一个Java类型信息的要求。该方法是基于二进制字节流进行的，只有通过了该阶段，字节流才会进入方法区，后面的三个阶段都是基于方法区的存储结构进行，不会直接操作字节流。 元数据验证该阶段对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范，可能的验证点 该类是否有父类(除了java.lang.Object以外，所有类都应该有父类) 该类是否继承了不允许被继承的类(final类) 该类如果不是抽象类，那么是否实现了其父类/父接口的抽象方法…… 该阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。 字节码验证该阶段最为复杂，主要目的是确定程序语义是否合法、符合逻辑，该阶段对方法体进行校验分析，确保被校验的方法在运行时不会做出危害虚拟机安全的事。可能验证的点 保证跳转指令不会跳转到方法体以外的字节码指令上 保证方法体中的类型转换是有效的，例如不能把对象赋值给与他毫无继承关系、完全不相干的数据类型，这是不合法的…… 如果一个类不能通过字节码验证，那么这个类肯定有问题，但是通过了字节码验证，并不能够说明其一定安全。 符号引用验证该阶段发生在虚拟机将符号引用转化为直接引用的时，这个转化动作将在连接的第三个阶段–解析阶段发生。符号引用验证可以看作是对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验，通常需要校验以下内容 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的访问性(public、private…)是否可以被当前类访问…… 符号引用验证的目的是确保解析动作能够正常进行，如果无法通过该阶段验证，那么会抛出异常。最后，对于虚拟机类加载机制来说，验证阶段非常重要、但却不一定必要。如果所运行的全部代码都已经被反复使用和验证过，那么可以通过”-Xverify:none”参数来关闭大部分验证措施。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都在方法区分配。这里说的初始化值通常情况下是数据类型的零值。例如一个类变量private static int value=123。在准备阶段过后的初始值是0值而不是123。而将value赋值为123的操作是在初始化阶段的类构造器&lt; clinit&gt;方法执行。如果一个类字段有ConstantValue属性，那么准备阶段变量value就会被初始化为ConstantValue属性所指定的值。 解析前面说过，Class文件中不会保存各个方法、字段最终在内存的哪个地方，因此这些字段、方法的符号引用不经过不经过运行期转换是无法得到字段、方法的内存入口。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用用一组符号来描述所引用的目标(如字段表集合中对字段的描述)，符号引用可以是任意形式的字面量，只要能无歧义的定位到所引用的目标。符号引用的目标不一定已经被加载进内存。 直接引用可以是指向目标的指针的相对偏移量、或能间接定位目标的句柄，能够直接在内存中定位到目标。如果有了直接引用，那么引用的目标肯定在内存中存在。 需要注意的是，虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、new、putfield、putstatic等操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。对一个符号引用进行多次请求解析是很常见的，除了invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)从而避免重复解析，这些解析被称为静态解析。而对于invokedynamic指令，必须等到程序实际运行到这条指令时，才会对符号引用进行解析，并且不会缓存。每一次运行时都要讲符号引用转换为直接引用，这种解析被称为动态连接。(后面讲到动态分派和重写时会介绍) 解析动作主要针对 类或接口 字段 类方法 接口方法等 具体对类、接口、类字段、类方法的解析见书P221 初始化该阶段是类加载过程的最后一步，前面的类加载过程，除了加载阶段用户可以参与，其余动作完全由虚拟机控制。到了初始化阶段，才真正开始执行类中定义的Java代码(Java代码编译后的字节码更准确一些)。在准备阶段，变量已经赋过一次值，而在初始化阶段，则根据程序员通过程序制定的计划去初始化类变量和其他资源。初始化阶段是执行类构造器&lt; clinit&gt;方法的过程。 &lt; clinit&gt;()方法 由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。编译器手机的顺序是由语句在源文件中出现的顺序决定的。静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，语句块只能赋值不能访问。(书P225) 该方法和实例构造器不同，不需要显式的调用父类构造器。虚拟机会保证在子类的&lt; clinit&gt;()方法执行前，父类的&lt; clinit&gt;()方法已经执行完毕。因此在虚拟机中第一个执行&lt; clinit&gt;()方法的类肯定是Object类。 由于父类的&lt; clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块和静态变量赋值要优先于子类 &lt; clinit&gt;()方法对于接口或类来说不是必须的，如果类中没有静态代码块、也没有对类变量的赋值操作，那么编译器可以不生成&lt; clinit&gt;()方法 对于接口，执行接口的&lt; clinit&gt;()方法不需要先执行父接口的&lt; clinit&gt;()方法，只有当父接口中定义的变量使用时父接口才会被初始化。 同样的，接口的实现类在初始化时也一样不会执行接口的&lt; clinit&gt;()方法。 同一个类加载器下，一个类型只会初始化一次。 至此，一个类加载的全过程就完成了。 类加载器加载阶段中”通过一个类的全限定名来获取类的的二进制字节流”这个动作是在虚拟机外部实现的，实现这个动作的代码模块被称为类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。即如果比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里说的相等 代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回结果 使用instanceof关键字做对象所属关系判定结果…… 双亲委派模型对于开发人员来说，类加载器分为三种 启动类加载器(Bootstrap ClassLoader)=&gt;最顶层将存放在\lib目录中的虚拟机识别的类库加载到虚拟机内存中 扩展类加载器(Extension ClassLoader)=&gt;第二层负责加载lib目录下ext目录中的类库，开发者可以直接使用扩展类加载器 应用程序类加载器(Application ClassLoader)=&gt;第三层这个类加载器时ClassLoader中的getSystemClassLoader()方法返回值，所以也叫系统类加载器。如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。 自定义类加载器=&gt;最底层 双亲委派模型的工作过程如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是这样，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。 好处使用双亲委派模型来组织类加载器的关系，Java类随着它的类加载器一起具备了一种带优先级的层次关系。例如java.lang.Object，无论哪一个类加载器要加载这个类，绥中都是委派给顶层的启动类加载器完成，因此Object类在程序中总是一个类。 破坏双亲委派模型没怎么理解，见书P234 至此，类加载机制也就介绍完了。主要介绍了类的加载、验证、准备、解析和初始化过程中虚拟机是怎么做的，以及类加载器的工作原理和双亲委派模型。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机二]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前面说了JVM虚拟机的内存布局和自动内存管理机制，这次就着重记录一下Class文件的结构，毕竟JVM只是工具，而Class文件才是被执行的主体。 无关性基石这里说的无关性，包括两个方面 平台无关性 语言无关性 平台无关性你一定听过一句话–Write Once,Run AnyWhere。以前，一个应用程序要想在要想在不同的操作系统上运行，就要编写不同的代码。因为代码编译后得到的是本地机器码，而不同的操作系统机器码是不一样的，因此如果一个程序需要在多个系统上运行，就要编写不同的代码。平台无关性，顾名思义，就是同样的代码可以在不同的操作系统上正确的运行。这就要通过虚拟机来实现。我们编写的代码(并不是特指Java代码)，会通过编译器编译为字节码，而虚拟机能够载入和执行字节码，从而实现了平台无关性。运行在不同操作系统上的JVM虚拟机是不一样的。JVM虚拟机接收到字节码后，再将字节码转换为本地的机器码。虚拟机就相当于代码和机器码之间的转换器，能够将同一种字节码根据不同的操作系统转换成不同的机器码。通过上述的介绍不难发现，各种不同平台的虚拟机和所有平台都使用的统一的程序存储格式–字节码是构成平台无关性的基石。语言无关性语言无关性的基石仍然是虚拟机和字节码存储格式。Java虚拟机只认识字节码，只和”Class文件”这种特定的二进制文件关联。即如果你将其他语言编译成字节码交付给Java虚拟机，它一样能够执行。事实也是这样，Java程序通过Javac编译器将Java编译成字节码，其他语言如JRuby通过jruby编译器将JRuby编译成字节码，JVM都能够执行。 Java中的各种变量、关键字、和运算符号最周都是由多条字节码命令组合而成，因此字节码命令的语言描述能力肯定比Java更加强大。有一些Java语言本身无法支持的语言特性并不代表字节码本身无法识别。 Class类文件结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目都严格的按照顺序紧凑的排列在Class文件中，中间没有任何分隔符，也就是说，整个Class文件所存储的内容几乎都是程序运行时必要的数据。对于需要占用8位以上的数据项，会按照高位在前的方式将其分割成若干个8位字节进行存储。 魔数和Class文件版本 魔数每个Class文件的前四个字节，值为”0xCAFEBABE”(可以称为咖啡宝贝…)。它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。 Class文件版本紧接着魔数的四个字节，前两个字节是Class文件的次版本号(Minor Version)，后两个字节是主版本号(Major Version)。高版本的JDK能够运行低版本的Class文件，但是不能运行更高版本的Class文件，即使这个Class文件没有发生任何变化。 常量池紧接着版本号之后就是常量池入口。常量池可以理解位Class文件的资源仓库。常量池中常量的数量是不确定的，因此需要一个常量池容量计数器。 常量池容量计数器紧接着版本号后的两个字节，但是要注意的是，&lt;?font color=blue&gt;容量计数是从1开始的。即如果容量转换为十进制是22，那么就有21项常量(1-21)。将0索引空出来的目的在于，当有些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”时，就可以把索引值置0。 常量池中主要存放两大类常量 字面量如文本字符串、声明为final的常量值等 符号引用 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 Java代码在进行Javac编译时，是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段最终在内存的哪个位置，因此这些字段、方法的符号引用要经过运行期的转换才能得到真真的内存地址。当虚拟机运行，需要从常量池获得符号引用，在类创建或运行时解析、翻译到具体内存地址中。(常量池表的类型和内容见书P169) 访问标志常量池结束后紧接着的两个字节就是访问标志(access_flags)，该标志用于识别一些类或者接口层次的访问信息。 该Class是类还是接口 是否为public类型 是否为abstruct 如果是类是否被声明为final等…(P173) 类索引、父类索引和索引接口集合紧接着访问标志之后 类索引两个字节，用于确定类的全限定名 父类索引两个字节，用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个 接口索引集合 两个字节，接口计数器。表示类实现的接口数 每一组都是2个字节，用于确定类实现了哪些接口。如果接口计数器为0，那么一组都没有。 字段表集合用于描述接口或类中声明的变量。即字段表包括类级变量和实例级变量，但不包括方法内部声明的变量。 字段计数器(fields_count)紧接着接口集合后的两个字节，表示字段的数量。 每个字段都有一个字段表，用于记录字段信息，字段计数器为多少，后面就有多少个字段表。 字段表 access_flags(访问标志)两个字节，同类的访问标志一样，描述字段的信息(书P176) name_index(名称索引)两个字节，对常量池的引用，代表字段的简单名称(不包括类名包名等…) descriptor_index(描述索引)两个字节，对常量池的引用，字段的描述符(描述符含义表书P177) 属性表集合用于存储额外信息，字段可以有0至多项额外信息。例如一个常量字段，额外信息中就包含一项ConstantValue属性，其值指向常量值 字段表集合中不会列出从超类或父接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段，譬如一个内部类，在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。并且，在Java中字段是无法重载的，两个字段的数据类型、描述符不管是否相同，都必须使用不一样的名称，但是对于字节码而言，如果两个字段的描述符不一致，那么字段可以重名。 方法表集合和字段表集合描述方式一模一样，分别是 方法计数器(fields_count)紧接着字段表集合后的两个字节，表示方法的数量。 方法表 access_flags(访问标志)两个字节，同字段的访问标志一样，描述方法的信息(书P179) name_index(名称索引)两个字节，对常量池的引用，代表方法的简单名称(int inc()==&gt;简单名称为inc) descriptor_index(描述索引)两个字节，对常量池的引用，方法的描述符(描述符含义表书P177) 属性表集合用于存储额外信息，字段可以有0至多项额外信息，例如方法的方法体编译为字节码后存放在Code属性中 与字段表集合相应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现父类的方法信息。在Java中，要重载一个方法有两个要求 重载方法和原方法具有相同的简单名称 重载方法和原方法的特征签名不同。 特征签名(Signature) Java代码中包含了方法名称、参数类型、参数顺序 字节码中还包括了方法返回值和受检查异常表 因此Java中返回值的不同不能构成重载。但是在Class文件中却可以。 属性表集合前面以及提到了很多次，在Class文件、字段表、方法表都可以携带自己的属性表集合信息。(虚拟机规范预定义属性见书P181) Code属性 attribute_name_index(属性名称索引)两个字节，对常量池的引用，固定为Code，代表属性名称。 attribute_length四个字节属性值的长度 max_stack两个字节，操作数栈的最大深度，方法执行的任意时刻操作数栈都不会超过这个深度。虚拟机运行时需要根据这个值来分配栈帧。 max_locals两个字节，局部变量表所需的存储空间，单位是Slot(double和long占2个Slot，其他基本类型等长度不超过32位的占1个Slot)。局部变量表中存放着 方法参数(包括实例方法的隐藏参数this) 显示异常处理器参数(try-catch中catch块定义的异常) 方法中定义的局部变量 code_length和code分别为四个字节和一个字节，用于存储Java代码编译后生成的字节码指令。code_length代表字节码长度，code用于存储字节码指令。(每个指令占一个字节)。当虚拟机读取到一条指令时，就可以找到这个字节码代表的是什么指令，并且可以知道这条指令后有没有跟参数，以及参数该如何理解。 Code属性时Class文件最重要的属性。如果将Java程序分为元数据(类、字段、方法等信息)和代码，那么在Class文件中 Code属性用于描述代码 其他所有数据项目都用于描述元数据。 在任何实例方法中，都可通过this关键字访问到此方法所属的对象，这是为什么？ 通过Javac编译的时候把对this关键字的访问转变为对一个普通方法参数的访问 然后再虚拟机调用实例方法时自动传入此参数 因此在实例方法的局部变量表中至少会有一个指向当前实例对象的参数，局部变量表也会预留出一个Slot位来存放对象实例的引用。同样在Code属性中，字节码指令后存放的是方法的显式异常处理表(简称异常表)，该表对于Code属性来说不是必须存在的。(当方法中有try-catch语句时会有该表) 显式异常处理表 属于Java代码的一部分，编译器使用异常表来实现Java异常和finally处理机制，表结构如下 start_pc end_pc handler_pc catch_type 如果方法在start_pc行和end_pc行(不包括end_pc)间出现了catch_type异常，则转到handler_pc行继续处理。 Exceptions属性不要和前面的显式异常处理表混淆，显式异常处理表是Code属性的一部分，Exceptions属性是属性表集合中的一种属性，和Code属性平级。该属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时throws关键字后面列举的异常。 attribute_name_index两个字节，对常量池的引用，固定为Exception，代表属性名称。 attribute_length四个字节属性值的长度 numbers_of_exception两个字节，可能抛出的受检查异常的个数 exception_index_table两个字节，对常量池的引用，代表了受检查异常的类型。 LineNumberTable属性用于描述Java源码行号和字节码行号之间对应关系(例如3：0，前面是字节码行号，后面是源码行号)。可以选择不生成，如果不生成，那么抛出异常时将不会显示出错的行号，并且调试程序时无法按照源码设置断点。 LocalVariable Table属性用于描述局部变量表中的变量和Java源码中定义的变量之间的关系，可以选择不生成。如果不生成，当其他人引入这个方法时，所有参数名称都会丢失，IDE会使用arg0、arg1等代替原参数名。该属性作用 描述局部变量在字节码中的作用域 存放局部变量的名称以及描述符 该局部变量在栈帧局部变量表中Slot位置，如果变量为64位，那么它占用的Slot为index和index+1。 ConstantValue属性通知虚拟机自动为静态变量赋值。只有被static修饰的变量才可以使用这项属性。 对于实例变量，在实例构造器(&lt; init&gt;)方法中进行赋值 对于类变量，可以在类构造器(&lt; clinit&gt;)中进行赋值，也可以使用ConstantValue属性进行赋值。 如果同时使用了final和static修饰、并且该变量数据类型为基本类型或String，就生成ConstantValue属性进行初始化 否则，在类构造器中进行赋值 Signature属性可以用在类/接口、方法表、字段表上。在Java中，任何类、接口、初始化方法或成员如果使用了泛型，则该属性会记录泛型的类型(在Java的语法糖中会详细说到)。 Java代码的方法特征签名包括了方法名称、参数顺序以及参数类型 字节码层次的方法特征签名还包括了方法返回值和受检查异常表 可以出现在类、字段表和方法表结构的属性表中，可选属性。在Java中的泛型采用的是擦除机制，在Code属性中，泛型信息编译的(类型变量，参数化类型)之后都统统被擦除掉。好处是实现简单、运行期节省一些类型所占的空间。但坏处是无法将泛型类型和用户定义的普通类型同等对待。例如运行期反射无法获取到反省信息。该属性就是为了弥补这个缺陷设计，Java反射API能够获取泛型类型，最终数据来源就是这个属性。 属性表还有很多其他属性，就不多记录了。Class文件结构就记录到这里。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机一]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%2F</url>
    <content type="text"><![CDATA[作为Java程序员，对于JVM虚拟机的理解是必不可少的。今天刚看了周志明周老师的《深入理解JVM虚拟机》(第二版)，还是有所收获。看得不多，简单小结一下，后面会继续完善JVM方面的知识。 走进Java从传统意义上来讲，Java技术体系包括以下几个组成部分： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java的API类库 来自商业机构和开源社区的第三方Java类库 其中JDK(Java Development Kit)是用于支持Java程序开发的最小环境，包括Java程序设计语言、各种硬件平台上的Java虚拟机以及Java的API类库。而JRE(Java Runtime Enviroment)是支持Java运行的标准环境，包括Java类库中Java SE API子集和Java虚拟机两部分。目前使用范围最广的Java虚拟机是HotSpot。 自动内存管理机制##Java内存区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域： 方法区 堆 虚拟机栈 本地方法栈 程序计数器 下面来分别说一说这几个区域的作用。再说之前，先说一下线程私有的概念线程私有每条线程都需要有一个自己的内存区域，各线程之间互不影响，独立存储，我们称这类内存区域为线程私有。程序计数器 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 该区域是线程私有的 Java虚拟机栈 虚拟机栈也是线程私有的，生命周期和线程相同 每个方法在执行时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息，调用方法时，将栈帧入虚拟机栈；方法执行过后，栈帧出栈，因此不难发现，虚拟机栈可以看作是用于执行Java方法的内存 局部变量表 存放了编译期可知的各种基本数据类型，对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址) long和double类型数据占2个局部变量空间(Slot)，其余的只占1个。 局部变量表所需的内存空间在编译期间分配完成。当进入一个方法时，这个方法需要在栈帧中分配的局部变量空间是完全确定的。 在方法运行期间不会改变局部变量表大小 本地方法栈该栈和Java虚拟机栈的服务很类似，区别在于Java虚拟机栈为执行Java方法(字节码)服务，而本地方法栈为虚拟机使用到的Nativa方法(本地方法，由其他语言编写)服务。Java堆(Java Heap) 一般来说，堆是Java虚拟机管理的内存中最大的一块 被所有线程共享的内存区域，在虚拟机启动时创建 作用是存放对象实例，几乎所有的对象实例都在这里分配 字符串常量池在堆中 同时，堆是垃圾收集器管理的主要区域，又被称为GC堆 Java堆还可以被细分为 新生代(1/3) Eden区(8/10) From Survivor区(1/10) ToSurvivor区(1/10) 老年代(2/3) 常见的配置堆的参数 -Xmx：堆内存的最大内存 -Xms：堆内存的最小内存 -Xmn：新生代的大小 XX:NewRatio：设置老年代是年轻代的几倍 XX:SurvivorRatio：设置Eden区是一个Survivor的几倍(注意是一个) 方法区 方法区也是各个线程共享的内存区域 用于存储一下信息 已被虚拟机加载的类信息 常量 静态变量 即时编译后的代码等 运行时常量池 该区域是方法区的一部分 Class文件除了有类的版本、字段、方法、接口等描述信息(后面会说到)外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用 这部分内容将在类加载后进入方法区的运行时常量池中 相比于Class文件的常量池，运行时常量池具备动态性。Java语言不要求常量一定只有编译期才能产生，也就是并不是只有预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能有新的常量放入运行时常量池中，例如String类的intern方法。(关于此方法可以看我String源码的文章) 关于Java对象说完了JVM内存区域，就简单说一下Java对象的相关内容 对象的创建当遇到一条new指令时 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化 如果没有，那必须先执行相应的类加载过程 类加载完成后，为新生对象分配内存。值得注意的是，对象所需内存大小在类加载完成后就已经完全确定。为对象分配内存的过程其实就是从堆内存中划分出一块确定大小的区域。 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，除了对象头以外(后面会说到)。这一操作保证了对象的实例字段在Java代码中可以不赋初始值就能使用。(不难理解，因为我们在创建Java对象时，成员变量就是默认零值) 接下来JVM对对象进行必要的配置，这些信息都存放在对象头中。例如 对象是哪个类的实例 如何找到类的元数据信息 对象的哈希值 对象的GC分代年龄(后面会说)等 到了这一步，已经执行完new指令了，但是此时对象的成员变量值都为0，显然不符合我们的实际情况。一般来说，这时候会执行&lt; init&gt;方法，把对象按照程序员的意愿进行初始化。这样，我们就得到了一个真正可用的对象。 对象的内存布局说完了对象的创建，紧接着自然就该说一说创建出来的对象是什么样的，有着什么样的内存布局。在HotSpot中虚拟机中，对象在内存中存储的布局可以分为三部分 对象头 实例数据 对齐填充 下面分别说一下这三个部分对象头前面说过，在创建对象分配内存阶段，会将除了对象头以外的内存空间初始化为零值，那接下来就看看对象头到底有什么作用吧。对象头包含两部分信息 一部分用于存储对象自身的运行时数据，如 哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID和偏向时间戳等 另一部分是类型指针，即对象指向它的类元数据的指针。通俗的讲，JVM通过这个指针来确定对象是哪个类的实例。 值得注意的是： 查找对象的元数据信息并不一定要经过对象本身(后面会说到)，因此并不是所有的虚拟机实现都必须在对象数据上保留类型指针。 除此之外，如果对象是Java数组，对象头中还必须有一块用于记录数组长度的数据。 实例数据 该部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。 无论是从父类继承的，还是子类定义的，都会记录下来。 默认情况下，相同宽度的字段会分配到一起。在满足这个条件的前提下，父类中定义的变量会出现在子类之前。 对齐填充这一部分并不是必然存在的，也没有特别含义，仅仅起着占位符的作用。HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。因此实例对象的大小必须是8字节的整数倍，如果对象不是，那么就需要通过对齐填充来补全。 对象的定位访问介绍了对象的创建和内存布局，相比你对Java对象已经有了一定的了解了，那么我们又是怎么在堆中找到这个对象并使用它的呢？Java程序是通过栈上的reference类型数据(前面说过，存放在栈帧中的局部变量表)来操作堆上的具体对象。通过reference数据有两种方式可以定位到堆中的数据 使用句柄访问对象，此时会在堆中划出一块内存叫做句柄池，refenence中存储的就是对象的句柄地址。而句柄中包含了对象的实例数据和类型数据各自的地址信息 实例数据：可以理解为当前对象的所有数据，位于堆中。 类型数据：属于类的数据，如静态变量，常量等，位于方法区中。 使用指针直接访问，此时reference中存储的就是对象实例数据的地址。而在对象中有指向类型数据的指针，通过该指针可以访问类型数据。 以上两种访问方式都有各自的优势： 句柄访问，reference中存储的是稳定的句柄地址，在对象移动时(如GC过程中)只会改变句柄的实例数据指针，而reference本身不需要修改。 指针直接访问，速度更快，节省了一次指针定位的时间 在使用句柄访问时,reference 需要访问句柄池(1次) 通过句柄池中指向实例数据的指针访问堆上的实例数据(2次) 通过句柄池中指向类型数据的指针访问访问方法区上的类型数据(3次) 直接使用指针时，reference 直接访问堆上的实例数据(1次) 在示例数据中找到指向类型数据的指针 通过该指针访问方法区上的类型数据(2次) 由于对象的访问在Java中很频繁，因此这一次开销也是相当客观的。对于HotSpot而言，使用的是第二种情况。 垃圾收集器与内存分配策略前面说过，程序计数器、虚拟机栈、本地方法栈这三个区域和线程生命周期相同，每个栈帧中分配多少内存基本在类结构确定下来时就已知，这几个区域的内存分配的回收都具有确定性，因此不用过多考虑回收问题。但是Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法不同的分支所需要的内存也可能不一样，只有在程序运行期间才能知道会创建哪些对象。这部分内存分配和回收都是动态的，垃圾收集器所关注的就是这一部分内存。 判断对象是否存活垃圾收集器在对堆进行回收前，首先要判断堆中的哪些对象还”存活”着，哪些对象已经”死去”(不可能再被任何途径使用的对象)，判断对象是否存活，有以下几种常用方法 引用计数法给对象添加一个引用计数器 每当有一个地方引用它时，计数器值+1 当引用失效时，计数器值-1； 这样一来，任何时候计数器值为0的对象就是不可能再被使用的，也就是已经”死去”的 这样的算法实现简单，效率也高，在大多数情况下都是一个不错的算法。但是它也有一个很大的缺陷，那就是无法解决两个对象相互引用的问题。什么是相互引用的问题呢？(代码见《深入理解JVM虚拟机》P63) 有两个对象A和B，A和B这两个对象已经不可能再被访问，但是它们之间相互引用 导致两者引用计数器都不为0，于是GC收集器也就无法收集它们。 可达性分析算法大多数的应用程序语言都是使用可达性分析算法来判定对象是否存活。基本思路 通过一系列被称为“GC Roots”的对象作为起始点，从这些节点向下搜索 搜索走过的路径称为”引用链”，当一个对象到GC Roots没有任何引用链相连时(即从GC Roots到这个对象不可达)，则该对象是”死亡”的。 在Java中，可作为GC Roots的对象有 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中Nativa方法引用的对象 引用前面说到的引用计数法和可达性分析法两种方法判断对象是否存活，都和”引用”有关，下面就详细说一下引用的类型 强引用(StrongReference)在程序代码中普遍存在，类似Object o=new Object()这类的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用(SoftReference)用来描述一些还有用但并非必须的对象。对于这些对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次回收。但如果这次回收还没有足够的内存，就会抛出内存溢出异常。 弱引用(WeakReference)比软引用强度更弱，被弱引用关联的对象只能生存到下次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。 虚引用(PhantomReference)最弱的一种引用关系，一个对象是否有虚引用存在，完全不影响其生存时间，也无法通过虚引用来获取一个对象实例。设置该引用的唯一目的就是能在这个对象被垃圾收集器回首时收到一个系统通知。 生存还是死亡即使在前面的可达性分析中得到不可达的对象，该对象也并是”非死不可”。这时候它们暂时处于”缓刑”，如果真正要宣告一个对象”死亡”，至少要经过两次标记过程。在其中对象还有”自救”的机会。 如果对象在可达性分析中发现没有和GC Roots相连的引用链，那么它将会被第一次标记并且进行筛选 如果该对象没有覆盖”finalize()”方法或该方法已经被虚拟机调用过，那么该对象被回收 如果该对象覆盖了”finalize()”方法并且没有被虚拟机调用过，那么该对象会被放置在F-Queue中。并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程执行它。 这里说的”执行”是指虚拟机会触发finalize()方法，但并不承诺会等待它运行结束。这样做的原因在于 如果一个对象在finalzie()方法中执行缓慢，或者发生了死循环，很可能会导致F-Queue队列中其他对象处于永久等待，甚至内存回收系统崩溃。 finalzie()方法是对象最后一次自救机会。稍后GC将对F-Queue队列中的对象进行第二次标记。 如果对象在finalxize()方法中成功拯救自己，和引用链上的任何一个对象建立关联(例如把自己this赋值给某个类的变量等)，那么在第二次标记时会被移出”即将回收”集合。 如果对象这时候没有成功拯救自己，那么基本就被回收了。 回收方法区方法区回收效率较低，这是由方法区存放的数据相关的。方法区主要回收两部分内容，废弃常量和无用的类。判断一个常量是否是废弃常量比较简单，但是要判定一个类是无用的类，条件就会严苛许多，这也是导致方法区回收效率低的原因。判断无用的类 该类的所有实例都被回收 加载该类的ClassLoader已被回收 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 满足上述三个条件的类可以被回收，但并不是必然被回收。 垃圾收集算法正如书上所说，垃圾收集算法涉及大量的程序细节，这里只是大致的介绍三种算法的思想 标记清除算法 复制算法 标记整理算法 标记清除算法该算法分为标记和清除两个阶段。 标记出所有需要回收的对象(标记过程前面已经说过) 标记完成后统一回收所有被标记的对象。 这个方法主要有两个缺点 效率问题，标记和清除两个过程效率都不高。 空间问题，标记清楚过后会产生大量不连续的内存碎片，这类碎片过多可能会导致程序在分配较大对象时无法找到连续内存而不得不再进行一次GC。 复制算法为了解决效率问题，该算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，将还存活着的对象复制到另一块内存上面，然后把自己使用过的内存空间一次清理掉。这样做的好处 每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只需要移动堆顶的指针，按顺序分配内存即可，实现简单且运行高效。 缺点 将内存缩小为原来的一半，代价过高。 现在的虚拟机大多都采用这种方法来回收新生代(注意是新生代)。据分析，98%的对象都是朝生夕死的所以并不需要1：1的比例来分配内存空间。因此新生代就被划分为Eden区(8/10)、FromSurvivor区(1/10)和ToSurvivor区(1/10)三个区域。 每次使用Eden区和一块Survivor区 当回收时，将Eden和Survivor中还存活的对象一次性的复制到另外一块Survivor区中 清理Eden区和刚才用过的Survivor区。 当然，我们并不能保证每次回收后都只有不多于1/10的对象存活，即有可能某次回收后对象存活较多，Survivor空间不够。这时候就要依赖其他内存(老年代)进行分配担保。 标记整理算法 复制算法在对象存活率较高时，效率就会变低(因为要进行较多的复制操作) 更关键的是，使用复制算法就必须要有额外的空间进行分配担保。 对于老年代，没有空间进行担保，因此对于老年代不能够使用复制算法，应该使用标记整理算法。和标记清除算法思想一样，但是后续的步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法这种算法就是根据对象存活周期不同将内存划分为几块。一般是把Java堆划分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。 对于新生代，每次垃圾收集都会有大量对象死去，只有少量存活，因此选用复制算法。 对于老年代，对象存活率较高且没有额外担保空间，不宜使用复制算法，因此选用标记清理或标记整理算法。 HotSpot算法实现前面从理论上介绍了对象的存货判定和垃圾收集算法，下面就具体说一下HotSpot的实现细节 HotSpot枚举根节点 在判断对象存活的可达性分析算法中，使用到了GC Roots。而可以作为GC Root的节点有很多，如果要逐一检查，无疑是很耗费时间的。 另外，可达性分析的过程中整个执行系统看起来就被冻结在某个时间点上，即GC停顿。不允许出现分析过程中对象的引用关系还在不断变化的情况，否则分析结果的准确性就不能得到保证。这就导致了GC进行时必须停掉所有的Java线程(Stop The World)。 由于大多虚拟机都是采用准确式GC(即虚拟机知道内存中某个地方的数据到底是什么类型，这样在GC时能够准确判断堆上的数据是否还可能被使用)。HotSpot虚拟机使用一组称为OopMap的数据结构，在类加载完成后，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 安全点(SafePoint)前面说了，在OopMap的协助下，HotSpot可以准确地完成GC Roots枚举。但仍有一个问题，可能程序中，导致引用关系变化(即导致OopMap内容发生变化)的指令很多，如果每一条指令都生成对应的OopMap，这样很占内存。实际上，HotSpot也没有为每条指令都生成OopMap。前面说到了，它只是在特定位置记录这些信息，这些位置被称为安全点。即在程序执行时并非所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。安全点的选用既不能太少以至于让GC等待时间太长，也不能太多导致频繁GC增大运行负荷。安全点的选定基本上是以指令”是否具有让程序长时间执行的特征”为标准进行选定。这是因为：每条指令执行时间都非常短暂，”长时间执行”最明显的特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等。所以具有这些功能的指令才会产生SafePoint。 对于安全点，还有一个问题就是如何在GC发生时让除了执行Native的所有线程都”跑”到最近的安全点上再停顿下来？书上给了两种方案 抢先式中断不需线程的执行代码主动去配合，在GC发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复该线程，让它跑到”安全点”上。(这种方法现在几乎不用) 主动式中断当GC需要中断线程时，不直接对线程进行操作，仅仅是简单地设定一个标志，各个线程执行时主动的去访问这个标志，发现中断标志为真时就自己中断挂起。标志的地方和安全点是重合的。 安全区域(Safe Region)前面的安全点并没有完全解决如何进入GC的问题。你发现没有，当一个线程不执行的时候(即没有分配到CPU时间，有可能是处于Sleep状态或者Blocked状态)，显然无法响应JVM的中断请求，”走”到安全点中断挂起；同样的JVM也不可能等待线程重新被分配CPU时间。这时，就需要安全区域来解决。 安全区域指的是在一段代码片段中，引用关系不会发生变化。那么在这个区域内的任意地方开始GC都是安全的。 对于安全区域的线程 在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域。 这样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程。 线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程) 如果完成了，线程就继续执行 否则它就必须等待直到收到可以安全离开Safe Region的信号为止 内存分配和回收策略Java体系中的自动内存管理，实际上可以归结为给对象分配内存以及回收分配给对象的内存。前面已经大致介绍了内存回收这方面，下面就说一下给对象分配内存的细节。 对象内存的分配，基本都是分配在堆上。对象主要分配在新生代的Eden区。对象优先在Eden分配大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。 Minor GC新生代GC，指发生在新生代的GC，因为Java对象大多都具有朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也较快。 Full GC老年代GC，指发生在老年代的GC，Full GC速度一般会比Minor GC慢10倍以上。 大对象直接进入老年代大对象，即需要大量连续内存空间的Java对象。最典型的有很长的字符串或数组。可以通过设置”-XX:PretenureSizeThreshold&lt;/font“参数，令大于这个设置值的对象直接在老年代分配。这样做的目的就是避免在Eden区以及两个Survivor区发生大量内存复制。长期存活的对象将进入老年代前面说过，JVM采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些又该放在老年代。为此，虚拟机给每个对象定义了一个年龄(Age)计数器。 如果对象在Eden区出生并经过一次Minor GC后仍然存在，并且能够被Survivor区容纳，将被移动到Survivor区中，并且对象年龄设为1 对象在Survivor区中每熬过一次Minor GC，Age就+1，当年龄增加到一定数时(默认15)，就会被移到老年代。 对象晋升到老年代的阈值，可以通过参数”-XX:MaxTenuringThreshold“设置 动态对象年龄判断为了更好地适应不同程序的内存情况，对象并不是一定要达到阈值年龄才能晋升到老年代。如果Survivor区中相同年龄所有对象的大小总和大于Survovir空间(一个Survivor大小)的一半，年龄大于或等该年龄的对象就可以直接进入老年代。 对于JVM的简单介绍就记录到这里，回顾一下主要介绍了JVM内存模型、自动内存管理以及垃圾收集机制。下次会记录一下第六章内容，即JavaClass文件结构。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础-SQL语句总结-三]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前面已经的数据库基础还没总结完，马上就要上手做demo了，先把数据库做个总结回顾，方便后面使用。上次记录了基本的DQL语句，这次就记录一下约束、范式以及多表关系方面。 约束]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之快速排序]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面已经说过了四种排序算法，这次来讲一讲一种效率较高，应用也较多的一种排序，那就是快速排序。听名字就知道，这种排序算法速度是比较快的，那它究竟是怎么操作的呢？让我们来看一看吧 算法思路快速排序其实是对冒泡排序的一种改进，用到了分治和递归思想。通过一趟排序将要排序的数组分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按照此方法对两部分数据分别进行快速排序，整个排序过程递归进行。 在待排序的数组中选定一个基数(作用后面说) 这里基数的选择有很多种方法： 数组的第一个元素作为基数 数组的最后一个元素作为基数 数组的中间元素作为基数 随机在数组中选择一个数作为基数 我这里是选择中间的数作为基数。 在当前数组的开头和末尾各定义一个指针，暂且命名为l和r l指针向右扫描，直到找到小于等于基数的数为止 r指针向左扫描，直到找到大于等于基数的数为止 交换arr[l]和arr[r]，重复3，4直到r&lt;=l为止 当r==l的时候，l和r指向基数。并且数组中比基数小的元素都在数组的左边，比基数大的元素都在数组的右边。 分别对数组的左边和右边递归进行2、3、4、5步，最后整个数组就被排序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void quickSort(int[] arr,int left,int right) &#123; //左下标，初始值为0 int l=left; //右下标，初始值为最后一个元素的下标 int r = right; //基数 int pivot = arr[(left + right) / 2]; //while循环让比pivot小的值放到左边，大的放到右边 while (r &gt; l) &#123; //在pivot左边一直找，直到找到大于等于pivot的值，才退出 while (arr[l] &lt; pivot) &#123; l++; &#125; //在pivot右边一直找，直到找到小于等于pivot的值，才退出 while (arr[r] &gt; pivot) &#123; r--; &#125; //此时说明pivot左边的值都小于等于pivot，右边都大于等于pivot if (l &gt;= r) &#123; break; &#125; //交换 int temp; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后发现arr[l]==pivot，让r前移一步，r-- if (arr[l] == pivot) &#123; r--; &#125; //如果如果交换完后发现arr[r]==pivot，让l后移一步，l++ if (arr[r] == pivot) &#123; l++; &#125; &#125; //注意：如果l==r，必须让l++,r--，否则会出现栈溢出 if (l == r) &#123; l++; r--; &#125; //向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (l &lt; right) &#123; quickSort(arr, l, right); &#125;&#125; 细节解释我把我觉得代码中不好理解的地方说一下 这两个判断的作用是什么呢？举个例子： 现有一个待排序数组{3,1,1,2}，初始时l=0；r=3；pivot=arr[1]=1; 第一次扫描过后，得到数组{1,1,3,2}，此时l=0；r=2； 第二次扫描，因为arr[r]=3&gt;pivot,r左移，r=1；l不变，l=0 这时候问题就来了，这时候arr[l]==arr[r]==pivot，所以l和r会一直互相交换值，但是它们指向的位置不变，即l==r==1一直保持，这样就会陷入死循环为什么在arr[l] == pivot时是r–而不是l++呢？前面说过，因为最后r==l时，arr[r]==arr[l]==pivo一定是存在的。当arr[l] == pivot时，说明l已经找到了确定的位置，这时候如果移动l，那么最后l==r时，arrr[r]==arr[l]就有可能不等于pivot。为什么会出现栈溢出？可以这么理解，当第一趟排序过后，arr[r]==arr[l]==pivot，数组中小于pivot的都在左边，大于pivot的都在右边。这时候要递归对左右序列分别进行快排。通过下面的递归代码可以发现： 对其左序列进行快排时，以r为新的右边界 对其右序列进行快排时，以l为新的左边界 这时候r和l指向的值是已经确定了位置的基数值，自然就不需要参与后面的快排。所以要将r前移，l后移，目的就是将已经确定位置的基数值排除在外。 排序速度同样的，我们来测试一下快排有多快排序时间进过多次测试发现快排的速度大约在20ms左右，比前面的希尔排序还要快一倍，果然是快排，名不虚传。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之希尔排序]]></title>
    <url>%2F2019%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说到了插入排序，并且知道了它是不稳定的。并且测试速度后发现插入排序的速度与冒泡、选择相比还是比较可观的。但是，不知道你有没有发现，插入排序再某些情况下存在着一些弊端。比如有这样的一个数组arr={4,7,9,6,4,1}，数组自身的顺序接近于逆序，当将4、1插入到有序数组中时，需要将有序数组部分所有元素都后移一个位置，这无疑会有一定的时间消耗。那么在这种情况下，就出现了希尔排序，你可以将希尔排序理解为插入排序的增强版。 算法思路希尔排序，又称为缩小增量排序 设置一个步长step，通常初始化为arr.length/2，即数组长度的一半 间隔为一个步长的元素为一组 分别对同一组的元素进行插入排序 每一趟过后将step减半，即step/=2(缩小增量) 重复3和4，直到step为1 setp为1时，数组已经接近有序，这时对整个数组进行插入排序。 前面说过，插入排序适用于哪些自身顺序比较良好的数组，而希尔排序通过不断地缩小步长，将一个数组变成一个接近有序的数组后，直到step=1，此时就相当于对一个接近有序的数组进行插入排序。 代码实现1234567891011121314151617181920public static void Shellsort1(int[] arr) &#123; int count=0; for (int step = arr.length / 2; step &gt; 0; step /= 2) &#123; //类比于插入排序 for (int i = step; i &lt; arr.length; i++) &#123; //当前分组中有序部分的最后一个数下标 int insertIndex = i - step; //当前分组中待待插入的数 int insertVal = arr[i]; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + step] = arr[insertIndex]; insertIndex -= step; &#125; arr[insertIndex + step] = insertVal; &#125; &#125; System.out.println(&quot;希尔排序后的数组&quot;); System.out.println(Arrays.toString(arr));&#125; 分析 算法的时间复杂度 平均时间：O(nlogn) 最差情况：O(n的1.2次方) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1) 稳定性 和插入排序不同，希尔排序不是稳定的 算法速度既然说希尔排序时插入排序的增强版，那就来测试一下希尔排序和插入排序的速度谁更快一些，又快多少呢？同样的，创建一个80000大小的随机数组，来测试希尔排序的排序速度排序时间(毫秒)为通过前面插入排序的对比不难发现，希尔排序能够较大的提高插入排序的速度]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之插入排序]]></title>
    <url>%2F2019%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说了两种排序算法，分别是冒泡排序和选择排序，这两种算法都比较容易理解。那么这次来学习第三种排序—-插入排序，这也是一种相对简单的排序算法，理解起来难度也不大。 算法思路将数组分成两部分： 一部分是有序数组 一部分是无序数组。 在每一趟排序中，从无序数组中拿出一个数来，放到有序数组的正确位置。即每一趟排序过后，无序数组元素减少一个，相应的有序数组元素增加一个。到最后该数组全部变为有序数组。 初始化有序数组长度为1，即arr[0]为有序数组。 第一趟排序，将无序数组中第一个元素arr[1]放到有序数组中，此时有序数组包含两个元素 第二趟排序，将无序数组中第一个元素arr[2]放到有序数组中，此时有序数组包含三个元素 …… 第n-1趟排序，将无序数组中第一个也是最后一个元素arr[n-1]放到有序数组中，至此数组全部有序可以看到，最后一趟排序过后，无序数组长度为0，至此数组全部有序。 代码实现1234567891011121314151617181920212223/** * 插入排序 * @param arr */public static void insertSort(int[] arr) &#123; //待插入的数，无序数组第一个元素 int insertIndex; //待插入的数前面一个数的下标，有序数组最后一个元素 int insertVal; for (int i = 0; i &lt; arr.length-1; i++) &#123; //待插入的数为无序数组第一个元素 insertVal = arr[i+1]; //有序数组最后一个元素 insertIndex = i ; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; arr[insertIndex+1] = insertVal; &#125; System.out.println(&quot;排序后的数组&quot;); System.out.println(Arrays.toString(arr));&#125; 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1) 稳定性 不难发现，插入排序是稳定的 另外，该排序算法在大部分元素已经是有序时比较好 算法速度和前面两个排序算法一样，我们来随机创建一个80000大小的随机数组，测试所用的时间最后测得的排序时间为让我们以ms为单位，再测试一次通过结果可以发现，相比于冒泡排序和选择排序，插入排序的速度还是很可观的。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下之计算机网络和因特网]]></title>
    <url>%2F2019%2F09%2F20%2F%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%2F</url>
    <content type="text"><![CDATA[最近在读计算机网络方面的书—–《计算机网络自顶向下方法》(第七版)，个人觉得书中概念讲的很清楚，举例也是很形象易懂了，如果你想学计网的话，5星强烈推荐！刚读完第一章，做个小结，方便回头复习。书中有些图有助于理解，建议搭配书本一起学习。 什么是因特网这一节主要从两个方面来解释什么是因特网 从因特网得具体构成，也就是从因特网的基本硬件和软件组成方面解释 从为分布式应用程序提供服务得联网基础设施来描述 具体构成描述因特网是一个世界范围内的网络，一个互联了遍及全世界数十亿计算设备的网络，这些计算设备包括计算机、手机、智能手表、电视…，用因特网术语来说，这些和因特网被称为主机/端系统。端系统通过通信链路和分组交换机连接到一起 通信链路 用来传输数据，由不同类型的物理媒体组成，例如同轴电缆、铜线、光纤… 传输速率：链路传输数据的频率，比特/秒(bit/s) 分组交换机 顾名思义，分组交换机从它一条如通信链路接收到达的分组，并从它的一条出通信链路转发该分组 两种有名的分组交换机：路由器和链路层交换机 链路层交换机通常位于接入网中 路由器通常位于网络核心中 分组 当端系统向另一台端系统之间发送数据时，发送端系统将数据分段，并为每段加上首部字节 由此形成的信息包用计算机网络术语来说称为分组 分组通过网络发送到目的端系统，并在那里被装配成原始数据 路径 一个分组所经历的一系列通信链路和分组交换机被统称为通过该网络的路径 也许通过上面的描述，你还是不明白数据在网络中怎么传输的。不着急，我们来举个例子：一个工厂需要将大量的货物搬运到数千里以外的某个目的地仓库。在工厂中，货物要分开并装上卡车车队。然后每辆卡车独立的通过高速公路、公路或立交桥组成的运输网络向仓库运送货物。在目的地仓库，卸下这些货物，并且与一起装载的同一批货物的其余部分堆放在一起。 工厂就相当于源端系统 货物就相当于数据 目的地仓库就相当于目的端系统 在工厂中将货物分开并装上卡车，即将数据分段，为每段加上首部字节，形成分组。因此、分组就相当于卡车。 高速公路、立交桥就相当于各种通信链路 分组交换机则相当于路的交叉口 公路两边的建筑物就相当于端系统 就像卡车选取运输网路的一条路径前行一样，分组选取计算机网络的一条路径前行 这下你明白了么？端系统通过ISP(Internet Service Provider,因特网服务提供商)接入因特网 ISP一个由多台分组交换机和多段通信链路组成的网络。各ISP为端系统提供了不同类型的网络接入，因特网就是将端系统彼此互联，因此为端系统提供接入的ISP也必须互联，后面会详细说到ISP 协议 控制着因特网中信息的接受和发送，端系统、分组交换机和其他因特网部件都要运行一系列协议 TCP(Transmission Control Protocal，传输控制协议)和IP(Internet Protocol，网际协议)是因特网中最为重要的协议 IP协议定义了在路由器和端系统之间发送和接收的分组格式 服务描述除了电子邮件、Web冲浪等传统应用外，因特网应用还包括手机和平板的应用程序。例如在线电影、多人游戏、视频会议…因为这些应用&lt;font color=bllue涉及到多个相互交换数据的系统，故它们被称为分布式应用程序。重要的是，这些因特网应用程序都是运行在端系统上的，即它们并不运行在位于网络核心的分组交换机中。假如你写了一个应用程序，运行在不同端系统上的软件需要相互发送数据(例如QQ、微博…)，这时候问题就来了，你怎么才能让运行在一个端系统上的应用程序指令因特网向运行在另一个端系统的软件发送数据呢？这个问题引出了另一种描述因特网的方法：即将因特网描述为应用程序的平台。与因特网相连的端系统提供了一个套接字接口(在Java中，接口就是规则)，该接口规定了运行在端系统上的应用程序请求因特网向运行在另一个端系统上的特定目的地程序交付数据的方式。 套接字 由端系统提供 规定了端系统上的应用程序请求因特网向另一个端系统上的特定目的地程序交付数据的方式。 一套发送程序必须遵循的规则集合 我们继续来做一个类比假设张三使用邮政服务向李四发送一封信。那我们知道，张三不能只是写了这封信，然后丢出窗外，这样邮政服务是不会接收的，李四也收不到信。正确的做法是什么呢？张三应该将信装在信封里，在信封上写李四的姓名、住址、邮编；在信封右上角贴上邮票；最后将信封丢进邮政的服务信箱中。这是邮政服务定义的规则，是每个要发信的人必须遵守的。同理，因特网也有一个发送数据的程序必须遵守的套接字接口(规则)，是因特网能向接收数据的程序交付数据。 什么是协议同样的，为了帮助理解，我们像举个例子类比一下协议这个概念。我们的生活中，无时无刻不在执行协议。假设张三遇到了李四，发生了下面一段对话 张三：你好，李四(李四发送报文) 李四：你好，张三(发送报文) 这时，李四对张三的回应按时着两人可以继续进行交谈(通信)。 但是如果是这样的： 张三：你好啊李四 李四：别烦我/没有理张三 李四的反应表明两人之间的交谈(通信)很勉强或者无法进行，这时张三可能会放弃和李四的交谈。 通过上面两段对话，可以知道，发送和接收的报文，以及这些报文发送、接收报文(在第一段中，李四接收报文后对张三进行了回复)或者其他事件出现时所采取的动作(在第二段中，李四没有进行回复)，在一个人类协议中起到了核心作用。如果两个人交谈时，使用不同的协议，例如张三和李四的语言不通，那么他们就无法通信。同样的，在网络中为了完成一项工作，要求两个(多个)通信实体运行相同的协议。网络的协议和人类协议类似，交换报文和采取动作的实体时设备而不是人 协议定义了在两个或多个通信实体间交换报文的&lt;font color=bllue格式和顺序，以及报文发送和或接受一条报文或其他事件发生时所采取的动作。因特网广泛的使用了协议，不同的协议用于完成不同的通信任务，掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式的过程。 网络边缘前面说过，通常把与因特网相连的计算机或其他设备称为端系统，它们位于互联网的边缘，因此被称为端系统。想象一下，在现实生活中，各种各样的房子/建筑物就相当于各种各样的端系统，建筑物前的公路将数以亿计的建筑物连接在一起，就相当于因特网将无数端系统连接在一起。通常路的尽头都是建筑物，建筑物位于公路系统的边缘，同样的端系统也位于互联网的边缘。端系统也称为主机，因为它们运行应用程序，主机有时又被分为两类：客户端和服务器。 接入网前面说到了位于网络边缘的端系统和应用程序，现在主要说一下接入网，这是指将端系统物理连接到边缘路由器的网络 边缘路由器端系统到任何其他远程端系统路径上的第一台路由器。下面说一下使用接入网的几种环境。 家庭接入家庭接入有大致4种不同的接入链路 DSL(Digital Subscriber Line，数字用户线) 电缆 FTTH(Fiber To The Home，光纤到户) 拨号和卫星 下面分别做一下了解 DSL-数字用户线住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。当使用DSL时，本地电话公司也是它的ISP(因特网服务提供商)。每个用户的DSL调制解调器使用现有的电话线(双绞铜线)与电话公司的数字用户线接入复用器(DSLAM)交换数据。家庭的DSL调制解调器得到数字信号后将其转换为高频音，通过电话线传输给电话公司，在电话公司的DSLAM处转换回数字信号。这样，电话线同时承载了数据和传统的电话信号，它们通过不同的频率进行编码 高速上行信道：50kHz-1MHz频段 中速下行信道：4kHz-50kHz频段 普通双向电话信道：0-4kHz频段 这种方法使得单根的DSL线路看起来就像有三根一样，因此一个电话呼叫和一个因特网连接能够同时共享DSL链路(后面会说到这种频分复用技术) 用户一侧：一个分配器把到达家庭的数据信号和电话信号分开，并将数据信号转发给DSL调制解调器 电话公司一侧：DSLAM把数据和电话信号分开，并将数据信号发送到因特网。 以上就是DSL接入方式。适用于短距离接入 电缆接入DSL利用电话公司的本地电话基础设施，而电缆因特网接入利用有线电视公司的有线电视基础设施。住宅从提供有线电视的公司获得电缆因特网接入。电视公司的电缆头端和地区枢纽通过光缆连接，地区枢纽使用传统的同轴电缆到达各家各户，每个地区枢纽通常支持500~5000个家庭。电缆因特网接入需要特殊的调制解调器，即电缆调制解调器。 家庭端类似DSL调制解调器，电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭PC，将数字信号转换为模拟信号。 电视公司的电缆头端电缆调制解调器端接系统(CMTS)，类似于DSL中的DSLAM，功能也类似。即将来自住户的电缆调制解调器发送的模拟信号转换回数字信号。 共享广播媒体 电缆因特网接入一个重要的特征是共享广播媒体。 由头端发送的每个分组向下行经每段链路到每个家庭，每个家庭发送的每个分组经上行信道向头端传输。因此，如果几个用户同时经下行信道下载一个视频文件，每个用户接收视频文件的实际速率将大大低于电缆总计的下行速率。 FTTH(光纤到户)从本地中心局直接到家庭提供了一条光纤路径，有两种方案 直接光纤，从本地中心局到每户设置一个光纤 从中心局出来的每根光纤实际上由多个家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤，进行这种分配形成了两种光纤分布体系方案 主动光纤网络(Active Optical NetWork,AON)，AON本质上就是交换因特网，后面会说到 被动光纤网络(Passive Optical NetWork,PON) 简单说一下PON 家庭端每个家庭具有一个光纤网络端接器(ONT)，用户将一台家庭路由器和ONT相连,并通过这台路由器接入因特网。ONT由专门的光纤连接到邻近的分配器，分配器把一些家庭(一般100个)集结到一根共享的光纤。 公司端该光纤在连接到本地公司的光纤线路端接器(OLT)，OLT提供了光信号和电信号之间的转换，经过本地公司的路由器和因特网相连 在PON体系中，所有从OLT发送到分配器的分组在分配器处复制。 拨号和卫星在无法提供上面三种接入的地方，能够使用这两种方式，速度较慢。 企业和家庭接入在公司和大学校园以及越来越多的家庭环境中，使用局域网(LAN)将端系统连接到边缘路由器，局域网技术有很多种，目前以太网是最流行的接入技术(会在后面讲到该技术)。 以太网用户使用双绞铜线与一台以太网交换机相连 以太网交换机或者这样相连的网络再与更大的因特网相连。 还有越来越多的手机等设备无线接入因特网。在无线LAN环境中： 无限用户从一个接入点发送/接收分组； 该接入点与企业网连接(可能是用了有线以太网)； 企业网再与有线因特网相连。现在我们知道的WiFi，就是基于IEEE802.11技术的无线LAN接入。 广域无线接入：4G和LTE 4G(第四代广域无线网络)我们平常使用的手机网络(联通、电信…)也能够接入因特网，这就用到了与蜂窝电话相同的无线基础设施，通过蜂窝网提供商(电信…)运营的基站来发送和接收分组。和WiFi不同的是，我们在使用4G网络的时候，并不需要在接入点几十米范围内，而是在基站数万米内都可以使用。 LTE(Long-Term-Evolutuon,长期演进)来源于3G技术 物理媒体在前面说到因特网一些接入技术的时候，说到了所使用的物理媒体。例如DSL使用了双绞铜线，电缆接入网络使用了光纤和同轴电缆…接下来就简要说一下常用的物理媒体。我们描述下一个bit从一个端系统开始传输，经过一系列链路和路由器，到达另一个端系统的历程。 源端系统发送这个bit，不久后第一台路由器接收该bit 第一台路由器转发该bit，不久后第二台路由器接收 ……中间经历了若干个路由器最终到达端系统 因此，该bit从源到目的地传输时，通过一系列的“发射器-接收器”对。对于每个发射器-接收器对，通过跨越一种物理媒体传播电磁波或光脉冲来发送该比特。物理媒体有多种形状和形式，并且对沿途的每一个发射器-接收器对来说不必具有相同的类型。物理媒体分为两种 引导型媒体：电波沿着固体媒体前行，如光缆、双绞铜线以及同轴电缆…… 非引导型媒体：电波在空气或外层空间种传播，如无线局域网或数字卫星频道中。 另外，物理链路(铜线、光缆等)的实际成本与其他网络成本相比通常小很多。下面说几种常见的物理媒体： 双绞铜线 最便宜最常用的引导型传输媒体； 由两根绝缘铜线组成以规则的螺旋排列，一对电线构成了一个通信链路。 数据传输速率取决于线的粗细以及传输方和接收方之间的距离。 同轴电缆和双绞线类似，由两个铜导体组成，但这两个铜导体是同心而不是并行的，同轴电缆能够达到较高的数据传输速率，在电缆电视系统中相当普遍。特别的，许多端系统能够直接与该电缆相连，每个端系统都能接收由其他端系统发送的内容。 光纤一种柔软的、能够引导光脉冲的媒体，每个脉冲表示一个bit。有以下特点： 比特速率极高 不受电磁干扰并且光缆信号衰减极低 很难窃听 这些特征使得光纤成为长途引导型传输媒体，特别是跨海链路&gt;。 陆地无线电信道无线电信道承载电磁频谱中的信号，不需要安装物理线路，并且具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力。无线电信道的特性依赖于传播环境和信号传输距离。环境上取决于 路径损耗 遮挡衰落(信号跨距离传播通过阻碍物时信号强度降低) 多径衰落(干扰对象的信号反射) 干扰(由于其他传输或电磁信号) 陆地无线电信道大致划分为三类 运行在很短距离：个人设备如无线头戴耳机、无线鼠标… 运行在局域，通常数十到几百米：无线LAN技术使用的就是该局域无线电信道 运行在广域，跨越数万米：蜂窝接入技术使用的就是该广域无线电信道 卫星无线电信道一颗通信卫星连接地球上两个或多个微波发射/接收器，它们被称为地面站。该卫星在一个频段上接受传输，使用一个转发器(后面会说到)再生信号，并在另一个频段上发射信号。通常用于无法使用DSL或电缆接入的区域。 网络核心前面说完了网络边缘，现在这里说一下网络核心，即由互联因特网端系统的分组交换机和链路构成的网状网路。 分组交换在各种应用程序中，端系统彼此交换报文。报文能够包含协议设计者需要的任何东西，可以包含控制功能，也可以包含数据。源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。分组以等于该链路最大传输速率的速度通过通信链路。例如，源或分组交换机将一个长为L的分组发送出去，链路的传输速率为R(bit/s)，那么传输该分组的时间为L/R秒。 存储转发传输交换机能够开始向输出链路传输该分组的第一个bit之前，必须接收到整个分组。多数分组交换机在链路的输入端使用存储转发传输。 排队时延和分组丢失每台分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个输出缓存/输出队列 输出缓存/输出队列用于存储路由器正准备发往那条链路的分组。 该输出缓存在分组交换中作用很大，如果到达的分组需要传输到某条链路，但发现该链路正在忙于传输其他分组，那么该分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延。这些时延是变化的，取决于网络的拥塞程度。 分组丢失前面说过，分组可能将会在路由器中的输出缓存中等待，因为缓存空间大小是有限的，一个到达的分组可能发现路由器的缓存空间已经被其他等待传输的分组完全充满。在这种情况下，将会出现分组丢失/丢包。到达的分组或已经排队的分组之一将被丢弃。 转发表和路由选择协议路由器从一条通信链路得到分组，然后向与它相连的另一条链路转发分组，那么问题来了，路由器是怎么决定它应当向哪条链路进行转发呢？在因特网中，每个端系统都有一个地址，被称为IP地址。当源主机要向目的主机发送一个分组时，源在该分组的首部包含了目的主机的IP地址。如同邮政地址一样，该地址具有等级结构。分组到达路由器时，路由器检查该分组目的地址的一部分，并向一台相邻的路由器转发该分组。更特别的，每台路由器具有一个转发表 转发表用于将目的地址(或目的地址的一部分)映射成输出链路。 当分组到达路由器时，路由器检查分组的目的地址(或一部分)，用这个地址搜索转发表，找到合适的出链路，路由器将分组导向该链路。 转发表的设置因特网具有一些特殊的路由选择协议，用于自动的设置这些转发表。 电路交换在电路交换网络中，端系统会话期间，预留了端系统间路径通信所需要的资源。而在分组交换网络中，这些资源则不是预留的，会话的报文按需使用资源，这样就带来了等待(排队)接入链路。 举例说明，现有两家餐馆 分组交换不需要预定，但不保证能安排顾客，即顾客去的时候可能餐馆满了，就需要排队等待 电路交换在去之前必须提前预定，虽然麻烦，但是我们到的的时候能够立即入座点菜。 传统的电话网络就是电路交换的例子，在发送方能够发送信息之前，该网络必须在发送方和接收方建立一个名副其实的连接，因此此时沿着该发送方和接收方之间路径上的交换机都将为该连接维护连接状态。该连接被称为一条电路 当网络创建这种电路时，也在连接期间为该网络链路上预留了恒定的传输速率(每条链路传输容量的一部分)，能够确保发送方以恒定速率向接收方传输数据。 例如：A向B发送报文，网络必须在链路中预留一条电路，如果一个链路的传输速率为1Mbps，有四条电路，那么A向B发送报文的速率恒定为250kbps，即使该链路此时只有这一条连接。 电路交换网络中的复用前面说的电路是通过频分复用(FDM)或时分复用(TDM)来实现的，并不是真正的电线电路。 频分复用(FDM)链路的频谱由跨越该链路创建的所有连接共享。特别的，在连接期间为每条连接专用一个频段。在电话网络中，这个频段的宽度通常为4kHz。这个频段的宽度称为带宽 时分复用(TDM)对于时分复用，时间被划分为固定时期的帧，每个帧又被划为为固定数量的时隙。当网络跨越链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用。在TDM中，一条电路的传输速度等于帧速率乘一个时隙中的比特数量。例如一个帧为1分钟，一个帧有60个时隙(即一个时隙1秒)，如果网络指定第二个时隙为该连接专用，那么在每分钟的第二秒时间内为该链接传送数据，其他的时隙即使没有连接使用，该链接也不能使用。 通过上面的描述我们不难发现，电路交换虽然能够保证数据传输的速率，但是往往会造成资源的浪费，总体上说分组交换要更优一些。 网络的网络前面说过，端系统通过一个接入ISP和因特网相连，因为因特网是将数以亿计的端系统相连，因为ISP自身也必须互联，通过创建网络的网络可以做到这点。 网络的网络可以理解为将ISP连接成网络，因为ISP自身就是一个网络，将许多ISP连接成网络，就实现了与不同ISP相连的端系统相连。 总的来说，今天的因特网是一个网络的网络，由十多个第一层ISP和数十万个较底层的ISP组成，较低层的ISP与较高层的ISP相连，较高层的ISP彼此互联。用户和内容提供商是较低层ISP的客户，较底层ISP是较高层ISP的客户。也有一下大型的内容提供商(谷歌等)创建自己的网路，直接在一些地方和较低层ISP互联。从而减少这些大型内容提供商向顶层ISP支付的费用。 分组交换网中的延时、丢包和吞吐量因特网能够看成是一种基础设施，为运行在端系统上的分布式应用提供服务。在理想情况下，我们希望它能够在任意两个目标端系统之间随心所欲地移动数据而不会产生数据丢失。然而，这是很难做到的。相反的，计算机网络必定要限制在端系统之间的吞吐量，在端系统之间引入时延、并且也会丢失分组。 吞吐量每秒能够传送的数据量 时延概述前面说过，分组从源到目的地的过程中，当分组从每个节点(主机或路由器)沿着这条路径到后继节点，该分组在每个节点经受了几种不同类型的时延 节点处理时延 排队时延 传输时延 传播时延 这些时延加起来就是节点总时延。 节点处理时延检查分组首部和决定该分组导向何处所需要的时延是节点处理时延的一部分，通常是微秒或更低的数量级 排队时延在队列中，当分组在链路上等待传输时，它经受排队时延。一个分组排队时延取决于在它前面正在排队等待向链路传输的分组数量如果队列为空，那么排队时延为0。通常是毫秒到微秒量级 传输时延将所有分组的bit推向链路所需要的时间，单位是bit/s，通常是毫秒到微秒量级 传播时延当比特被推向链路后，该比特需要向下一个路由器传播。从该链路的起点到路由器B传播所需要的时间是传播时延。传播时延等于两台路由器之间距离除以传播速率。在广域网中，通常是毫秒量级 传输时延和传播时延的比较 传输时延由路由器将分组推向链路所需要的时间，和距离无关，和分组大小相关；单位是bit/s。 传播时延是分组被路由器推出链路后经过链路传播到下一台路由器所需要的时间，和分组长度无关，和两台路由器之间的距离相关；单位是m/s。 排队时延和丢包排队时延 假设a表示分组到达队列的平均速率(以bps/s为单位) R表示传输速率，即从队列中推出比特的速率(以bps/s为单位) 假定所有的分组都由L个比特组成。 那么bit到达队列的平均速率为(La)bps/s。最后，假设该队列很大，能够容纳无限数量的bit，那么比率La/R被称为流量强度 流量强度 La/R&gt;1，即比特到达队列的平均速率超过从该队列传输出去的速率。这时，队列将会无限增加，排队时延就会趋于无穷大。 La/R≤1，这时，到达流量的性质将影响排队时延。 分组周期性到达，即每L/R秒到达一个分组，则每个分组到达时，队列刚好将上一个分组全部推出。此时队列为空，就不会有排队时延 分组以突发形式到达，即在某个时刻同时到达很多分组。就可能会有很大的平均排队时延 因此：设计系统时流量强度不能大于1。通常情况下，分组到达队列的时间是随机的 到达速率小于传输能力时队列的长度将缩短 流量强度接近于1时平均队列长度将会变得越来越长。 丢包在上面，我们假设了队列能够容纳无穷多的分组，在现实中，链路的队列容量是有限的。随着流量强度接近于1，队列并不是趋于无穷大。到达的分组发现一个满的队列，该分组将会被路由器丢掉。丢失的比例随着流量强度的增加而增加。因此，一个节点的性能不仅根据时延来度量，也根据丢包的概率来度量。后面会说到，丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源送到了目的地。 端到端时延前面的讨论集中在节点时延上，即在单台路由器上的时延，这里考虑从源到目的地的总时延(端到端时延)端到端的时延就是源主机的时延和路由器时延之和，即节点时延的总和 计算机网络中的吞吐量 瞬时吞吐量A向B发送数据，任何时间瞬间B接收该文件的速率 平均吞吐量A向B发送大小为Fbit的文件，B接收所有Fbit用了Ts，则平均吞吐量为F/T 服务器传送一个文件到客户端，两者之间只有一台路由器 假设Rs为服务器和路由器之间的链路速率 假设Rc为路由器和客户端之间的链路速录 假设网络中只有该服务器到客户端的bit在传送 那么服务器到客户端的吞吐量就是min(Rs,Rc)我们想象bit是流体，链路是管道。显然，这台服务器不能以超过Rs的速率发送bit，路由器也不能以超过Rc的速率转发，最终的吞吐量取决去两者中小的那一个。服务器传送一个文件到客户端，两者之间有N-1台路由器 那么就有N条链路 假设这N条链路的速率分别是R1、R2…Rn 那么服务器到客户端的吞吐量就是min(R1,R2…Rn)目前，因特网核心都超量配置了高速率的链路，很少发生拥塞，今天在因特网中对吞吐量的限制因素通常是接入网。但是并不绝对，当很多客户端和服务器公用一条共享链路时，由于链路需要同时为多个客户端服务器传输数据。这时共享链路可能称为限制吞吐率的因素。 协议层次机器服务模型各层的所有协议被称为协议栈。因特网协议栈由5个层次组成，从上到下依次是 应用层 运输层 网络层 链路层 物理层 下面就分别简要的说一下每一层 应用层网络应用程序以及它们的应用层协议存留的地方应用层协议包括 HTTP：HyperText Transfer Protocol(超文本传输协议)，提供了Web文档的请求和传送 SMTP：Simple Mail Transfer Protocol(简单邮件传输协议)，提供了电子邮件报文的传输 FTP：File Transfer Protocol(文件传输协议)，提供了两个端系统之间文件传送 DNS：Domain Name System(域名系统) …… 应用层协议分布在多个端系统上，端系统的应用陈旭之间使用协议交换信息分组。这种位于应用层的信息分组称为报文。 运输层因特网运输层在应用程序端点之间传送应用层报文。两种应用层协议 TCP：向应用程序提供了面向连接的服务，包括应用层报文向目的地传输的确保传递和流量控制(发送方/接收方速率匹配)TCP将长报文划分为短报文，并提供拥塞控制机制，当网络拥塞时，源抑制其传输速率。 UDP向应用程序提供了无连接的服务，没有可靠性、没有流量控制、也没有拥塞控制。 将运输层的分组称为报文段。 网络层因特网网络层负责将网络层分组(数据报)从一台主机移动到另一台主机。源主机中的运输层协议(TCP/UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信时提供的地址一样网络层协议 IP协议：该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。 路由选择协议：确定路由器的转发表。 …… 将网络层的分组称为数据报。 链路层因特网的网络层通过源和目的地之间一系列的路由器来路由数据报。为了将分组从一个节点(路由器/主机)移动到下一个节点，网络层必须依靠链路层的服务。 在每个节点，网络层将数据下传给链路层，链路层沿着路径(链路)将数据报传递给下一个节点。 到达下一个节点，链路层再将数据上传给网络层。 链路层提供的服务取决于应用于该链路的特定的链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。注意：这里的可靠连接服务不同于TCP的可靠传输服务。TCP提供从一个端系统到另一个端系统的可靠交付。链路层协议 以太网 WiFi 电缆接入网的DOCSIS协议 因为数据从源到目的地通常会经过几条链路，这些链路可能应用的链路层协议不同。网络层将受到每个不同链路层协议的不同服务将链路层的分组称为帧。 物理层链路层的任务是将整个帧从一个节点移动到临近的节点，而物理层的任务是将该帧的一个个bit从一个节点移动到临近的节点。该层的协议仍和链路层相关，并且进一步和该链路的实际传输媒体相关。例如以太网具有很多物理层协议： 关于双绞铜线的 关于同轴电缆的 关于光纤的 …… 封装数据从发送端系统的协议栈向下，沿着中间的链路层交换机的路由器协议栈上上下下，然后向上到达接收端系统的协议栈。 链路层交换机实现了第一层和第二层，即物理层和链路层 路由器实现了第一层到第三层，即物理层到链路层再到网络层。 这意味着路由器能实现IP协议，链路层交换机则不能。但是链路层交换机能够识别第二层地址如以太网地址。主机实现了所有5个层次，因为在发送数据时，需要将数据层层封装，最后封装为帧(链路层分组)，在接收数据时相反。因此主机必须实现所有的5个层次。 每一层的封装 在发送主机端应用层报文被传送给传输层 运输层传输层收取到报文并附上附加信息，该首部信息将被接收端的运输层使用。应用层报文和运输层首部信息一起构成了运输层分组—-报文段。并将该报文段传递给网络层。 网络层增加了源和目的地端系统的地址等网络层首部信息，运输层报文段和网络层首部信息一起构成了网络层分组—-数据报。并将该数据报传递给链路层。 链路层增加自己的链路层首部信息，网络层数据报和链路层首部信息一起构成了链路层分组—-帧。 所以我们看到，在每一层，一个分组具有两种类型的字段 首部字段：在当前层添加上的 有效载荷字段：该字段通常是来自于上一层的分组 实际上，封装的过程可能更加复杂。例如，一个大报文可能被划分为多个运输层的报文段(同样的，这些报文段可能被划分为多个网络层数据报)，在接收端，必须从其连续的数据包中重构这样一个报文段。 第一章内容大致就这些，后面的网络攻击就不说了。后续的等看完一章写一章吧，一共16k个字，纯手打。在记录的过程中无形中对第一章内容又回顾了一遍，很明显感觉得到理解的更深入了，希望看完这篇博客的你也能学到一些知识哦。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之选择排序]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说过了冒泡排序，这次来说一下选择排序。同样的，这次也会从算法思路、代码实现以及算法分析三个思路来剖析选择排序 算法思路 第一次从arr[0]和arr[n-1]中选取最小值，与arr[0]交换 第二次从arr[1]和arr[n-1]中选取最小值，与arr[1]交换 ……以此类推 第n-1次从arr[n-2]和arr[n-1]中选取最小值，与arr[n-2]交换 至此，得到一个从小到大的有序数组，一共进行n-1轮 对于一个数组arr={3,-1,9,10,-2} 代码实现12345678910111213141516171819202122public static void SelSort(int[] arr) &#123; int min; int index; //一共进行n-1趟排序，当确定了n-1个元素的位置后，最后一个元素的位置自然也就确定了 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //假定最大值为arr[i]，下标为i min = arr[i]; index = i; //找到i+1到最后一个元素的最大值，记录该元素的值和下标位置 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; min) &#123; min=arr[j]; index = j; &#125; &#125; //如果index发生了变化，说明arr[i]不是最大的，那么就将最大值和arr[i]交换 if (index != i) &#123; arr[index]=arr[i]; arr[i] = min; &#125; &#125;&#125; 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个min和一个index，和n的大小无关，所以是O(1) 稳定性 不难发现，选择排序不是稳定的 另外，该排序算法在n比较小时较好 和冒泡排序比较这里，我创建了一个80000大小的数组对其进行排序，分别使用冒泡排序和选择排序，并记录两种排序耗费的时间 冒泡排序 选择排序 通过上面的对比发现，对同样规模的随机生成的数组进行排序，选择排序要比冒泡排序快很多 通过查看两种排序的实现过程不难发现： 冒泡排序，每一趟排序中，相邻元素如果逆序，都要进行交换操作，整个排序过程会进行很多次交换操作 选择排序，每一趟排序中，只需要找到最大值/最小值的元素即其下标，最后只进行一次交换交换操作，整个排序过程最多进行n-1次交换操作 两方法时间上的差异就在这里体现的]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之冒泡排序]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[正如categories所言：算法之美，是的，算法是美妙的，尤其是好的算法，总会让人感到眼前一亮，让人茅塞顿开。而今天说到的排序算法，是我们日常生活中用的及其之多的一种算法，排序算法种类也有很多，这篇博客记录的是其中较为简单地一种——冒泡排序 算法思路 通过对排序序列从前向后(数组下标从小到大)开始，依次比较相邻元素的值 若发现两相邻元素逆序，则交换两相邻元素的位置，使值较大的元素逐渐从前移到后 第一趟排序使序列中最大的元素移到最后一个位置 第二趟排序使序列中第二大的元素移到倒数第二个位置 ……以此类推 一共需要n-1趟排序(n为序列的大小) 对于一个数组arr={3,-1,9,10,-2} 代码实现 优化冒泡排序因为每一趟排序都是将未排序部分的相邻元素进行比较，逆序则交换位置，那么反过来，在某一趟排序中，如果没有发生元素交换，说明该数组已经有序，就不用在进行之后的排序对于一个数组arr={3,-1,9,10,20} 设置一个boolean类型的flag，初始化为true 将循环趟数的条件改为flag==true&amp;&amp;i &lt; arr.length 在进入某一趟排序之前，先将flag设置为false。 如果在这一趟排序中，发生了相邻元素的交换，那么将flag重新设置为true 如果在这一趟排序中，没有发生相邻元素的交换，flag不变 在进行下一趟循环时，判断flag是否为true 如果为true，进行下一趟循环 如果为false，说明在上一趟排序中已经得到有序数组，那么不再进行下一趟排序 优化冒泡排序算法代码实现 12345678910111213141516public static void BuSortBatter(int[] arr) &#123; int temp; //设置一个flag，判断当前趟是否进行过交换 boolean flag = true; for (int i = 1; flag==true&amp;&amp;i &lt; arr.length; i++) &#123; flag = false; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; &#125;&#125; 同样对于上面的数组arr={3,-1,9,10,20}，使用优化冒泡排序这样就达到了优化的目的 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个临时变量和一个flag，和n的大小无关，所以是O(1) 稳定性 稳定性：即在排序过程中，对于两个大小相等的数A和B，排序前A在B的前面，如果排序后A还在B的前面，即排序前后不改变想等元素的顺序，那么称该排序方法是稳定的 不难发现，冒泡排序是稳定的 另外，该排序算法在n比较小时较好]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[八皇后问题一个古老而著名的问题，该问题是回溯算法的典型案例。在8*8格的国际棋盘上摆放8个皇后，使其相互不能攻击。即：任意两个皇后不能处于同一行、同一列或同意斜线上，问有多少中摆法？ 问题分析 第一个皇后先放在第一行第一列 第二个皇后放在第二行第一列，然后判断是否满足条件 不满足：继续放在第二行第二列…依次把所有列放完，找到一个合适的位置 满足：摆放下一个皇后(递归) 直到第八个皇后也能放在一个满足条件的位置，就算找到一个正确解(递归出口) 当得到第一个正确解时，就会开始回溯，即将第一个皇后放在第一列的所有正确节点全部找到 然后回头继续将第一个皇后放在第二列，后面继续循环执行上面的步骤 一维数组代替二维数组理论上，我们应该创建一个二维数组表示棋盘，但实际上可以通过算法，用一个一维数组解决问题例如：arr[8]={0,4,7,5,2,6,1,3} 数组arr的下标：表示第几行，即第几个皇后 arr[i]=val：表示第i+1个皇后放在第i+1行的val+1的位置 检查冲突的方法该方法用于检查当前第n个皇后和前面的n-1个皇后是否发生冲突(即是否在同一行、同一列或同一斜线上) arr[n] == arr[i]：数组的值表示的是列，这里是判断第i+1个皇后是否和第n+1个皇后在同一列 Math.abs(n-i)==Math.abs(arr[n]-arr[i])：判断第i+1个皇后是否和第n+1个皇后在同一斜线 Math.abs(n-i)：第i+1个皇后和第n+1个皇后的行数差 Math.abs(arr[n]-arr[i])：第i+1个皇后和第n+1个皇后的列数差如果行数差==列数差，说明两个皇后在同一斜线上 递归回溯方法 首先，创建一个长度为9的数组，0-7用于表示8个皇后，最后一个用于记录摆放方法个数 当n==MAX=8时：之前说过，n代表第n+1个皇后(例如n=0时代表第一个皇后)，那么n=8应该代表的是第9个皇后，这时候说明前8个皇后都已经摆放好了，即找到了一种摆放方法 arr[MAX]++：个数+1； 打印当前摆放方法 n&lt;MAX说明皇后还没有摆放完，先将当前皇后摆放在第i列，检查这个位置是否和前面已经摆放的皇后位置冲突 如果不冲突，递归调用方法，摆放下一个皇后 如果冲突，i++，回到第3步。(即将当前皇后摆放到下一列，继续判断) 当找到一种正确方法后，会向上回溯 前面7个皇后位置不变，将第8个皇后从当前列往后摆，找到所有正确的摆法 前面6个皇后不变，将第7个皇后向后摆放1列 将第8个皇后从第1列往后摆，找到所有正确的摆法 回到第2步，直到将第7个皇后摆放到最后1列，找到所有正确的摆法 前面5个皇后不变…. 以此类推，直到最后将第1个皇后摆放到最后1列。这样，就找到了所有正确的解法！]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫问题]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[迷宫问题有一个迷宫，迷宫中有一个小球，要求给小球一个起始位置和迷宫的终点位置，给小球找到一条路能够到达终点位置。 构建迷宫 用一个二维数组模拟迷宫 用1表示围墙和障碍物 用2表示小球从起始位置到终点位置走过的点以下就是构建好的迷宫 递归解决 定义一个方法、传递一下参数 毫无疑问、要将map二维数组传递进去 将小球的起始位置传递进去 由于这里默认出口是最右下角，就不传递终点位置了 递归出口：前面说到了，用2表示小球走过的点，那么当终点位置map[6][5]==2时，说明小球已经走到了终点，递归结束 判断当前点map[i][j]是否为0,如果为0 先假定通过当前点能到达终点位置，即将当前点设置为2 设置寻路策略：即每次到达一个点，就会有上下左右四种走法，所谓寻路策略，即指定小球先向哪个方向走，该方向走不通后再向哪个方向走，这里我指定的寻路策略是下右上左 如果该点的四个位置都走不通，那么说明该点不通，此时将当前点设置为3，即map[i][j]=3,表明该点走过，确认走不通 如果不为0，那么当前点的取值情况有三种 map[i][j]==1，说明该点为墙，走不通，返回false map[i][j]==2，说明该点走过了，就不能再走了，返回false map[i][j]==3，说明该点已经确定了走不通，返回false 找到出路最后根据我下右上左的寻路策略找到的路线其中2代表的就是起点到终点的路线，通过不同寻路策略找到的路线可能不同 对于递归解决迷宫问题，我想可以这么理解每次走到一个点时，都会按照寻路策略的顺序走 如果某个方向能走通，那就继续往下走 如果到了某个点时，该点四个方向都走不通，那么就回溯，即回到该点的上一个节点，从上一个点的其他方向继续走 例如：对于A点，我们按照寻路策略先向下走，走到了B点，这时候发现，B点四个方向都走不通，那么就回退到A点，按照寻路策略向右走。以此类推，直到找到终点和每个点都被标记为3。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰计算器]]></title>
    <url>%2F2019%2F09%2F16%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[今天重新学习了一下栈这一经典的数据结构，突然想起来当时大二为了进实验室用安卓写的一个计算器app，当时也是年轻，虽然写出来了，但是对于中缀转后缀却仍是似懂非懂、迷迷糊糊，所以趁着刚复习完栈这个号时候，准备趁热打铁，把这方面给弄明白了。 概念什么是中缀表达式中缀表达式，就是我们平常见到的表达式，例如1+((2+3)*4)-5。它便于我们理解和计算，但是却不利于计算机来运算，因为在运算过程中需要不停的判断操作符优先级 什么是后缀表达式后缀表达式，又称为逆波兰式，上面的1+((2+3)4)-5。转换成后缀表达式就是123+4+5-，计算机在计算后缀表达式的时候，不用判断操作符的优先级，每次遇到操作符，直接从栈中弹出两个操作数进行相应的运算即可，但是这样的表达式对我们来说写出来就比较困难，尤其是在表达式比较长比较复杂的时候。 中缀转后缀首先，我先说一下我的大致思路 将中缀表达式的字符串存储到一个ArrayList中==&gt;这一步主要是方便操作、 一个存放操作符的栈s1 注意：网上大多的教程是准备两个栈，一个存放操作符，一个存放的是逆序的后缀表达式，但这里我用ArrayList集合代替了第二个栈，这样做的好处就是可以直接得到后缀表达式，而非逆序的，至于为什么后面会说 中缀表达式集合 遍历字符串 如果当前字符是操作符，那么直接加入到集合中 如果当前字符是操作数，那么就要考虑多位数操作数的问题 继续向后遍历，如果后面的字符仍是操作数，就将这些数拼接起来 直到当前字符不是操作数为止，将拼接的字符串加入到集合中 判断操作符优先级 后缀表达式集合上一步我们得到了一个集合，集合中存储着中缀表达式内容，这一步就要将中缀表达式转换为后缀表达式并存储到集合中步骤： 创建变量 栈s1用于存放操作数 集合ls用于存放后缀表达式 遍历中缀表达式集合list，如果是操作数，直接放到ls集合中 如果是”(“，直接压入s1中 如果是”)”，将s1中的操作符出栈并加入到ls集合中，直到s1栈顶元素为”(“为止，最后将”(“也出栈(但是不加入ls中)，这一步操作目的是消去”()” 如果是操作符 如果s1栈为空，那么直接入栈 如果当前操作符优先级大于栈顶操作符优先级，将当前操作符入栈 如果当前操作符优先级不大于栈顶操作符优先级，那么将栈顶元素出栈并加入到ls集合中，继续和新的栈顶操作符比较，直到栈为空或者当前操作符优先级大于栈顶操作符优先级为止 将当前操作符压入s1中 集合list遍历完毕后，将s1中所有元素依次出栈加入到ls集合中 最后得到的ls集合就是后缀表达式 注意：这里如果用栈代替集合，那么由于栈先进后出的特性，得到的只能是逆序的后缀表达式，还要进一步的转换才能得到后缀表达式 计算后缀表达式 创建一个栈stack用于存放操作数 从左向右扫描后缀表达式集合 如果是操作数，直接入栈 如果是操作符，就从stack中弹出两个操作数进行运算，并将运算结果重新入栈 集合遍历完毕，stack剩下的元素就是最后的结果 这样一个简单地逆波兰计算器就成功了，核心逻辑在于如何利用栈将中缀表达式转换为后缀表达式(逆波兰式)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的环问题]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先，关于单链表的环，一般涉及到以下几个问题 给一个单链表，判断是否有环 如果存在环，找出环的入口点 如果存在环，求出环上节点的个数 如果存在环，求出链表的长度 判断是否有环解法一：快慢指针法 有两个指针fast和slow，开始时两个指针都指向链表头head 将两个指针同时向后移动 fast每次走两步==&gt;fast=fast.next.next slow每次走一步==&gt;slow=slow.next 如果没有环，那么fast和slow一定不会相遇；当fast.next==null||slow==null时说明该链表没有环，因为有环的链表没有nul指针 如果有环，那么slow一定会和fast相遇,并且此时slow指针最多绕环一圈，即slow走的步数一定小于等于单链表的节点数 可以这么理解，当链表时环形链表时，环是最大的，此时slow刚好绕环一圈回到头指针指向的节点时 fast的速度是slow的二倍(因为fast每次走2步)，所以fast此时一定走了两圈，也回到了头指针指向的节点，最终会在头节点相遇 如果链表不是环形链表，那么环的长度就会更短，此时fast一定能在slow走完一圈之前和slow相遇 (可以画图帮助理解)方法返回的是相遇的节点 解法二：HashSet法 遍历链表，将当前节点的引用存储到HashSet中 如果当遍历到某个节点时，HashSet集合中已经存在该节点的引用，那么说明该链表有环，并且第一个重复的节点就是入环口 找出环的入口点如果用HashSet方法来解决第一个问题，那么这个问题就同时得到了解决如果用快慢指针法解决第一题，那么得到fast和slow第一次相遇的节点， 假设slow和fast相遇时，slow还没有走完链表，即链表不是首尾相接的环形链表分析 假设 链表的长度为L 环的长度为r(即环有r个节点) head节点到入环口的距离为a(即从head到入环节点要走a步) 入环口和相遇点的距离是x(从入环节点到相遇点要走a步) 假设fast和slow相遇时，fast已经在环内循环了n圈，slow走了s步，在环内走一圈的步数=环的长度 那么fast走过的步数为：2s步 则有：2s=s+n *r–&gt;s=nr 又有s=a+x–&gt;因为前面说过slow节点没有走完一圈，所以这就是最简单的步数相加 所以得到a+x=n*r a+x=(n-1)*r+r a+x=(n-1)*r+L-a a=(n-1)*r+(L-a-x) a：head到入环节点要走a步 (L-a-x)：从向相遇节点到入环节点要走(L-a-x)步 经过上面分析可以总结得到解决方法 设置两个临时指针str1和str2 str1=head str2=slow(slow是第一问得出的相遇节点) 让两个节点同时往后走，直到str1==str2为止 str1=str1.next str2=str2.next str1==str2时退出循环，此时的str1/str2就是入环节点 特殊情况：即链表首尾相接(环长度最大) 此时slow节点和fast节点在head相遇，即slow==head 根据上面的代码会直接返回head/slow，因此也满足特殊情况 求出环上节点的个数解法一：相遇节点法 设置一个临时指针temp=slow(相遇节点) 让临时指针temp后移–&gt;temp=temp.next，并记录移动次数count 当temp==slow时，说明temp绕环走了一圈，count就是换的长度 解法二：快慢指针法 设置两个临时指针，str1=str2=slow(相遇节点) str1每次走一步、str2每次走两步，并记录str1走的步数count str1=str1.next str2=str2.next.next 当str1==str2(再次相遇)时，说明str2刚好比str1多走1圈，此时count就是环上节点的个数 假设再次相遇时str1走了s步、str2走了2*s步、环的长度为r 由分析得到2*s=s+r，所以s=r; 求出链表的长度链表长度L=head节点到入口节点的距离a+环的长度r根据上面两个问题，这个就很好解决]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>HashSet</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Josefu问题(约瑟夫环)两种解决方法]]></title>
    <url>%2F2019%2F09%2F15%2FJosefu%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF-%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[约瑟夫问题设编号为1、2….n的n个人坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出圈，他的下一位又从1开始报数，数到m的人又出圈，以此类推，直到所有人出圈为止，由此产生一个出圈编号的序列 解法一：循环链表 首先对参数k、m、n进行校验，确保k、m、n在正常范围内 创建一个辅助指针helper 让helper指向first前一个节点，即指向最初链表的最后一个节点 将first和helper向后移动k-1次，即让first指向开始报数的小孩 当helper==first时，说明圈中只有一个小孩 helper！=first时，将first和helper同时向后移动m-1次 将移动m-1此之后first指向的节点出圈 继续执行5，直到helper==first为止 其中方法的参数： k：第一次开始报数的小孩 count：每次数几下(m) nums：最开始圈中小孩数 这个约瑟夫问题是基于我自己创建的单向环形链表实现的(或者说我创建的单向环形链表是用来解决约瑟夫问题的)，helper节点最初就指向first前一个节点，所以2和3两步骤可以省略(可以看一下我创建单项循环链表的博客) 解法二：数组对于数组，进行出圈操作的时候就不能向链表一样删除节点了，因为数组的长度是固定的，那么怎么解决呢？我们可以将已经出圈的孩子所在的元素值赋值为0，这样，当我们遍历到元素值为0的节点时，就可以跳过该节点。步骤： 首先对参数k、m、n进行校验，确保k、m、n在正常范围内 因为数组下标是从0开始，小孩编号从1开始，所以让开始数数的小孩编号-1==&gt;k=k-1 根据nums创建数组，模拟nums个小孩组成的圈 一共有nums个小孩，所以一共要循环报数nums次==&gt;for (int i = 0; i &lt; nums; i++) {} 每一次报数m次，所以k要移动m-1次(起初报数时，自己也算一次)，当k代表的数组元素a[k]==0时，说明当前孩子已经出圈，所以需要k再次移动，直到a[k]!=0==&gt;for (int j = 0; j &lt; m - 1||arr[k]==0;) {} 第5步得到的k是该赋值为0的元素，即该出圈的孩子编号-1==&gt;k+1即为当前该出圈的孩子编号 a[k]=0，并且将k取模移向下一位 重复567nums次，直到所有孩子都出圈]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>环形链表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-环形链表]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[环形链表，顾名思义，就是整个链表构成一个环，将单链表的最后一个节点的next指针指向头节点，这样就构成了循环链表。这里说的循环链表主要用于解决约瑟夫环问题和判断链表是否有环两个算法问题。 环形链表节点 int val：存储数据 Node next：指向另外一个Node节点 单向循环链表成员变量 head：环形链表的头指针 helper：环形链表的尾指针，每次都指向新插入的节点(helper.next=head) 成员方法public void Add(int ele)向链表中添加元素 在添加之前，判断当前链表是否为空 如果为空 将head头指针指向新创建的节点==&gt;head=new Node(ele) helper指针也指向新创建的节点==&gt;helper=head 将新创建节点的next指针指向head，构成一个环==&gt;helper.next=head 如果不为空 将helper指针指向节点(尾节点)的next指针指向新节点==&gt;helper.next=new Node(ele) 将helper指针向后移，保证helper指针仍然指向尾节点==&gt;helper=helper.next 将尾节点的next指针指向head头节点，形成一个环==&gt;helper.next=head 环形链表，其实就是将单链表的尾节点的next指针指向头节点 public void show()打印环形链表逻辑比较简单，因为在打印的过程中指针会移动，所以可以创建两个临时变量，这样打印过后head和helper指针都没有发生变化，下次添加元素的时候仍然能够按照顺序添加 单链表的两个算法问题会在算法之美分类中说到]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>环形链表</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队列]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列的特点：FIFO–&gt;First in First out，即先进先出这篇文章讲的是数组结构存储队列，队列从功能上来说分为两种 普通队列 循环队列。 后面将会分别用Java手写两个队列类来讲述普通队列和循环队列 普通队列概述队列本身是一个有序列表，因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队头和队尾 front会随着数据输出而改变 rear会随着数据输入而改变 成员变量 private int maxSize; –&gt;队列最大容量 private int front; –&gt;队列头 private int rear; –&gt;队列尾 private T[] arr;(使用泛型) –&gt;队列存储结构：数组 构造方法这里创建了两个构造方法： 通过参数确定数组大小，即队列的容量 无参构造方法默认数组大小为10 front和rear指向的位置 front：指向队列头的前一个位置 rear：指向队列最后一个元素 成员方法public boolean isFull()对于非循环队列来说，判断队列是否已满很简单，只需要判断rear是否到达数组末尾即可 public boolean isEmpty()对于非循环队列来说，队列为空就是初始状态，即rear==front public void Add(T ele)对于添加元素的方法，有两个步骤 先判断队列是否已满 如果队满，抛出异常 否则，先将rear后移，再进行赋值操作 public T get()取队头元素的方法，同样有两个步骤 判断队列是否为空 如果队空，抛出异常 否则，先将front后移指向队头元素，再返回队头元素 public void show()打印当前队列所有元素 以上就是一个基本的普通数组模拟队列类，不难发现这样的队列是有很大缺陷的 无法复用：即只能用一次，当front指向arr[maxSize-1]的时候，就算此时队列中没有元素，也无法向队列中添加数据。下面来说循环队列 循环队列成员变量 private int maxSize; –&gt;队列最大容量 private int front; –&gt;队列头 private int rear; –&gt;队列尾 private T[] arr;(使用泛型) –&gt;队列存储结构：数组 构造方法这里创建了两个构造方法： 通过参数确定数组大小，即队列的容量 无参构造方法默认数组大小为10 front和rear指向的位置和普通队列不同 front：指向队列头元素 rear：指向队列尾元素的后一个位置 为了便于循环，rear指向的位置自始至终都是空着的，即队列的容量=maxsize-1 public boolean isFull()在循环队列中，判断队满的条件(rear+1)%maxSize==front public boolean isEmpty()在循环队列中，判断队满的条件仍是rear==front，因为rear指向的位置是不存放元素的，当front==rear时，说明队列已经没有元素了 public void Add(T ele)在循环队列中，当rear到达队列末尾时，我们需要它从0开始，因此不能+1，要用取模运算 public T get()在循环队列中，对于front也要用取模运算 public int getNum()对于(rear - front + mixsize) % mixsize运算，可以这么理解 当rear&gt;front时候，说明所有的元素都处于rear和front中间，num=rear-front 当rear&lt;front时候，说明所有元素都处在rear和front两边，即rear比front多走了一个mixsize的长度，num=rear+maxSize-front; 因此两者加起来就是(rear - front + mixsize) % mixsize public void show()特别注意循环条件，i从front开始，做带循环的后移(取模)，直到i==rear是遍历完所有元素]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--稀疏数组]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%C2%9E%2F</url>
    <content type="text"><![CDATA[这篇文章主要讲的是数组的应用之一–稀疏数组。那么什么是稀疏数组呢？我们来看一个问题：假设你做了一个五子棋游戏，玩儿过的都知道这个游戏有一个叫做复盘的功能，就是你可以将这句游戏先存档，之后再读档的时候就会接着之前的继续下。我们都知道 用二维数组来构造棋盘 用0表示棋盘上没有落子的位置 用1和2分别表示黑棋和白棋的位置 存档：把二维数组通过流保存到硬盘中那么这里面就有一个问题：如果要存档的棋盘中有大片的空白(数组中有大量的元素为0)，直接将原数组存储进去会浪费空间，这时候可以用到稀疏数组来压缩 稀疏数组的结构行 稀疏数组的行数取决于原数组非0元素的个数–&gt;row=num+1; 第一行存储着原数组的信息 [0][0]=原数组的行数 [0][1]=原数组列数 [0][2]=原数组非0元素的个数 剩下的每一行都存储着原数组非0元素的信息 [i][0]=元素所在行 [i][1]=元素所在列 [i][2]=元素的值 稀疏数组的行数row=num+1：稀疏数组的第一行要用来存储原数组的信息，在还原的时候会用到 列 所有的稀疏数组都只有3列 除了第一行外： 第一列存储非0元素的行位置 第二列存储非0元素的列位置 第三列存储非0元素的值 上面说的非0元素，只是在数组中存在的大量重复元素值为0时的情况 数组–&gt;稀疏数组假设存在一个数组 遍历原数组，获取非0元素的个数 创建稀疏数组 稀疏数组的行数row=num+1 稀疏数组的列数col=3 将原数组信息存储到稀疏数组第一行 稀疏数组的第一行，存储原数组的行数、列数以及非0元素个数 遍历原数组，储存其中非0元素的信息 每一行的第一列存储元素的行信息 每一行的第二列存储元素的列信息 每一行第三列存储元素的值 最后得到的稀疏数组 稀疏数组–&gt;数组 创建普通数组 数组的行数为稀疏数组第一行第一列的值 数组的列数为稀疏数组第一行第二列的值 遍历稀疏数组的每一行 当前行的第一列为元素的行位置 当前行的第二列为元素的列位置 当前行的第三列为元素的值 最后得到原数组 通过实际操作我们发现，将数组转换为稀疏数组后，节省的空间还较为客观，当要存储的数组中含有大量的重复元素时，我们可以采用稀疏数组来存储，能够在一定程度上节省空间]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--String类]]></title>
    <url>%2F2019%2F09%2F10%2FJDK%E6%BA%90%E7%A0%81-String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[这一篇的String源码基于JDK8版本，来自于慕课网上文贺老师的JAVA源码专栏(收费)结合张家界的雪以及自己学习String源码的总结，主要的目的在于总结知识，方便后续回顾查看，如转载，请注明出处 成员变量在学习String源码之前，首先要知道String对象再内存中的存放位置，我们都知道JAVA对象一般都是存放在堆中，但是String对象是一个特例，它被存放在常量池中可以看到，String类实现了 Serializable：序列化接口，String对象可以被序列化 Comparable：表明字符串可以比较 CharSequence：表明String对象是一个字符序列 String底层实现是一个char类型的数组并且被final修饰 构造方法public String()值为空串，很少使用 *public String(String original)这个构造方法在创建的过程中会创建两个对象，一个在堆中，一个在常量池中当调用这个构造方法时String str=new String(“abc”) 现在堆中new出一个String对象，并将str指向该对象 查看常量池中是否存在”abc” 如果不存在，那么就会在常量池中在创建一个String对象 如果存在，不做操作 最终str是指向堆中的对象，而不是常量池中的对象 str1和str3都是指向常量池中的”abc”对象，所以str1==str3返回true str4涉及到了变量的相加，内部实现是先new一个StringBuilder，然后 append(str2),append(“c”);然后让str4引用toString()返回的对象;如图，StringBuilder的toString方法实质上也是new了一个String对象，所以str4指向堆中的另外一个String对象，所以str1==str4返回false 上面说了，str5指向堆中的一个String对象，所以str1==str5返回falsepublic String(char value[])如图，该构造方法实质上是调用Arrays工具类的copyof方法public String(char value[], int offset, int count)如图，该构造方法会先对起始位置进行判断，如果不合法会抛出异常。最后调用Arrays工具类的copyOfRange来实现public String(byte bytes[], int offset, int length, String charsetName)如图，该构造方法用byte数组构造String对象，用指定字符集转换后构造String对象。其中StringCoding.decode(charsetName, bytes, offset, length)方法根据指定编码对byte数组进行解码，返回char数组checkBounds方法是对参数进行检查，该方法为私有，只能在String类中使用该构造方法如果不指定charsetName，那么按照系统默认字符集进行解码public String(StringBuffer buffer)通过StringBuffer构造String，因为StringBuffer内部也是一个char数组，所以实质上还是调用Arrays.copyOf方法实现，并且由于StringBuffer是线程安全的，所以这里也加了synchronized块保证线程安全通过StringBuilder构造String对象和StringBuffer原理相同。不过由于StringBuilder是线程不安全的，所以没有加synchronized块*String(char value[] boolean share)这个构造方法是protected修饰的，它和public String(char value[])的区别在于多了一个boolean参数，并且不支持false只支持true，这样做的原因是为了和public String(char value[])方法进行区分，否则没办法构成重载，查看方法体可以发现，它直接将char数组的的地址传递给String对象，要比注意拷贝快很多但是这样做的弊端很大：String对象和char数组共享同一块内存，破坏了String的不可变性，所以将该构造方法设置为protected保证安全,但是由于性能比较好，节约内存，所以replace、concat、valueof等方法也用到了这个构造方法 成员方法public int length()返回char数组的长度 public boolean isEmpty()char数组长度是否为0 public char charAt(int index) 判断index是否超出char数组长度，超出则抛异常 否则返回value[index]。 public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)将String对象指定的字符从dst[]数组的dstBegin位置向后复制,通过System.arraycopy实现，这是一个本地方法(native)。参数： srcBegin：复制的起始位置(包括) srcEnd：复制的结束位置(不包括) dst[]：目的数组 dstBegin：目的数组dstBegin起始 如果要复制的字符个数srcEnd-srcBegin&gt;dst.length-dstBegin,会抛出异常 public byte[] getBytes(String charsetName)和前面传递Byte数组的构造方法相反，这里将String对象的value数组按照指定字符集编码成字符数组并返回如果不指定字符集，按照默认字符集编码 public boolean equals(Object anObject)重写了Object的equals方法 public boolean equalsIgnoreCase(String anotherString)先判断地址是否相同，地址相同内容肯定相同，再判断长度是否相同，如果长度一样再调用regionMatches方法进行判断，这里用了&amp;&amp;运算符的断路原理regionMatches方法有两种形式 没有boolean参数的 有boolean参数的 该方法的作用是区域比较，比较两个字符串指定长度的内容是否相等，从指定位置开始逐一比较字符数组内容是否相等两方法的区别在于：如果booloean参数为true，那么当字符不相等时 先将两字符转换成大写字符比较，还不相等 将两字符转换成小写比较，还不相等返回false 和String的内部类实现原理一样 public int compareTo(String anotherString)这个方法是实现Comparable接口的方法，用于对字符串大小进行比较这个方法取了两个字符串长度较小的那个作为循环次数，对两个字符串进行逐位比较。 如果不同，就返回两字符串不同那一位字符的差 如果都相同，就返回两字符串的长度差 差的计算:调用方法的字符串-参数字符串 public int compareToIgnoreCase(String str)该方法实际上是调用了静态内部类对象的忽略大小写的compareTo方法 public boolean startsWith(String prefix, int toffset) public int hashCode()重写了Object的hashCode方法在JAVA中，hashCode有两个作用： Object的hashCode返回对象的内存地址 重写的hashCode配合基于散列的集合使用 在使用散列集合例如HashMap时，要保证key唯一，但是对于大量元素比较时直接比较equals效率低下，可以先判断hashCode，如果hashCode相等，然后判断equals，因为不同的对象其hashCode值可能相同，例如”通话”和”重地”、”Aa”和”BB” 为了使字符串计算的hashCode尽可能地少重复(降低哈希冲突)，这里采用的是31这个乘数，有两个好处 31是个不大不小的质数，是作为hashCode乘子的优秀质数之一 31可以被JVM优化，31*i=(i&lt;&lt;5)-i(暂时没弄明白JVM优化) public int indexOf(int ch, int fromIndex)作用：找到ch字符从字符串fromIndex位置开始第一次出现的位置方法中的判断条件ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT是什么意思呢？我们知道，在JAVA中，一个char类型字符占2个字节也就是16位 当参数中的ch在这个范围内时，就在String中从fromIndex开始逐一查找ch第一次上出现的位置 当参数超过这个范围(即大于65535)时，调用indexOfSupplementary()方法进行比较 通过查看Character源码可知这个数值就是65535 public int indexOfSupplementary(int ch, int fromIndex)这个方法是private修饰的，只能由String内部调用，用来处理当参数ch大于2个字节时的查找方法不难发现，它将ch字符拆分成高低位来查找，高位和value[i]比较，低位和value[i+1]比较lastIndexof逻辑和Indexof基本类似，不多说 public int indexOf(String str, int fromIndex)参数为字符串，实际上比较的时字符串里的char数组方法是保护的，只能在包内调用 首先分析一下方法的参数： char[] source：调用方法的字符串内部数组–&gt;暂且称为源数组 int sourceOffset：数组的起始位置(一般是0) int sourceCount：数组的长度 char[] target：参数字符串的内部数组–&gt;暂且称为目的数组 int targetOffset：数组的起始位置(一般是0) int targetCount：数组的长度 int fromIndex：从源数组fromIndex位置开始向后查找 前三个if条件判断 当fromIndex &gt;= sourceCount(即指定的起始搜索位置大于源数组数组的长度)时 判断目的数组是否为空串 若为空，则返回源数组的长度 不为空，返回-1 当指定起始搜索位置小于0，默认从0开始搜索 当目的数组为空，并且fromIndex在正常范围内，返回fromIndex 找源数组和目的数组第一个字符相同的位置记为i 逐一比较接来的字符是否相等，如果遍历完目的数组后仍相等，返回i，不相等进行5 从源数组第i个位置后找与目的数组第一个字符相等的位置，再比较接下来的每一个字符是否相等 一直循环查找直到找到i并返回，或源字符串遍历完毕返回-1对于几种特殊情况的测试public int indexOf(String str)默认fromIndex=0，调用上面的indexOf方法 public int lastIndexOf(String str, int fromIndex)逻辑和上面个一样，都是调用比较char数组的保护方法，需要时查看一下JDK8的源码 public String substring(int beginIndex) 对beginIndex进行判断 beginIndex&lt;0，抛出StringIndexOutOfBoundsException异常 大于源数组的长度，抛出StringIndexOutOfBoundsException异常 begin=0，直接返回当前字符串 调用String(char[] value,int beginIndex,int count(value.length-beginIndex))来实现 public String substring(int beginIndex, int endIndex)逻辑和上面一样(含头不含尾) public String concat(String str)拼接字符串，将str拼接到this串后面 如果参数串为空串，直接返回this(当前字符串) 调用Arrays.copyOf方法创建一个新的字符串buf，长度为this.length+str.length，内容为this.value 调用String类的getChars方法，将str复制到buf串中(从buf串的this.length位置开始) 调用String类的protected修饰的构造方法，直接将buf串的地址赋值给新创建的字符串对象–&gt;参考前面protected的构造方法 大致上来说，该方法的实现原理：先创建一个字符数组，复制了两个字符串中的内容，然后通过String(char value[] boolean share)方法来new一个新的字符串因为buf串是在方法内部创建的，外部是不可见的，因此不会破坏String对象的不可变性 public String replace(char oldChar, char newChar)将字符串中所有的oldChar替换为newChar 如果OldChar==newChar，直接返回当前字符串 找到字符串中第一个OldChar，记录位置为i； 新建一个char数组buf，将字符串赋值给buf数组，从buf的i开始，将所有的OldChar替换为newChar 通过String(char value[] boolean share)来创建新的字符串对象并返回 说一下为什么要重建一个val数组，用val数组给buf数组赋值，而不直接用value数组赋值呢？上网查阅，val数组是局部变量，value数组是类变量，getfield操作是一个访问类变量的操作当使用value数组循环赋值的时候，每一次循环都会有一个getfield操作入栈使用局部变量val时，只有一次getfield操作操作，就是将value数组赋值给val的时候当数组长度很大的时候，使用局部变量性能会更好一些(大神真不愧是大神，太细节了) public boolean contains(CharSequence s)判断字符串是否包含制定的字符序列，实际上是调用indexOf(String str)方法，查找序列在字符串中出现的位置来判断的，如果不包含返回-1。 public String toLowerCase()/toUpperCase()对字符串进行大小写转换，只对英文字符有效 public String trim()去掉两端空白字符(空格、tab、回车符) 从左到右循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置st 从右往左循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置len 如果st=0并且len=value.length，说明该字符两端没有空字符，直接返回字符串 否则，调用substring(st, len)方法获取去掉首尾空字符的字串。 通过分析：一个首尾没有空字符的str调用trim方法，返回它本身，所以得到的新String对象地址相同一个开头或结尾存在空字符的str调用trim方法，返回的新String对象是new出来的，两者地址不同 public String toString()返回他自身 public char[] toCharArray()创建一个resault数组，调用System.arraycopy方法将value复制给resault数组并返回不能直接返回value数组，破坏了String的不可变性源码中有一行注释：Cannot use Arrays.copyOf because of class initialization order issues，由于类初始化顺序问题，不能使用Arrays.copyOf方法可能的原因：String初始化比Arrays早，但是在JDK中存在其他对象使用了toCharArray()方法，而这个对象初始化比String晚但是比Arrays早，导致在使用时Arrays还没有初始化完成而报错而Syatem.arraycopy不会有这样的问题，因为这是本地方法 public static String valueOf系列方法直接查看JDK源码即可，很简单，就不赘述 public native String intern();本地方法，详细解释请见传送门，讲的挺好传送门1传送门2 静态内部类实际上就是String内部定义的一个比较器，用于忽略大小写比较字符串是否相等，CompareToIgnoreCase方法用到了这个类 到这里String类也大致总结完了，但是对于String类，我想要学的远不止这些，做这些只是整理方便后期学习理解，如果哪里不对或者有其他源码学习途径，欢迎私信我一起讨论交流，让我们一起学习，共同进步 暂时只能通过微博，后续会开微信公众号来一起交流，毕竟现在实力还不够]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--SQL语句总结(二)]]></title>
    <url>%2F2019%2F09%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[今天初步的做了一个web的小Demo，才发现数据库操作对于Web开发的重要性，频繁的对数据库进行操作，发现才学完数据库没多久，连基础的CRUD语句都写不出来，真是让人头大。突然想起来之前的SQL语句还有一半没有总结，现在趁着手机没电不能继续做Demo，就花30分钟左右的时间来总结一下剩下的DQL语句和DCL语句吧 DQL语法 select *from +表名 select字段列表 from表名列表 where条件列表 group by分组字段 having分组之后的条件 order by排序 limit分页限定 基础查询基于上面这个表进行演示 多个字段的查询 select 字段名1，字段名2… from 表名 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复：如果要单独查地址栏：SELECT address FROM student; 就会发现有多个香港地址但是在这种情况下我们并一般不希望出现这种情况 在select后面加distinct关键字就可以取出要查询的字段中重复的值格式：SELECT DISTINCT address(字段名) FROM 表名; 计算列 可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 表达式2：如果该字段为null后的替换值。 如图，计算英语成绩和数学成绩之和SELECT NAME,math,english,math+english FROM student;因为英语这一列存在null值，所以就会导致数学和英语的和也为null，这显然是不合理的使用ifnull，如果字段为null，就会在相加的时候替换为0；SELECT NAME,math,english,math+IFNULL(english,0) FROM student; 起别名： as：as也可以省略上面再计算列的时候，最后的列的值发生了变化，变成了(math+english)，顾名思义，其别名就是将列名换一个自己的名字SELECT NAME,math,english,math+IFNULL(english,0)AS 总分 FROM student; 条件查询 在where子句后面跟查询的条件 运算符 &lt; 、&gt;、&lt;= 、&gt;= 、= 、&lt;&gt;(不等于，相当于！=) BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! 实例演示 查询年龄大于20岁的：SELECT *FROM student WHERE age&gt;20; 查询年龄在20~30岁之间的(三种方法)SELECT *FROM student WHERE age BETWEEN 20 AND 30;/age&gt;=20&amp;&amp;age&lt;=30;/age&gt;=20 AND age&lt;=30; 查询年龄22岁，18岁，25岁的信息(查询满足指定条件的数据)SELECT *FROM student WHERE age IN(19,22,25);age=22 OR age=19 OR age=25;/age=22 || age=19 || age=25; 查询英语成绩为null–&gt;不能用=和！=来判断是否为null，要用is和is not来判断SELECT * FROM student WHERE english IS NULL; 查询姓马的有哪些 模糊查询–likeSELECT *FROM student WHERE NAME LIKE “马%”;因为用的%占位符，所以马后面不管有几个字符，都符合条件排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2… 排序方式： ASC：升序，默认的。 DESC：降序。 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 实例演示 按照数学成绩排名(默认升序排列)SELECT *FROM student ORDER BY math; 按照数学习成绩升序排名，如果数学成绩一样，就按照英语成绩升序排名。SELECT *FROM student ORDER BY math ASC,english ASC;聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 实例演示 某一列数据总行数(如果这一列有null值，那么为null的行不算)SELECT COUNT(english) FROM student;这时候还要用到ifnull计算行数的时候将null临时替换为0，SELECT COUNT(IFNULL(english,0)) FROM student;使用SELECT COUNT(*) FROM student;来计算行数，只要这一组数据中有一列数据全不为null，就能够正确的计算行数 计算数学成绩最大值(max)其余的min、sum以及avg用法和max一样分组查询 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 实例演示 按照性别分组。分别查询男、女同学的数学平均分,人数SELECT sex , AVG(math)(平均分),COUNT(id)(人数) FROM student GROUP BY sex(性别分组); 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex,AVG(math) ,COUNT(id) FROM student WHERE math&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2 ; 分页查询1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot; 通过上面的实例演示，结合DQL查询语句的语法不难发现，如果一次有多个查询条件，那么写的顺序一次是Where、Group By、Having、Order By、Limit的顺序 可以这么来理解： where先对数据进行筛选，不满足条件的不进行后面的分组，这是第一次条件 Having再对分完组后的数据进行筛选，不满足条件的数据不会被查询到，这是第二次条件 前面的都完成后，Order By再对查询到的数据进行排序，这是第三次条件 Limit再对排序后的数据进行分页展示，这是第四次条件 发现数据库这方面的知识要掌握的东西太多，多练习才能掌握，死记硬背是很难的，本来以为30分钟，最后俩小时还没搞定，后面大约还有整个基础部分的一半吧，下次再说吧]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会话技术--Cookie&Session]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie-Session%2F</url>
    <content type="text"><![CDATA[会话：一次会话中包含多次请求和响应。在一次会话中，浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止会话技术能够在一次会话的多次请求响应间共享数据 会话技术的实现方式 客户端会话技术：Cookie 服务器端会话技术：Session 客户端会话技术–CookieCookie使用步骤 创建Cookie对象，绑定数据:new Cookie(String name, String value) 发送Cookie对象::response.addCookie(Cookie cookie) 获取Cookie，拿到数据:Cookie[] request.getCookies() Cookie实现原理基于响应头set-cookie和请求头cookie实现 客户端和服务器第一次请求响应：服务器创建Cookie对象，并在set-cookie响应头将Cookie响应给浏览器 浏览器接收到服务器带有set-cookie头的响应后，将Cookie存储在浏览器中，当下一次浏览器向服务器发送请求时，会在请求头cookie头中附带这cookie 这样就实现了多次请求响应之间的数据共享 Cookie的细节 一次可以发送多个cookie：在服务器端创建多个Cookie对象，多次调用response的addCookie方法将多个Cookie对象发送，但是如果两个Cookie的值相同，那么后加入的Cookie值会覆盖前面的值 cookie在浏览器中保存时间 默认情况下，当浏览器关闭后，Cookie数据被销毁(服务器关闭，Cookie仍然存在，因为Cookie存储在浏览器中) 持久化存储：调用Cookie对象的setMaxAge(int seconds)方法实现 参数取值情况： 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值，即浏览器关闭后Cookie被销毁 零：删除cookie信息 cookie存储中文问题:在tomcat 8 之前 cookie中不能直接存储中文数据。但是在tomcat8之后，支持直接存储中文，但是对于一些特殊字符(如空格等)，仍不能直接存储，需要借助URL编码才行(具体步骤下一篇文章说到) cookie的共享 在一个tomcat服务器中部署了多个项目，在默认情况下，这些项目之间的Cookie是不能共享的但是可以通过Cookie对象的setPath(String path)方法来设置Cookie的共享范围 默认情况下，设置的是当前项目的虚拟目录 如果要在多个项目之间共享，则可以将path设置为"/"(“/”为服务器路径) 不同服务器之间Cookie的共享 setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 例如：设置path为".baidu.com"，那么tieba.baidu.com和news.baidu.com两个不同的服务器之间可以共享数据，因为它们的一级域名是.baidu.com Cookie的特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) Cookie存储的键值对都是String类型 作用 cookie一般用于存出少量的不太敏感的数据，这是因为Cookie的存储位置决定的，存储在客户端容易丢失和被篡改。 在不登录的情况下，完成服务器对客户端的身份识别 服务器端会话技术–SessionSession使用步骤 通过resquest获取Session对象：request.getSession() 调用Session对象的方法存储数据(和request请求转发方法一样) Object getAttribute(String name)：通过键获取值 void setAttribute(String name, Object value)：将数据存储进Session对象 void removeAttribute(String name)：通过键移除相应的键值对 Session实现原理Session的实现是依赖于Cookie的。 客户端第一次向服务器发送请求，服务器在服务器内部开辟一块内存空间，存放Session对象，并给该内存空间指定一个id 服务器在响应头set-cookie中设置JSESSIONID=id这个键值对发送给客户端 客户端接收到服务器的相应后，会将保存着Sessionid的Cookie对象保存在浏览器内存 当客户端下一次向服务器发送请求的时候，会带着Cookie一起(在请求头cookie中有JSESSIONID=id键值对) 服务器接收到请求后，得到JSESSIONID=id键值对的id后，会在内存中找到对应id的Session对象 这就是为什么说Session依赖于Cookie的原因以及多次请求响应之间共享数据的原理 Session细节 当客户端关闭后，服务器不关闭，两次获取session不是同一个：前面说到过，Session是依赖于Cookie的，Cookie在默认情况下当客户端浏览器关闭后是自动销毁的，因此Cookie中的键值对自然也就销毁了，所以两次获取的Session不是同一个，如果需要两次的Cookie是同一个 创建一个Cookie对象，设置cookie的键为JSESSIONID，值为session对象的id 设置cookie的存活时间 那么在cookie存活时间内，服务器通过cookie请求头拿到session的id都是一样的，这样通过id找到的Session对象自然也是同一个 客户端不关闭，服务器关闭后，两次获取的session不是同一个，因为服务器关闭后相应内存会被释放，Session自然也会被释放 但是一般我们需要获取到的Session对象是同一个，确保数据不丢失，tomcat会自动完成Session的钝化和活化 Session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上 Session的活化：在服务器启动后，将session文件转化为内存中的session对象。 Session被销毁 服务器关闭 session对象调用invalidate() 自杀 session默认失效时间 30分钟,可以tomcat服务器的web.xml配置文件中session-config设置所有项目的失效时间,也可以在项目的wen.xml配置文件单独配置项目的失效时间 Session的特点 用于一次会话的多次请求间共享数据，存储在服务器端 session可以存储任意类型，任意大小的数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>会话技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器中的四种路径]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在Web开发中，会很频繁的用到各种路径，路径又大致分为四种，分别是相对路径、绝对路径、虚拟路径、资源路径 # 相对路径 通过相对路径不能确定唯一资源 例如：./index.html ## 相对路径的使用规则 以"./"开头, 在使用时先确定当前资源和目标资源的之间的相对位置关系 如果两资源位于同一级目录：./+目标资源名称 ./可以不加，默认有./ 如果目标资源位于上一级目录：../+目标资源名称 如何确定当前资源和目标资源的关系 对于src目录下的资源，可以用request.getRequestURL()来得到该资源的位置src下的java资源的URI都是虚拟路径+资源名称无论该java文件位于src下的哪一级目录，只要在src目录里，都是这个形式。这里说的资源名称并不是实际的java类名，而是@WebServlet中的资源名称，服务器通过这个资源名称找到实际的类。 对于web目录下的资源，如果直接在web目录下，那么资源的URI就是虚拟路径+/文件名称如果在web目录下的其他目录，那么资源的URI就是虚拟路径+/目录名称+/文件名称，有几级目录写几级目录。 绝对路径通过绝对路径确定唯一资源例如：http://localhost/response/responseDemo2或者/response/responseDemo2协议名+ip地址+端口号+虚拟路径+文件资源 两种路径使用规则规则：判断要定义的路径是给谁用的，即判断请求将来从哪发出 给客户端浏览器使用 需要加虚拟目录(项目的访问路径,查看项目的xml配置文件) 例如：&lt;\a&gt;标签，&lt;\form&gt;，重定向等从浏览器发出，需要加虚拟路径 给服务器使用不需要加虚拟目录例如：请求转发就是服务器内部的资源跳转，不需要加虚拟路径，直接写资源名称就可以了 虚拟路径虚拟路径代表的是项目实际部署的位置，服务器通过虚拟路径能够映射到项目实际部署的位置通过查看项目的xml文件可以发现:&lt;\Context path=”虚拟路径” docBase=”资源在电脑上存储的位置” /&gt;这就是配置文件的内容，我们在浏览器输入的是Contextpath，也就是项目的虚拟路径，服务器就通过该虚拟目录映射到后面项目部署的真实目录 虚拟路径的好处 虚拟目录的名称通常要比物理目录的名称易记，因此更便于用户访问。 使用虚拟目录可以提高安全性，因为客户端并不知道文件在服务器上的实际物理位置，所以无法使用该信息来修改服务器中的目标文件。 使用虚拟目录可以更方便地移动网站中的目录，只需更改虚拟目录物理位置之间的映射，无需更改目录的URL。 使用虚拟目录可以发布多个目录下的内容，并可以单独控制每个虚拟目录的访问权限。 使用虚拟目录可以均衡Web服务器的负载，因为网站中资源来自于多个不同的服务器，从而避免单一服务器负载过重，响应缓慢。 资源路径资源路径也不是文件的真实路径，它和真是路径之间存在着映射关系，服务器可以通过资源路径找到文件link这篇文章提到了配置Servlet的方法，一种是通过web.xml来配置，通过这种方法很容易理解资源路径和文件路径的映射关系，服务器通过资源路径映射到实际文件，通过@WebServlet配置原理一样 我们在浏览器输入的是项目的URL是由协议名+ip地址+端口号+虚拟路径+文件资源组成，服务器会通过虚拟路径找到项目在电脑上部署的位置，通过文件资源路径找到文件在电脑上的实际位置]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ServletContext对象]]></title>
    <url>%2F2019%2F09%2F08%2FServletContext%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ServletContext对象，代表了整个web应用，可以和程序的容器(服务器)来通信 获取方式 通过request对象获取:request.getServletContext() 通过HttpServlet获取:this.getServletContext(); ServletContext对象的功能 获取MIME类型(文后将什么是MIME类型):String getMimeType(String file) 获取到数据的类型后，可以用于设置响应头content-type的值 获取方法：String getMimeType(String file)； 域对象：共享数据，前面说到，ServletContext代表了整个web应用，因此ServletContext对象中存放的数据整个web应用的资源都可以访问和修改 方法和request域对象的三个方法一样，只是两者的作用范围不同 动态的获取文件的真实(服务器)路径 方法：String getRealPath(String path) 文件直接位于web目录下时：context.getRealPath("/+文件名称"); 文件位于web目录下下的目录a中时：context.getRealPath("/a/+文件名称"); 文件直接位于src目录下时：context.getRealPath("/WEB-INF/classes+文件名称"); 以上可以通过查看tomcat项目的层次结构，以tomcat项目的web目录为基准 tomcat项目目录位于IDEA工作空间目录的\out\artifacts下 MIME类型MIME类型:在互联网通信过程中定义的一种文件数据类型MIME类型的格式：大类型/小类型&nbsp;&nbsp;&nbsp;&nbsp;例如：text/html、image/jpg getMimeType方法获取MIME类型的原理在web.xml配置文件中，tomcat定义了上千种MIME类型和文件后缀名的对应关系，而ServletContext又可以和服务器通信，所以ServletContext的getMimeType实际上是通过文件的后缀名来映射获取的文件的MIME类型。]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求转发和重定向]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[目前已经学习了两种资源跳转的方式：分别是request对象的请求转发和response的重定向，那么这两者各自有什么特点以及它们之间的区别是什么呢？ request请求转发一种在服务器内部的资源跳转方式举个例子：浏览器向服务器发出请求，服务器中的AServlet收到了请求，但是AServlet无法单独完成这个请求，如果要完成这个请求，还需要服务器内BServlet的参与，这时候就会用到请求转发，AServlet执行完自己能执行的部分后跳转到BServlet中继续执行，(这中间还涉及到了共享数据，文章后面会将) 请求转发的特点 浏览器地址栏路径不发生变化：就是说，浏览器请求访问AServlet，Aservlet执行完自己能执行的部分后跳转到BServlet，在这个过程中浏览器地址栏的路径还是AServlet的路径，并不会发生改变 只能转发到当前服务器内部资源中。 转发是一次请求：从上面的例子可以看出，整个转发的过程中，无论在服务器内部资源跳转多少次，浏览器只发出过一次请求，而服务请经过多次跳转处理完浏览器的请求后只会做出一次响应 共享数据上面说到了，AServlet和BServlet一起完成浏览器的请求，那么这两者之间必定是有数据交互的，因为AServlet要告诉BServlet自己做了哪些部分(修改了那些数据..)，并将这些部分共享给BServlet说共享数据之前，先说一个概念域对象：一个有作用范围的对象，可以在范围内共享数据request域：代表一次请求的范围，即在一个请求的范围内各个服务器资源可以共享数据。因为上面说到了请求转发这个过程是一次请求响应的过程，所以请求转发过程中的多个资源可以共享数据 存储数据，在当前资源中调用此方法(转发之前调用)void setAttribute(String name, Object o)参数：String name：给数据起一个名，在后面取出数据用到Object o：要共享的数据 在跳转后的资源调用此方法，可以达到共享数据的目的：Object getAttribute(String name) 参数：String name：存储数据时起的名 还有一个相关的方法：通过键来移除键值对void removeAttribute(String name) response重定向一种资源跳转的方式，不限于服务器内部，可以跳转到其他服务器资源(如跳转到百度) 重定向实现步骤 设置状态码为302(代表重定向) 设置响应头location：response.setHeader("location","目的资源的路径"); 以上是分步实现，其实一个方法就能够完成上述步骤 调用response的sendRedirect方法，方法中传递跳转资源的路径 response.sendRedirect("https://www.baidu.com"); 重定向的原理 浏览器向服务器发出请求，AServlet接收到了这个请求,AServlet表示无法处理服务器的这个请求，但AServlet却知道BServlet(可以是服务器内部的资源也可以是其他服务器的资源) 所以AServlet在在响应消息中干了两件事情 设置状态码为302，告诉服务器重定向 告诉浏览器BServlet的路径，(设置响应头location为BServlet的路径) 浏览器收到了AServlet的响应消息后，根据AServlet给出的location路径去访问BServlet 重定向的特点 地址栏发生变化：在资源跳转的过程中，浏览器地址栏会发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response输出中文乱码]]></title>
    <url>%2F2019%2F09%2F08%2Fresponse%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用response对象设置响应体时有两个步骤： 获取输出流(字节流或字符流) 使用输出流，将数据输出到客户端浏览器这时候如果传输的数据是中文，输出到浏览器就会乱码 乱码原因首先，要知道乱码的根本原因是什么，乱码的根本原因在于编码和解码使用的字符集不一样。那么在从服务器输出数据到客户端的过程中，有几次编码和解码过程？又分别是在哪里执行的？在输出数据的过程中，有一次编码，是tomcat执行的，它按照自己的字符集将数据编码后发送给客户端浏览器有一次解码，是浏览器执行的，浏览器将接收的数据按照自己的字符集解码后打印在屏幕上。而tomcat的默认编码是ISO-8859-1，浏览器的默认编码是操作系统的编码，也就是GBK，两者的编码格式不一样，就造成了中文乱码问题 解决方案解决方案不止一种，记录一种比较简单地使用response设置响应头的方法来设置 Content-Type 具体操作在获取输出流之前(一定是之前)设置响应头content-typeresponse.setHeader(“content-type”,”text/html;charset=utf-8”);这个方法不仅可以设置流的编码，还可以告诉浏览器发送数据的编码方式，并建议浏览器使用同样的字符集解码，这样就解决了乱码的问题由于只需要设置content-type这个响应头，所以有另一个方法更为简单response.setContentType(“text/html;charset=utf-8”);]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--request和response对象]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[首先要知道request对象和response对象是由服务器创建的，我们只是使用并不创建request对象是来获取请求消息，response对象是来设置响应消息 request对象request继承结构&nbsp;&nbsp;&nbsp;&nbsp;ServletRequest(接口)–&gt;HttpServletRequest(接口)–&gt;RequestFacade 类(tomcat实现) request功能获取请求消息数据 获取请求行数据:这是一个GET请求方式的请求行：GET /day14/demo1?name=zhangsan HTTP/1.1 获取请求方式 ：String getMethod() -->上例得到结果：GET 获取虚拟目录(常用)：String getContextPath() -->上例得到结果：/day14 获取Servlet路径: String getServletPath()-->上例得到结果：/demo1 获取get方式请求参数：String getQueryString()-->上例得到结果：name=zhangsan 获取请求URI(常用)(有两个方法) String getRequestURI()-->上例得到结果：/day14/demo1 StringBuffer getRequestURL()上例得到结果 :http://localhost/day14/demo1 获取协议及版本：String getProtocol()-->上例得到结果：HTTP/1.1 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据: 通过请求头的名称获取请求头的值(常用):String getHeader(String name) 获取所有的请求头名称:Enumeration getHeaderNames() 获取请求体数据:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 获取流对象 获取字符输入流，只能操作字符数据:BufferedReader getReader() 获取字节输入流，可以操作所有类型数据:ServletInputStream getInputStream() 其他功能因为对于不同的请求方式，它们的请求参数所在位置不同，GET方式请求参数在请求行中，POST方式请求参数封装在请求体中，所以服务器在获取请求参数的时候，需要分别在doGet和doPost方法中写不同的逻辑代码来获取请求参数，比较麻烦，因此就有一种通用的获取请求参数的方法 获取请求参数通用方式 根据参数名称获取参数值:String getParameter(String name) 根据参数名称获取参数值的数组(多选框):String[] getParameterValues(String name) 获取所有请求的参数名称:Enumeration getParameterNames() 获取所有参数的map集合:Map' 请求转发:一种在服务器内部的资源跳转方式 通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发:forward(ServletRequest re, ServletResponse res) 注意:path是要跳转的资源的路径， 获取ServletContext(后面博客会详细讲到): ServletContext getServletContext() request的请求转发和资源共享以及response的重定向，它们各自的特点和区别会新开一篇博客 response对象response功能:设置响应消息 设置响应行(设置状态码):setStatus(int sc) 设置响应头:setHeader(String name, String value) 设置响应体: 使用步骤 获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--请求响应模型]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Http–Hyper Text Transfer Protocol 超文本传输协议传输协议：定义了客户端和服务器端通信时，发送数据的格式 # Http协议的特点 基于TCP/IP的高级协议,默认端口是80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 Http协议的历史版本 1.0版本每次请求响应之后都会断开连接，下一次请求响应又会建立新的连接，即每次请求响应都会建立新的连接缺点：连接会被多次建立和多次丢弃掉，影响传输速度，消耗资源 1.1版本在一次请求响应之后，连接不会立刻断开，而是会等待一定的时间，如果在这一定时间内，还有其他请求，就会默认使用该连接，而不去建立新的连接，这样就实现了连接的复用 上面说了，Http定义了客户端和服务器通信时传输数据的格式，而传输数据分为两种： 客户端向服务器传输数据：请求消息数据 服务器向客户端传输数据：相应消息数据 Http请求消息数据格式 请求行:请求方式 请求url 请求协议/版本例如：GET /login.html HTTP/1.1请求url=虚拟路径+Servlet资源路径 请求头：客户端浏览器告诉服务器一些信息请求头消息以键值对的方式给出：请求头名称：请求头值常见的请求头： User-Agent：浏览器告诉服务器，使用的浏览器版本信息,可以在服务器端获取该头的信息，解决浏览器的兼容性问题(可以在服务器端对不同的服务器写不同的逻辑代码，然后根据该头的内容获取浏览器名称，执行对应浏览器的代码) Referer：告诉服务器，当前请求从哪里来？可以用来防盗链和统计工作 请求空行：一个空行，用于分割请求头和请求体 请求体(正文)：封装POST请求消息的请求参数 对于请求行中的请求方式，http协议7中请求方式，常用的有2种 GET:请求参数在请求行中，跟在url后。 请求的url长度有限制的 不太安全 POST: 请求参数在请求体中 请求的url长度没有限制的 相对安全 Http响应消息数据格式 响应行:协议/版本 响应状态码 状态码描述例如：HTTP/1.1 200 OK请求url=虚拟路径+Servlet资源路径 响应头：服务器告诉浏览器一些信息响应头消息以键值对的方式给出：响应头名称：响应头值常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据常见有两种取值 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体，用于文件下载 注意：这个filename是浏览器在弹出框显示，和服务器中要下载的文件名无关 响应空行：一个空行，用于分割响应头和响应体 响应体(正文)：传输的数据 响应状态码服务器告诉客户端浏览器本次请求和响应的一个状态。状态码都是3位数字 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：本次请求响应成功。代表码：200 4xx：客户端错误。 404:请求路径没有对应的资源-->路径错误 405:请求方式没有对应的doxxx方法-->比如浏览器请求方式是Post方式，而客户端没有doPost方法 5xx：服务器端错误。代表码：500(服务器内部出现异常)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FServlet%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Servlet：server applet官方给出的解释是运行在服务器端的小程序 # Servlet的本质 浏览器通过ip和端口来找到服务器，服务器中的资源分为两类 静态资源， 动态资源所谓动态资源，就是不同的用户访问到的页面是不一样的，这说明动态资源中肯定有一些逻辑性，来实现不同的用户访问同样的资源看到的是不一样的。而这些逻辑性，就要通过Java代码(Java类)来实现。 也就是说浏览器请求动态资源的时候，访问的就是服务器上的Java类 要注意的是：这里说的Java类没有main方法，不能自己运行，需要依赖服务器才能运行，相当于Tomcat(服务器软件)来执行它。那么问题来了，如果要Tomcat能够认识这个类并执行这个类，这个类就需要遵守一定的规则，在Java中，规则==接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说的规则，就是Servlet，它本质上就是一个接口，定义了Java类被tomcat识别的规则 Servlet的使用 创建JavaEE项目 在src目录内定义一个类，实现Servlet接口 实现接口中的抽象方法 配置Servlet(一共有两种方法，这里先记录第一种)在web.xml中配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;全类名(包名+类名)&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1(Servlet资源路径)&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在web.xml中加上以上内容 Servlet配置原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的url-pattern标签体内容。 如果有，则通过映射找到对应的servlet-class全类名 tomcat会将字节码文件加载进内存，并且创建其对象注意：这个实现了Servlet接口的类是由Tomcat通过反射创建的对象，并不是由程序员创建的 调用对象的方法 Servlet的生命周期 被创建：执行init()方法，该方法只执行一次 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么Servlet在什么时候被创建呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，在资源第一次被访问时，Servlet被创建 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在web.xml文件中配置改变Servlet被创建的时机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面说到的servlet标签下配置，具体下面有图 提供服务：执行service方法，可以执行多次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有服务器正常关闭时，才会执行destroy方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy方法在Servlet被销毁之前执行，一般用于释放资源 设置Servlet被创建的时机使用load-on-startup标签，这是一个围堵标签，当标签的值为负数的时候，默认第一次被访问时创建当标签的值为正数或0的时候，服务器启动时创建 注解配置Servlet在Servlet3.0以后，可以使用注解配置Servlet，相比较在web.xml文件中配置更加方便使用方法：在类上加注解@WebServlet(“资源路径”)，这样就可以通过注解的资源路径找到相应的类，直接将类加载进内存 Servlet体系结构 Servlet是一个接口，里面有5个抽象方法，每次继承Servlet接口的时候，都需要重写这5个抽象方法，而实际上，很多时候并用不到其中的有些方法，所以每次都要重写，很麻烦 Servlet的子类GenericServletGenericServlet也是一个抽象类，将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象，将来定义Servlet类时，可以继承GenericServlet，只实现service()方法即可(但实际上，这种方法使用较少) HttpServletHttpServlet出现原因HttpServlet extends GenericServlet该类是对Http协议的一种封装和描述对于一般的Servlet实现类，在service方法中通过一些操作获取浏览器的数据，但在获取数据之前，需要判断浏览器的请求方式是get方式还是put方式，因为两种方式封装数据的位置和格式是不一样的，对于不同的方式需要进行不同的逻辑处理。也就是说，我们需要在service方法里作两步操作： 判断浏览器请求方式 根据不同的请求方式编写不同的逻辑代码 HttpServlet实现原理这个过程比较麻烦，但却是所有的service方法都必须要做的一个过程，因此sun公司就提供了HttpServlet这个类。在HttpServlet类的Service方法中，已经写好了判断浏览器请求方式的逻辑代码，我们需要做的就是重写相应doxxx()方法，service方法判断请求方式后，会根据判断的结果调用我们重写的doxxx()方法以上是HttpServlet类service的源码，可以发现，HttpServlet中的service方法主要用于判断浏览器的请求方式，然后根据不同的请求方式调用相应的doxxx()方法，我们只需要重写这些方法，省略了判断请求方式的步骤]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Servlet类</tag>
        <tag>HttpServlet类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--SQL语句总结(一)]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这里主要总结两类SQL语句 DDL和DML，即操作数据库和表的语句以及对表中数据进行增删改操作的语句 DDL语句这类语句又分为两部分 操作数据库(CRUD) 操作表(CRUD) 操作数据库 (Create)创建： 1. 创建数据库：create database 数据库名称; 2. 先判断数据库是否存在，如果不存在，再创建：create database if not exists 数据库名称; 3. 创建数据库，并指定字符集：create database 数据库名称 character set 字符集名; 4. 创建db4数据库，判断是否存在，并指定字符集为gbk：create database if not exists db4 character set gbk; (Retrieve)查询： 1. 查询所有数据库名称：show databases; 2. 查询某个数据库的字符集:show create database 数据库名称; (Update)修改： 修改数据库的字符集:alter database 数据库名称 character set 字符集名称; (Delete)删除： 1. 删除数据库:drop database 数据库名称; 2. 判断数据库存在，存在再删除:drop database if exists 数据库名称; 使用数据库： 1. 查询当前正在使用的数据库名称:select database(); 2. 使用数据库:use 数据库名称; 操作表 (Create)创建： 1. 创建表：create table 表名( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名1 数据类型1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名2 数据类型2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名n 数据类型n); 注意：最后一列不加逗号 2. 复制表：create table 表名 like 被复制的表名; 数据库数据类型 int：整数类型 double:小数类型 date:日期，只包含年月日，形如yyyy-MM-dd datetime:日期，包含年月日时分秒, yyyy-MM-dd HH:mm:ss timestamp:时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串，在使用的时候需要指定长度，例如varchar(2)表示最大长度2个字符 (Retrieve)查询： 1. 查询某个数据库中所有的表名称:show tables; 2. 查询表结构:desc 表名; (Update)修改： 1. 修改表名:alter table 表名 rename to 新的表名; 2. alter table 表名 character set 字符集名称:alter table 表名 character set 字符集名称; 3. 添加一列:alter table 表名 add 列名 数据类型; 4. 修改列名称 类型:alter table 表名 modify 列名 新数据类型; (Delete)删除： 1. 判断数据库存在，存在再删除:drop table if exists 表名 ; 从上面这些语句不难总结得出，无论是数据库还是表，它们的增删改语句都和create、alter、drop、show有关 DML语句增删改表中的语句 添加数据insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n);列名和值要一一对应如果不指定列名，则默认给所有列添加值：insert into 表名 values(值1,值2,…值n);除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据delete from 表名 [where 条件]如果不加条件，则默认删除表中所有数据但是，如果要删除表中所有的话，不推荐使用这种方法，因为效率低推荐使用TRUNCATE TABLE 表名; 效率更高 先删除表，然后再创建一张一样的表。 修改数据update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件];注意：如果不加条件，则会将表中的记录全部修改 总结：DML语句用来操作表中的数据，主要对数据进行增删改操作，主要有insert 、delete、update三个关键字]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--数据库概念和SQL简介]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%92%8CSQL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[数据库(DataBase)，简称DB，用于存储和管理数据的仓库能够持久化存储数据，实际上，数据库就是一个文件系统，能够方便的存储和管理数据，使用了统一的方式来操作数据库，即SQL MySQL的配置MySQL服务启动 cmd--> services.msc 打开服务的窗口 使用管理员方式打开cmd net start mysql : 启动mysql的服务 net start mysql :关闭mysql的服务 MySQL登录 mysql -uroot -p密码 mysql -hip -uroot -p连接目标的密码 mysql –host=ip –user=root –password=连接目标的密码 MySQL退出 exit/quit命令 SQLStructured Query Language：结构化查询语言定义了操作所有关系型数据库的规则，但是不同的数据库操作的方式可能存在不同的地方，可以理解为‘方言’SQL分为四类 DL(Data Definition Language)数据定义语言用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 一张图来帮助理解四类SQL语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中创建多个Project]]></title>
    <url>%2F2019%2F09%2F08%2FIDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProject%2F</url>
    <content type="text"><![CDATA[我们知道，IDEA是没有workspace这个概念的，它是以Project为单位，一个窗口对应着一个Project，而一个Project对应着很多Model，Model相当于eclipse中的project，那么如何在一个项目中存放多个Project呢？ 首先，创建一个空的Project 给项目命名并点击finish会进入到新创建的Project窗口中，接着IDEA就会弹出下面界面，让你为新的Priject创建一个Model：在这里很重要，不选择给新的Project创建一个Model，直接点OK这样，常见出来的没有Model的Project就相当于一个空文件夹，(查看创建的Project文件夹，会发现它是没有src的) 在新的Projrect中，new一个Model我这里创建的时web项目，如果要创建普通的项目，点击左侧第一个按钮JAVA就可以给新创建的Model起名，通过这里就可以发现，第一个untitled是创建的project名(由于没有命名，默认就是untitled)，第二个是正在创建的Model名，点击finish这样就创建成功了一个，按照上面的方法再来一遍这样就成功地在一个窗口创建了两个Project 另外IDEA会为这两个web项目分别部署一份配置文件，这样这两个web项目就可以分别设置不同的端口，虚拟路径等配置运行项目的时候，查看控制台的log：Using CATALINA_BASE: 的值，就能找到配置文件的路径]]></content>
      <categories>
        <category>Utils</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat部署项目的方式]]></title>
    <url>%2F2019%2F09%2F08%2FTomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Tomcat有三种部署项目的方式将项目直接放到Tomcat的webapps目录下也可以将项目打包成war包，放到webapps目录下，运行时Tomcat会自动解压 利用Tomcat的配置文件sever.xm打开conf目录，找到sever.xml配置文件(先关闭Tomcat服务) 找到Host标签，加上一个Context标签，path值可以自己设置 启动Tomcat服务 在浏览器输入localhost:8080(端口号)/path的值/docBase的值就能正确访问项目 这种部署方式项目可以放在硬盘上的任意位置，Tomcat会通过path映射到docBase。 注意：因为server.xml是Tomcat服务核心的配置文件，是配置Tomcat整体的，在里面配置项目有可能损坏配置文件，导致出错，比较危险，所以一般不推荐使用 自定义xml配置文件(先**关闭Tomcat**) 打开Tomcat下的conf\Catalina\localhost这个目录，在localhost下创建一个xml配置文件， 文件名可以任意起(但是这个文件名就是浏览器搜索时的虚拟路径)，假设是aaa.xml； 在配置文件中：将上图中红框里的Context标签及内容写进去，把后面的path键值对删掉(因为虚拟路径已经指定为xml文件名，所以不需要再指定虚拟路径) 再次启动Tomcat 浏览器搜索**localhost:8080(端口号)/xml文件名/docBase的值**即可这种部署方式还有一个好处： 这是一种热部署的方式，如果不想要这个项目，可以将创建的xml文件删掉，或者后缀名改一下 例如：将aaa.xml改为aaa.xml_bak；无需重新启动Tomcat就能生效(浏览器就访问不到项目资源)]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动问题分析]]></title>
    <url>%2F2019%2F09%2F08%2Ftomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[问题前提在Tomcat目录下的bin目录中双击startup.bat直接打开tomcat时，可能会出现以下两个问题 Tomcat的窗口一闪而过 启动报错 Tomcat的窗口一闪而过原因没有正确配置JAVA_HOME环境变量在安装JDK时，需要将JDK的目录配置到Path变量下，问题就在这里，因为配置的时候，有可能是直接将JDK的目录配置到了Path环境变量双击Path变量，如下图所示这样的做法是错误的 正确的做法应该先创建一个JAVA_HOME环境变量将JAVA_HOME的值设置问JDK的路径，如下图然后再将JAVA_HOME代替JDK安装路径给Path变量将startup.bat关掉，重新启动即可 分析一下原因先以文档的形式打开startup.bat，发现和catolina.bat有关，我们就以文档形式打开bin目录下的catolina.bat在文档里可以看到，这里用到了环境变量的JAVA_HOME，所以在配置环境变量的时候，必须用JAVA_HOME来设置JDK路径，否则这里就无法找到JDK，由于Tomcat是纯java编写的，它的启动和运行要依赖与JDK，所以Tomcat就无法正常运行 启动报错，然后窗口自动关闭原因有可能是已经打开了一个Tomcat(或者有其他程序占用了Tomcat的端口号)，再次启动的时候由于端口被占用，所以无法正常启动如果是这种情况，通过查看日志会发现有一个异常：java.net.BindException:Address already in use 解决方法找到占用Tomcat端口号(一般是8080)的程序，关闭该程序1、打开cmd窗口，输入 netstat -ano命令找到Tomcat端口(我的是默认8080)，记录该端口程序的PID2、打开任务管理器找到刚记录的PID对应的程序，把它关掉。这样，Tomcat就能正确启动了]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>问题分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM模型基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FBOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[BOM，全称Browser Object Model，浏览器对象模型它将浏览器的各个组成部分封装成对象 五个对象window-窗口对象Location-地址栏对象History-历史记录对象Screen-显示器屏幕对象Navigator-浏览器对象 window-窗口对象该对象无需创建，可以直接使用对象的方法和属性 window对象的方法与弹出框有关的方法alert()显示带有一段消息和一个确认按钮的警告框。 confirm()显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法close()关闭浏览器窗口。 谁调用我 ，我关谁 open()打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式setTimeout()在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器clearTimeout()取消由 setTimeout() 方法设置的 timeout。setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()取消由 setInterval() 设置的 timeout。window对象的属性获取其他BOM对象historylocationNavigatorScreen获取DOM对象document Location-地址栏对象创建(获取)1. window.location 2. location方法reload() 重新加载当前文档。刷新 属性href 设置或返回完整的 URL。如图，给按钮设置监听器，点击按钮后修改页面的URL为百度页面，就会自动跳转到百度的页面 History-历史记录对象创建(获取)1. window.history 2. history方法back()加载 history 列表中的前一个 URL。 forward()加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性length返回当前窗口历史列表中的 URL 数量。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>BOM</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F09%2F08%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS和HTML结合方式内部样式在html文件内部定义一个script标签、在标签里面写的JS代码注意：和CSS不同的是，JS标签可以有很多个，而且可以写在HTML文件中的任意位置 外部样式在html文件内部定义一个script标签，通过script的src属性，来指定JS配置文件的路径 JS代码写在JS配置文件中 数据类型和变量JS数据类型和JAVA类似，分为**原始数据类型**和**引用数据类型**两大类数据类型number包括整数、小数和NaN类型(不是数字的数字类型 not a numebr) string字符/字符串类型 booleantrue/false、 null一个对象为空的占位符 undefined未定义，如果一个表量没有给初始化值，就会被默认赋值为 undefined ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828110402952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)变量一小块存储数据的内存空间 JAVA是强类型语言，而JavaScript是弱类型语言强类型在开辟内存空间时，定义了空间将来存储数据的类型，只能存储固定的类型 弱类型在开辟内存空间时，没有定义空间将来存储数据的类型，可以存放任意类型的数据 运算符在JS中，如果运算数不是运算符要求的类型，那么JS会自动将运算数进行类型转换 例如：一元运算符+(正号)和-(负号)是对数字类型进行操作，但是有+&apos;a&apos;这样的运算，就会将字符串类型的&apos;a&apos;转换为number类型其他类型转numberstring--&gt;number：**按照字面值转换**，如果字面值是数字，如&apos;123&apos;，会转换成数字123， 如果字面值不是数字，如&apos;abc&apos;，会转换为NaN(不是数字的数字)注意：NaN和整数小数运算，还是NaN; boolean–&gt;number: true=1 false=0 比较运算符字符串按照字典顺序比较(如c&gt;b),按位逐一比较，直到得出大小 **类型不同比较，先进行类型转换** ”===“运算符：在比较之前先进行类型判断，如果类型不同，直接返回false逻辑运算符！：非运算其他类型转boolean number--&gt;boolean：0和NaN为false，其他都是true string--&gt;boolean：除了空字符串，都是true null/undefined--&gt;boolean：false 对象--&gt;boolean：true 注意：在JS中，所有的**变量都是关键字var**定义的，var可以省略，但是，**用var定义的是局部变量**，不用var定义的 是全局变量常用对象function对象 方法对象 Array对象数组对象 数组长度可变 Date对象 Math对象该对象不用创建，可以直接使用对象的方法和属性，Math.调用 常用方法和属性： Global对象 特点：是一个全局对象，这个对象中封装的方法不需要对象就能够直接使用,和Math不同的是，使用它的方法前面不 用加对象名 在说该对象的方法之前先说一下**URL编码**： 浏览器将从表单中收集的数据经过URL编码后发送给服务器，服务器再将接收到的URL编码的数据解码。 URL编码的规则：对于汉字，先将汉字按照GBK/UTF8编码成对应的二进制数字，再将每四位二进制数字组合在 一起转换成十六进制数字，这样就将汉字转换成了一串十六进制数字，最后，每两个十六进制数字一组，在前面 +%，这样就组成了URL编码，字母和数字不编码第二组方法编码的字符更多，会将网址中./等符号也用URL编码]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器和常用属性]]></title>
    <url>%2F2019%2F09%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基础选择器id选择器使用此选择器要求HTML相应的标签必须指定了id属性 格式： #+标签id属性{ //对应id标签的属性 如color等}通过HTML标签的id来指定标签，修改样式 元素选择器格式：标签名称{ //通过标签名称找到标签(可能不止一个)并修改内容样式 }这个元素选择器会找到HTML中所有的div标签，并将标签内容字体改为红色 类选择器 格式： .+类名{ 通过标签的class属性值找到标签 }其中：三个选择器中 id选择器优先级最高，元素选择器优先级最低 扩展选择器![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828103900651.png) CSS常见属性 盒子模型 参见JAVA_WEB/HTML&amp;CSS]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础回顾]]></title>
    <url>%2F2019%2F09%2F08%2FHTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[HTML用于搭建基础页面，展示页面内容，一般和CSS以及JS搭配使用HTML标签分类# 1、围堵标签 顾名思义，就是开始和结束标签，例如&lt; html&gt; &lt; /html&gt;，内容放在标签中 # 2、自闭合标签 开始标签和结束标签在一起。例如换行标签&lt; br/&gt;、超链接标签&lt; a&gt;等 标签不区分大小写，建议小写无论是哪种标签，都可以在开始标签中定义属性，属性是由键值对组成，其中值需要由引(单/双)号引起来 &lt; html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt; /html&gt;文件标签&lt; html&gt;文档的根标签 &lt; head&gt;头标签，用于指定html文档的一些属性，引入外部资源，如CSS、JS文件等 &lt; title&gt; 标题标签 &lt; body&gt; 体标签，html代码写在body标签中 以上均为围堵标签 文本标签&lt; h1&gt;~&lt; h6&gt;标题标签，从h1到h6字体大小递减 –&gt;围堵标签 &lt; p&gt;段落标签：被该标签包裹的文本会换行两次 –&gt;围堵标签 &lt; br&gt;换行标签 &lt; hr&gt;展示一条水平线 该标签有一些属性：color、width、height、align(对齐方式)来设置水平线的样式 &lt; b&gt;字体加粗标签 &lt; i&gt;字体斜体标签以上四个均为自闭合标签 &lt; font&gt;字体标签 该标签属性：color、size、face(字体)来改变字体 center：文本居中标签 图片标签&lt; img&gt;图片标签，是一个自闭合标签，其中有src属性，可以指定展示图片的路径 相对路径： 其中如果html文件和图片所在文件夹目录是同一级目录，那么./+图片所在文件夹目录/图片 如果图片所在文件夹目录是html文件上一级目录，那么就用../ 列表标签&lt; ol&gt;/&lt; li&gt;有序列表 type属性：指定序号的样式 &lt; ul&gt;/&lt; li&gt;无序列表无序列表的type属性有三种： disc：原点 square：正方形点 circle：圆圈 链接标签&lt; a&gt;定义一个超链接 属性： href 指定访问资源的URL()统一资源定位符)，可以是网址 target 指定打开资源的方式，有两种方式 _ selt:在当前页面打开 _ blank：在新空白页面打开 和CSS以及JS搭配的标签 div标签和span标签，两者的区别是div自带换行，而span没有换行功能 表格标签&lt; table&gt; 定义表格，table的开始标签可以指定一些属性 width：表格宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt; tr&gt;标签定义行标签 &lt; td&gt;标签定义单元格标签 &lt; th&gt;标签定义表头单元格标签 表单标签注意：表单中的数据要想被提交，必须指定其name属性 表单：用于采集用户输入的数据，用于和服务器进行交互 &lt; form&gt;用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围form标签有以下属性 action：指定提交数据的URL路径 method：指定提交方式，有两种比较常用，分别是post和get form只是制定了收集用户数据的范围，并没有指定提交形式(输入框、按钮、下拉列表…)因此就会用到表单项标签表单项标签主要有三种：input标签、select标签、textarea标签 &lt; input&gt;标签展示效果 &lt; select&gt;标签子元素：option，指定列表项展示效果 文本域标签主要有两个属性：cols：指定列数，每一行有多少个字符rows：默认多少行。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--Byte类]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[学习过程中参考此篇文章，写的很好 1、观察它继承的父类，实现了那些接口 2、找到它的成员变量 3、学习构造方法 4、学习方法 一、父类和接口从图中可以知道，Byte类继承了Number类，实现了Comparable接口 对于Comparable接口，只有一个抽象方法这个接口赋予它和它的子类比较的能力，用于排序，比较大小对于一个存储自定义类的数组或集合，只有这个类实现了该接口，重写了接口中的compareTo()方法，重写了排序规则才能使用Arrays类的sort方法进行排序； 二、成员变量定义了Byte类型数据的边界值，就是说，Byte类型的值只能在-128~127之间TYPE是一个Byte的Class类对象，相当于TYPE=Byte.class；这就是Byte类型的基础类型，数据存储的地方(从下面的构造方法可以看出)这三个成员变量分别表示Byte数据的位数，字节数和UID(用于序列化和反序列化) 三、构造方法Byte的构造方法有两个，可以看出，两个构造方法都会将传入的数据存放到成员变量byte中 四、私有静态内部类![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171705760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70) 这是Byte类的一个静态内部类，类里面还有一个静态代码块 静态代码块会在类第一次被加载的时候执行，并且只执行一次 这里的作用就是，创建一个Byte类型的数组，数组的长度是256 里面存储着-128~127的数字(Byte类数据所有可能的取值) 并且数组是静态的并且final修饰， 因为后面的有些成员方法会需要用到Byte对象，所以这样做就避免了重复创建对象和回收对象五、成员方法1、toString(byte b)方法![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171318100.png) 注意：这个toString()方法不是重写Object的toString方法，因为它有参数 作用：将一个byte类型数据转化为String字符串类型 实质上是直接调用Integer类的toString方法， radix：10：用10进制表示2、valueOf(byte b)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172235507.png) 作用：将基本类型--&gt;包装类型，直接从上面的数组中得到3、parseByte(String s,int radix) 参数： String s:要解析的字符串 int radix:指定字符串表示的进制 例如：s=“10000”，radix=2，解析出来的值就是16 作用： 将字符串按照指定进制解析为byte类型 实质上调用的是Integer的parseInt方法，解析成int类型 判断是否超出范围，超出范围就抛异常，否则就返回 4、parseByte(String s)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172742458.png) 不指定进制默认十进制解析5、valueOf(String s,int radix) 参数： String s:要转换的字符串 int radix：字符串表示的进制，和解析方法一样作用： 将字符串转换为按照指定进制形式表示的Byte类型，先将字符串解析为byte类型，在调用valueOf()方法，从静态代码块初始的数组中找到对应的Byte并返回 6、valueOf(String s)默认10进制7、xxxValue()方法重写父类的方法，由于byte数值最小，不用担心出现溢出 直接用强制类型转换，然后return8、hashCode()重写了父类的hashCode方法，对于Byte类型，它的hashCode方法实质上就是返回它的值 9、equals()方法 重写了父类的equals方法 10、compareTo()方法 重写了接口中的compareTo方法，直接返回两个对象的差值 调用方法的对象-方法的参数]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>Byte</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流和字节流]]></title>
    <url>%2F2019%2F09%2F07%2FJAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[深入理解字符流编码 首先要理解字符流输入的原理：字符流输入其实底层也是字节流输入 字符–&gt;计算机二进制数字（字节）：编码字节(计算机二进制数字)–&gt;字符：解码 写入时：1、当使用字符流的write方法向文件写入数据的时候，数据会先写进内存缓冲区中， 2、内存缓冲区会先字符对比着系统码表编码(中文系统是GBK)为对应的字节：字符--&gt;数字 3、调用了flush方法或者是close方法后，内存缓冲区中编码为字节(数字)会写入到文件中读取时：使用read方法读取文件的时候，文建会先将存储在计算机中的二进制对照系统码表解码成相应的字符，读入程序图片不能用字符流的原因因为图片是字节文件，计算机中存储的也是字节数字，所以用字节流输入的时候不需要编码解码的过程，直接将计算机中的字节读取写入就可以了 但是用字符流读取的时候，一次读取两个字节，然后将这两个字节按照码表解码成相应的字符，当读取图片的时候，将两个字节拼在一起对比码表解码，码表中可能没有相应的字符，就会将此二进制数据标记为未知字符， 在写入的时候，会将未知字符丢掉，所以图片拷贝不成功 因为原图片和你拷贝的“图片”在计算机中的字节都是不一样的 拷贝的“图片”丢失了很多 **解码后**被标记为“未知字符”的**字节** 举个例子：一个图片在计算机中存储的字节是：-121，34，124，53，-65，-43，1.... 使用字节流读取的时候，一次读取一个字节，会原封不动的读取出来：-121，34，124，53，-65，-43，1.... 但是当使用字符流读取的时候，一次读两个字节-12134，12453....然后将每次读取到的两个字节对照系统码表解码成相应的字符，但是码表中可能没有相应的字符； 例如没有和-12134对应的字符，就会将此二进制数据标记为未知字符(假设标记为￥)； 在写入的时候，就会将￥字符给丢掉，所以**最后实际写入的数据为**124，53，-65，-43，1.... 这样拷贝自然就失败了关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接**最后**：字符流因为解码编码等原因，比字节流慢很多 字符流一般用于传输纯文本文件，尤其是中文文档，不能用于视频，图片等传输 图片等视频音频文件要用字节流]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>乱码</tag>
        <tag>字符流/字节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树镜像对称]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC101%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度–简单题目 分析： 通过题目可以知道，这个树镜像对称，那么这棵树关于根节点这条线对称 就是说，将它所有的左子树变成右子树，所有右子树变成左子树，它是不变的 递归//这里直接传递tree根节点的左右子树会比pre(TreeNode tree,TreeNode tree)好，因为减少一层递归，LeetCode速度直接 //快1ms，亲测 1、pre(TreeNode tree.left,TreeNode tree.right) 2、如果A.val==B.val --&gt;return true 3、如果A==null&amp;&amp;B==null --&gt;return true 4、如果A和B不同时为空，说明树是不对称的 --&gt;return false 5、遍历A的左子树和B的右子树 //pre(A.left,B.right) 6、遍历A的右子树和A的左子树 //pre(A.right,B.left)迭代法使用队列，比较容易理解，直接上代码(LeetCode官方题解)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC70%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度： 简单 1、动态规划可以知道，如果要到达第n阶台阶，有两种方式：第一：从n-1阶台阶跨1步第二：从n-2阶台阶跨2步设到达第n阶台阶的方法总数为sum(n)那么由上面可以知道：sum(n)=sum(n-2)+sum(n-1) 可以举例假设一下假设n等于3，那么到达第3阶台阶由两种方法1、从第1阶台阶跨2步上去2、从第2阶跨1步上去 相应的，到达第1阶台阶只有一种方法，sum(1)=1；到达第2阶台阶也有两种方法：从起始位置跨2步，和先跨1步再跨1步，sum(2)=2；所以sum(3)=3; 2、斐波那契数列通过观察规律可以知道：假设第0阶为1；那么可以得到从第1阶往后分别是：1，2，3，5，8，13…..这是一个很明显的斐波那契数列 3、递归同样的思路，爬第n阶台阶的方法和等于爬上第n-1阶台阶和爬上第n-2阶台阶方法之和递归出口：n=0的时候返回1，n&lt;0的时候返回0；运行到44个样例的时候栈爆了…..]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
