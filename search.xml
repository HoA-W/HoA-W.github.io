<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法之希尔排序]]></title>
    <url>%2F2019%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说到了插入排序，并且知道了它是不稳定的。并且测试速度后发现插入排序的速度与冒泡、选择相比还是比较可观的。但是，不知道你有没有发现，插入排序再某些情况下存在着一些弊端。比如有这样的一个数组arr={4,7,9,6,4,1}，数组自身的顺序接近于逆序，当将4、1插入到有序数组中时，需要将有序数组部分所有元素都后移一个位置，这无疑会有一定的时间消耗。那么在这种情况下，就出现了希尔排序，你可以将希尔排序理解为插入排序的增强版。 算法思路希尔排序，又称为缩小增量排序 设置一个步长step，通常初始化为arr.length/2，即数组长度的一半 间隔为一个步长的元素为一组 分别对同一组的元素进行插入排序 每一趟过后将step减半，即step/=2(缩小增量) 重复3和4，直到step为1 setp为1时，数组已经接近有序，这时对整个数组进行插入排序。 前面说过，插入排序适用于哪些自身顺序比较良好的数组，而希尔排序通过不断地缩小步长，将一个数组变成一个接近有序的数组后，直到step=1，此时就相当于对一个接近有序的数组进行插入排序。 代码实现 分析 算法的时间复杂度 平均时间：O(nlogn) 最差情况：O(n的1.2次方) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1) 稳定性 和插入排序不同，希尔排序不是稳定的 算法速度既然说希尔排序时插入排序的增强版，那就来测试一下希尔排序和插入排序的速度谁更快一些，又快多少呢？同样的，创建一个80000大小的随机数组，来测试希尔排序的排序速度排序时间(毫秒)为通过前面插入排序的对比不难发现，希尔排序能够较大的提高插入排序的速度]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之插入排序]]></title>
    <url>%2F2019%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说了两种排序算法，分别是冒泡排序和选择排序，这两种算法都比较容易理解。那么这次来学习第三种排序—-插入排序，这也是一种相对简单的排序算法，理解起来难度也不大。 算法思路将数组分成两部分： 一部分是有序数组 一部分是无序数组。 在每一趟排序中，从无序数组中拿出一个数来，放到有序数组的正确位置。即每一趟排序过后，无序数组元素减少一个，相应的有序数组元素增加一个。到最后该数组全部变为有序数组。 初始化有序数组长度为1，即arr[0]为有序数组。 第一趟排序，将无序数组中第一个元素arr[1]放到有序数组中，此时有序数组包含两个元素 第二趟排序，将无序数组中第一个元素arr[2]放到有序数组中，此时有序数组包含三个元素 …… 第n-1趟排序，将无序数组中第一个也是最后一个元素arr[n-1]放到有序数组中，至此数组全部有序可以看到，最后一趟排序过后，无序数组长度为0，至此数组全部有序。 代码实现 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个insertIndex和一个insertVal，和n的大小无关，所以是O(1) 稳定性 不难发现，插入排序是稳定的 另外，该排序算法在大部分元素已经是有序时比较好 算法速度和前面两个排序算法一样，我们来随机创建一个80000大小的随机数组，测试所用的时间最后测得的排序时间为让我们以ms为单位，再测试一次通过结果可以发现，相比于冒泡排序和选择排序，插入排序的速度还是很可观的。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下之计算机网路和因特网]]></title>
    <url>%2F2019%2F09%2F20%2F%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%2F</url>
    <content type="text"><![CDATA[最近在读计算机网络方面的书—–《计算机网络自顶向下方法》(第七版)，个人觉得书中概念讲的很清楚，举例也是很形象易懂了，如果你想学计网的话，5星强烈推荐！刚读完第一章，做个小结，方便回头复习。书中有些图有助于理解，建议搭配书本一起学习。 什么是因特网这一节主要从两个方面来解释什么是因特网 从因特网得具体构成，也就是从因特网的基本硬件和软件组成方面解释 从为分布式应用程序提供服务得联网基础设施来描述 具体构成描述因特网是一个世界范围内的网络，一个互联了遍及全世界数十亿计算设备的网络，这些计算设备包括计算机、手机、智能手表、电视…，用因特网术语来说，这些和因特网被称为主机/端系统。端系统通过通信链路和分组交换机连接到一起 通信链路 用来传输数据，由不同类型的物理媒体组成，例如同轴电缆、铜线、光纤… 传输速率：链路传输数据的频率，比特/秒(bit/s) 分组交换机 顾名思义，分组交换机从它一条如通信链路接收到达的分组，并从它的一条出通信链路转发该分组 两种有名的分组交换机：路由器和链路层交换机 链路层交换机通常位于接入网中 路由器通常位于网络核心中 分组 当端系统向另一台端系统之间发送数据时，发送端系统将数据分段，并为每段加上首部字节 由此形成的信息包用计算机网络术语来说称为分组 分组通过网络发送到目的端系统，并在那里被装配成原始数据 路径 一个分组所经历的一系列通信链路和分组交换机被统称为通过该网络的路径 也许通过上面的描述，你还是不明白数据在网络中怎么传输的。不着急，我们来举个例子：一个工厂需要将大量的货物搬运到数千里以外的某个目的地仓库。在工厂中，货物要分开并装上卡车车队。然后每辆卡车独立的通过高速公路、公路或立交桥组成的运输网络向仓库运送货物。在目的地仓库，卸下这些货物，并且与一起装载的同一批货物的其余部分堆放在一起。 工厂就相当于源端系统 货物就相当于数据 目的地仓库就相当于目的端系统 在工厂中将货物分开并装上卡车，即将数据分段，为每段加上首部字节，形成分组。因此、分组就相当于卡车。 高速公路、立交桥就相当于各种通信链路 分组交换机则相当于路的交叉口 公路两边的建筑物就相当于端系统 就像卡车选取运输网路的一条路径前行一样，分组选取计算机网络的一条路径前行 这下你明白了么？端系统通过ISP(Internet Service Provider,因特网服务提供商)接入因特网 ISP一个由多台分组交换机和多段通信链路组成的网络。各ISP为端系统提供了不同类型的网络接入，因特网就是将端系统彼此互联，因此为端系统提供接入的ISP也必须互联，后面会详细说到ISP 协议 控制着因特网中信息的接受和发送，端系统、分组交换机和其他因特网部件都要运行一系列协议 TCP(Transmission Control Protocal，传输控制协议)和IP(Internet Protocol，网际协议)是因特网中最为重要的协议 IP协议定义了在路由器和端系统之间发送和接收的分组格式 服务描述除了电子邮件、Web冲浪等传统应用外，因特网应用还包括手机和平板的应用程序。例如在线电影、多人游戏、视频会议…因为这些应用&lt;font color=bllue涉及到多个相互交换数据的系统，故它们被称为分布式应用程序。重要的是，这些因特网应用程序都是运行在端系统上的，即它们并不运行在位于网络核心的分组交换机中。假如你写了一个应用程序，运行在不同端系统上的软件需要相互发送数据(例如QQ、微博…)，这时候问题就来了，你怎么才能让运行在一个端系统上的应用程序指令因特网向运行在另一个端系统的软件发送数据呢？这个问题引出了另一种描述因特网的方法：即将因特网描述为应用程序的平台。与因特网相连的端系统提供了一个套接字接口(在Java中，接口就是规则)，该接口规定了运行在端系统上的应用程序请求因特网向运行在另一个端系统上的特定目的地程序交付数据的方式。 套接字 由端系统提供 规定了端系统上的应用程序请求因特网向另一个端系统上的特定目的地程序交付数据的方式。 一套发送程序必须遵循的规则集合 我们继续来做一个类比假设张三使用邮政服务向李四发送一封信。那我们知道，张三不能只是写了这封信，然后丢出窗外，这样邮政服务是不会接收的，李四也收不到信。正确的做法是什么呢？张三应该将信装在信封里，在信封上写李四的姓名、住址、邮编；在信封右上角贴上邮票；最后将信封丢进邮政的服务信箱中。这是邮政服务定义的规则，是每个要发信的人必须遵守的。同理，因特网也有一个发送数据的程序必须遵守的套接字接口(规则)，是因特网能向接收数据的程序交付数据。 什么是协议同样的，为了帮助理解，我们像举个例子类比一下协议这个概念。我们的生活中，无时无刻不在执行协议。假设张三遇到了李四，发生了下面一段对话 张三：你好，李四(李四发送报文) 李四：你好，张三(发送报文) 这时，李四对张三的回应按时着两人可以继续进行交谈(通信)。 但是如果是这样的： 张三：你好啊李四 李四：别烦我/没有理张三 李四的反应表明两人之间的交谈(通信)很勉强或者无法进行，这时张三可能会放弃和李四的交谈。 通过上面两段对话，可以知道，发送和接收的报文，以及这些报文发送、接收报文(在第一段中，李四接收报文后对张三进行了回复)或者其他事件出现时所采取的动作(在第二段中，李四没有进行回复)，在一个人类协议中起到了核心作用。如果两个人交谈时，使用不同的协议，例如张三和李四的语言不通，那么他们就无法通信。同样的，在网络中为了完成一项工作，要求两个(多个)通信实体运行相同的协议。网络的协议和人类协议类似，交换报文和采取动作的实体时设备而不是人 协议定义了在两个或多个通信实体间交换报文的&lt;font color=bllue格式和顺序，以及报文发送和或接受一条报文或其他事件发生时所采取的动作。因特网广泛的使用了协议，不同的协议用于完成不同的通信任务，掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式的过程。 网络边缘前面说过，通常把与因特网相连的计算机或其他设备称为端系统，它们位于互联网的边缘，因此被称为端系统。想象一下，在现实生活中，各种各样的房子/建筑物就相当于各种各样的端系统，建筑物前的公路将数以亿计的建筑物连接在一起，就相当于因特网将无数端系统连接在一起。通常路的尽头都是建筑物，建筑物位于公路系统的边缘，同样的端系统也位于互联网的边缘。端系统也称为主机，因为它们运行应用程序，主机有时又被分为两类：客户端和服务器。 接入网前面说到了位于网络边缘的端系统和应用程序，现在主要说一下接入网，这是指将端系统物理连接到边缘路由器的网络 边缘路由器端系统到任何其他远程端系统路径上的第一台路由器。下面说一下使用接入网的几种环境。 家庭接入家庭接入有大致4种不同的接入链路 DSL(Digital Subscriber Line，数字用户线) 电缆 FTTH(Fiber To The Home，光纤到户) 拨号和卫星 下面分别做一下了解 DSL-数字用户线住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。当使用DSL时，本地电话公司也是它的ISP(因特网服务提供商)。每个用户的DSL调制解调器使用现有的电话线(双绞铜线)与电话公司的数字用户线接入复用器(DSLAM)交换数据。家庭的DSL调制解调器得到数字信号后将其转换为高频音，通过电话线传输给电话公司，在电话公司的DSLAM处转换回数字信号。这样，电话线同时承载了数据和传统的电话信号，它们通过不同的频率进行编码 高速上行信道：50kHz-1MHz频段 中速下行信道：4kHz-50kHz频段 普通双向电话信道：0-4kHz频段 这种方法使得单根的DSL线路看起来就像有三根一样，因此一个电话呼叫和一个因特网连接能够同时共享DSL链路(后面会说到这种频分复用技术) 用户一侧：一个分配器把到达家庭的数据信号和电话信号分开，并将数据信号转发给DSL调制解调器 电话公司一侧：DSLAM把数据和电话信号分开，并将数据信号发送到因特网。 以上就是DSL接入方式。适用于短距离接入 电缆接入DSL利用电话公司的本地电话基础设施，而电缆因特网接入利用有线电视公司的有线电视基础设施。住宅从提供有线电视的公司获得电缆因特网接入。电视公司的电缆头端和地区枢纽通过光缆连接，地区枢纽使用传统的同轴电缆到达各家各户，每个地区枢纽通常支持500~5000个家庭。电缆因特网接入需要特殊的调制解调器，即电缆调制解调器。 家庭端类似DSL调制解调器，电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭PC，将数字信号转换为模拟信号。 电视公司的电缆头端电缆调制解调器端接系统(CMTS)，类似于DSL中的DSLAM，功能也类似。即将来自住户的电缆调制解调器发送的模拟信号转换回数字信号。 共享广播媒体 电缆因特网接入一个重要的特征是共享广播媒体。 由头端发送的每个分组向下行经每段链路到每个家庭，每个家庭发送的每个分组经上行信道向头端传输。因此，如果几个用户同时经下行信道下载一个视频文件，每个用户接收视频文件的实际速率将大大低于电缆总计的下行速率。 FTTH(光纤到户)从本地中心局直接到家庭提供了一条光纤路径，有两种方案 直接光纤，从本地中心局到每户设置一个光纤 从中心局出来的每根光纤实际上由多个家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤，进行这种分配形成了两种光纤分布体系方案 主动光纤网络(Active Optical NetWork,AON)，AON本质上就是交换因特网，后面会说到 被动光纤网络(Passive Optical NetWork,PON) 简单说一下PON 家庭端每个家庭具有一个光纤网络端接器(ONT)，用户将一台家庭路由器和ONT相连,并通过这台路由器接入因特网。ONT由专门的光纤连接到邻近的分配器，分配器把一些家庭(一般100个)集结到一根共享的光纤。 公司端该光纤在连接到本地公司的光纤线路端接器(OLT)，OLT提供了光信号和电信号之间的转换，经过本地公司的路由器和因特网相连 在PON体系中，所有从OLT发送到分配器的分组在分配器处复制。 拨号和卫星在无法提供上面三种接入的地方，能够使用这两种方式，速度较慢。 企业和家庭接入在公司和大学校园以及越来越多的家庭环境中，使用局域网(LAN)将端系统连接到边缘路由器，局域网技术有很多种，目前以太网是最流行的接入技术(会在后面讲到该技术)。 以太网用户使用双绞铜线与一台以太网交换机相连 以太网交换机或者这样相连的网络再与更大的因特网相连。 还有越来越多的手机等设备无线接入因特网。在无线LAN环境中： 无限用户从一个接入点发送/接收分组； 该接入点与企业网连接(可能是用了有线以太网)； 企业网再与有线因特网相连。现在我们知道的WiFi，就是基于IEEE802.11技术的无线LAN接入。 广域无线接入：4G和LTE 4G(第四代广域无线网络)我们平常使用的手机网络(联通、电信…)也能够接入因特网，这就用到了与蜂窝电话相同的无线基础设施，通过蜂窝网提供商(电信…)运营的基站来发送和接收分组。和WiFi不同的是，我们在使用4G网络的时候，并不需要在接入点几十米范围内，而是在基站数万米内都可以使用。 LTE(Long-Term-Evolutuon,长期演进)来源于3G技术 物理媒体在前面说到因特网一些接入技术的时候，说到了所使用的物理媒体。例如DSL使用了双绞铜线，电缆接入网络使用了光纤和同轴电缆…接下来就简要说一下常用的物理媒体。我们描述下一个bit从一个端系统开始传输，经过一系列链路和路由器，到达另一个端系统的历程。 源端系统发送这个bit，不久后第一台路由器接收该bit 第一台路由器转发该bit，不久后第二台路由器接收 ……中间经历了若干个路由器最终到达端系统 因此，该bit从源到目的地传输时，通过一系列的“发射器-接收器”对。对于每个发射器-接收器对，通过跨越一种物理媒体传播电磁波或光脉冲来发送该比特。物理媒体有多种形状和形式，并且对沿途的每一个发射器-接收器对来说不必具有相同的类型。物理媒体分为两种 引导型媒体：电波沿着固体媒体前行，如光缆、双绞铜线以及同轴电缆…… 非引导型媒体：电波在空气或外层空间种传播，如无线局域网或数字卫星频道中。 另外，物理链路(铜线、光缆等)的实际成本与其他网络成本相比通常小很多。下面说几种常见的物理媒体： 双绞铜线 最便宜最常用的引导型传输媒体； 由两根绝缘铜线组成以规则的螺旋排列，一对电线构成了一个通信链路。 数据传输速率取决于线的粗细以及传输方和接收方之间的距离。 同轴电缆和双绞线类似，由两个铜导体组成，但这两个铜导体是同心而不是并行的，同轴电缆能够达到较高的数据传输速率，在电缆电视系统中相当普遍。特别的，许多端系统能够直接与该电缆相连，每个端系统都能接收由其他端系统发送的内容。 光纤一种柔软的、能够引导光脉冲的媒体，每个脉冲表示一个bit。有以下特点： 比特速率极高 不受电磁干扰并且光缆信号衰减极低 很难窃听 这些特征使得光纤成为长途引导型传输媒体，特别是跨海链路&gt;。 陆地无线电信道无线电信道承载电磁频谱中的信号，不需要安装物理线路，并且具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力。无线电信道的特性依赖于传播环境和信号传输距离。环境上取决于 路径损耗 遮挡衰落(信号跨距离传播通过阻碍物时信号强度降低) 多径衰落(干扰对象的信号反射) 干扰(由于其他传输或电磁信号) 陆地无线电信道大致划分为三类 运行在很短距离：个人设备如无线头戴耳机、无线鼠标… 运行在局域，通常数十到几百米：无线LAN技术使用的就是该局域无线电信道 运行在广域，跨越数万米：蜂窝接入技术使用的就是该广域无线电信道 卫星无线电信道一颗通信卫星连接地球上两个或多个微波发射/接收器，它们被称为地面站。该卫星在一个频段上接受传输，使用一个转发器(后面会说到)再生信号，并在另一个频段上发射信号。通常用于无法使用DSL或电缆接入的区域。 网络核心前面说完了网络边缘，现在这里说一下网络核心，即由互联因特网端系统的分组交换机和链路构成的网状网路。 分组交换在各种应用程序中，端系统彼此交换报文。报文能够包含协议设计者需要的任何东西，可以包含控制功能，也可以包含数据。源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。分组以等于该链路最大传输速率的速度通过通信链路。例如，源或分组交换机将一个长为L的分组发送出去，链路的传输速率为R(bit/s)，那么传输该分组的时间为L/R秒。 存储转发传输交换机能够开始向输出链路传输该分组的第一个bit之前，必须接收到整个分组。多数分组交换机在链路的输入端使用存储转发传输。 排队时延和分组丢失每台分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个输出缓存/输出队列 输出缓存/输出队列用于存储路由器正准备发往那条链路的分组。 该输出缓存在分组交换中作用很大，如果到达的分组需要传输到某条链路，但发现该链路正在忙于传输其他分组，那么该分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延。这些时延是变化的，取决于网络的拥塞程度。 分组丢失前面说过，分组可能将会在路由器中的输出缓存中等待，因为缓存空间大小是有限的，一个到达的分组可能发现路由器的缓存空间已经被其他等待传输的分组完全充满。在这种情况下，将会出现分组丢失/丢包。到达的分组或已经排队的分组之一将被丢弃。 转发表和路由选择协议路由器从一条通信链路得到分组，然后向与它相连的另一条链路转发分组，那么问题来了，路由器是怎么决定它应当向哪条链路进行转发呢？在因特网中，每个端系统都有一个地址，被称为IP地址。当源主机要向目的主机发送一个分组时，源在该分组的首部包含了目的主机的IP地址。如同邮政地址一样，该地址具有等级结构。分组到达路由器时，路由器检查该分组目的地址的一部分，并向一台相邻的路由器转发该分组。更特别的，每台路由器具有一个转发表 转发表用于将目的地址(或目的地址的一部分)映射成输出链路。 当分组到达路由器时，路由器检查分组的目的地址(或一部分)，用这个地址搜索转发表，找到合适的出链路，路由器将分组导向该链路。 转发表的设置因特网具有一些特殊的路由选择协议，用于自动的设置这些转发表。 电路交换在电路交换网络中，端系统会话期间，预留了端系统间路径通信所需要的资源。而在分组交换网络中，这些资源则不是预留的，会话的报文按需使用资源，这样就带来了等待(排队)接入链路。 举例说明，现有两家餐馆 分组交换不需要预定，但不保证能安排顾客，即顾客去的时候可能餐馆满了，就需要排队等待 电路交换在去之前必须提前预定，虽然麻烦，但是我们到的的时候能够立即入座点菜。 传统的电话网络就是电路交换的例子，在发送方能够发送信息之前，该网络必须在发送方和接收方建立一个名副其实的连接，因此此时沿着该发送方和接收方之间路径上的交换机都将为该连接维护连接状态。该连接被称为一条电路 当网络创建这种电路时，也在连接期间为该网络链路上预留了恒定的传输速率(每条链路传输容量的一部分)，能够确保发送方以恒定速率向接收方传输数据。 例如：A向B发送报文，网络必须在链路中预留一条电路，如果一个链路的传输速率为1Mbps，有四条电路，那么A向B发送报文的速率恒定为250kbps，即使该链路此时只有这一条连接。 电路交换网络中的复用前面说的电路是通过频分复用(FDM)或时分复用(TDM)来实现的，并不是真正的电线电路。 频分复用(FDM)链路的频谱由跨越该链路创建的所有连接共享。特别的，在连接期间为每条连接专用一个频段。在电话网络中，这个频段的宽度通常为4kHz。这个频段的宽度称为带宽 时分复用(TDM)对于时分复用，时间被划分为固定时期的帧，每个帧又被划为为固定数量的时隙。当网络跨越链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用。在TDM中，一条电路的传输速度等于帧速率乘一个时隙中的比特数量。例如一个帧为1分钟，一个帧有60个时隙(即一个时隙1秒)，如果网络指定第二个时隙为该连接专用，那么在每分钟的第二秒时间内为该链接传送数据，其他的时隙即使没有连接使用，该链接也不能使用。 通过上面的描述我们不难发现，电路交换虽然能够保证数据传输的速率，但是往往会造成资源的浪费，总体上说分组交换要更优一些。 网络的网络前面说过，端系统通过一个接入ISP和因特网相连，因为因特网是将数以亿计的端系统相连，因为ISP自身也必须互联，通过创建网络的网络可以做到这点。 网络的网络可以理解为将ISP连接成网络，因为ISP自身就是一个网络，将许多ISP连接成网络，就实现了与不同ISP相连的端系统相连。 总的来说，今天的因特网是一个网络的网络，由十多个第一层ISP和数十万个较底层的ISP组成，较低层的ISP与较高层的ISP相连，较高层的ISP彼此互联。用户和内容提供商是较低层ISP的客户，较底层ISP是较高层ISP的客户。也有一下大型的内容提供商(谷歌等)创建自己的网路，直接在一些地方和较低层ISP互联。从而减少这些大型内容提供商向顶层ISP支付的费用。 分组交换网中的延时、丢包和吞吐量因特网能够看成是一种基础设施，为运行在端系统上的分布式应用提供服务。在理想情况下，我们希望它能够在任意两个目标端系统之间随心所欲地移动数据而不会产生数据丢失。然而，这是很难做到的。相反的，计算机网络必定要限制在端系统之间的吞吐量，在端系统之间引入时延、并且也会丢失分组。 吞吐量每秒能够传送的数据量 时延概述前面说过，分组从源到目的地的过程中，当分组从每个节点(主机或路由器)沿着这条路径到后继节点，该分组在每个节点经受了几种不同类型的时延 节点处理时延 排队时延 传输时延 传播时延 这些时延加起来就是节点总时延。 节点处理时延检查分组首部和决定该分组导向何处所需要的时延是节点处理时延的一部分，通常是微秒或更低的数量级 排队时延在队列中，当分组在链路上等待传输时，它经受排队时延。一个分组排队时延取决于在它前面正在排队等待向链路传输的分组数量如果队列为空，那么排队时延为0。通常是毫秒到微秒量级 传输时延将所有分组的bit推向链路所需要的时间，单位是bit/s，通常是毫秒到微秒量级 传播时延当比特被推向链路后，该比特需要向下一个路由器传播。从该链路的起点到路由器B传播所需要的时间是传播时延。传播时延等于两台路由器之间距离除以传播速率。在广域网中，通常是毫秒量级 传输时延和传播时延的比较 传输时延由路由器将分组推向链路所需要的时间，和距离无关，和分组大小相关；单位是bit/s。 传播时延是分组被路由器推出链路后经过链路传播到下一台路由器所需要的时间，和分组长度无关，和两台路由器之间的距离相关；单位是m/s。 排队时延和丢包排队时延 假设a表示分组到达队列的平均速率(以bps/s为单位) R表示传输速率，即从队列中推出比特的速率(以bps/s为单位) 假定所有的分组都由L个比特组成。 那么bit到达队列的平均速率为(La)bps/s。最后，假设该队列很大，能够容纳无限数量的bit，那么比率La/R被称为流量强度 流量强度 La/R&gt;1，即比特到达队列的平均速率超过从该队列传输出去的速率。这时，队列将会无限增加，排队时延就会趋于无穷大。 La/R≤1，这时，到达流量的性质将影响排队时延。 分组周期性到达，即每L/R秒到达一个分组，则每个分组到达时，队列刚好将上一个分组全部推出。此时队列为空，就不会有排队时延 分组以突发形式到达，即在某个时刻同时到达很多分组。就可能会有很大的平均排队时延 因此：设计系统时流量强度不能大于1。通常情况下，分组到达队列的时间是随机的 到达速率小于传输能力时队列的长度将缩短 流量强度接近于1时平均队列长度将会变得越来越长。 丢包在上面，我们假设了队列能够容纳无穷多的分组，在现实中，链路的队列容量是有限的。随着流量强度接近于1，队列并不是趋于无穷大。到达的分组发现一个满的队列，该分组将会被路由器丢掉。丢失的比例随着流量强度的增加而增加。因此，一个节点的性能不仅根据时延来度量，也根据丢包的概率来度量。后面会说到，丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源送到了目的地。 端到端时延前面的讨论集中在节点时延上，即在单台路由器上的时延，这里考虑从源到目的地的总时延(端到端时延)端到端的时延就是源主机的时延和路由器时延之和，即节点时延的总和 计算机网络中的吞吐量 瞬时吞吐量A向B发送数据，任何时间瞬间B接收该文件的速率 平均吞吐量A向B发送大小为Fbit的文件，B接收所有Fbit用了Ts，则平均吞吐量为F/T 服务器传送一个文件到客户端，两者之间只有一台路由器 假设Rs为服务器和路由器之间的链路速率 假设Rc为路由器和客户端之间的链路速录 假设网络中只有该服务器到客户端的bit在传送 那么服务器到客户端的吞吐量就是min(Rs,Rc)我们想象bit是流体，链路是管道。显然，这台服务器不能以超过Rs的速率发送bit，路由器也不能以超过Rc的速率转发，最终的吞吐量取决去两者中小的那一个。服务器传送一个文件到客户端，两者之间有N-1台路由器 那么就有N条链路 假设这N条链路的速率分别是R1、R2…Rn 那么服务器到客户端的吞吐量就是min(R1,R2…Rn)目前，因特网核心都超量配置了高速率的链路，很少发生拥塞，今天在因特网中对吞吐量的限制因素通常是接入网。但是并不绝对，当很多客户端和服务器公用一条共享链路时，由于链路需要同时为多个客户端服务器传输数据。这时共享链路可能称为限制吞吐率的因素。 协议层次机器服务模型各层的所有协议被称为协议栈。因特网协议栈由5个层次组成，从上到下依次是 应用层 运输层 网络层 链路层 物理层 下面就分别简要的说一下每一层 应用层网络应用程序以及它们的应用层协议存留的地方应用层协议包括 HTTP：HyperText Transfer Protocol(超文本传输协议)，提供了Web文档的请求和传送 SMTP：Simple Mail Transfer Protocol(简单邮件传输协议)，提供了电子邮件报文的传输 FTP：File Transfer Protocol(文件传输协议)，提供了两个端系统之间文件传送 DNS：Domain Name System(域名系统) …… 应用层协议分布在多个端系统上，端系统的应用陈旭之间使用协议交换信息分组。这种位于应用层的信息分组称为报文。 运输层因特网运输层在应用程序端点之间传送应用层报文。两种应用层协议 TCP：向应用程序提供了面向连接的服务，包括应用层报文向目的地传输的确保传递和流量控制(发送方/接收方速率匹配)TCP将长报文划分为短报文，并提供拥塞控制机制，当网络拥塞时，源抑制其传输速率。 UDP向应用程序提供了无连接的服务，没有可靠性、没有流量控制、也没有拥塞控制。 将运输层的分组称为报文段。 网络层因特网网络层负责将网络层分组(数据报)从一台主机移动到另一台主机。源主机中的运输层协议(TCP/UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信时提供的地址一样网络层协议 IP协议：该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。 路由选择协议：确定路由器的转发表。 …… 将网络层的分组称为数据报。 链路层因特网的网络层通过源和目的地之间一系列的路由器来路由数据报。为了将分组从一个节点(路由器/主机)移动到下一个节点，网络层必须依靠链路层的服务。 在每个节点，网络层将数据下传给链路层，链路层沿着路径(链路)将数据报传递给下一个节点。 到达下一个节点，链路层再将数据上传给网络层。 链路层提供的服务取决于应用于该链路的特定的链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。注意：这里的可靠连接服务不同于TCP的可靠传输服务。TCP提供从一个端系统到另一个端系统的可靠交付。链路层协议 以太网 WiFi 电缆接入网的DOCSIS协议 因为数据从源到目的地通常会经过几条链路，这些链路可能应用的链路层协议不同。网络层将受到每个不同链路层协议的不同服务将链路层的分组称为帧。 物理层链路层的任务是将整个帧从一个节点移动到临近的节点，而物理层的任务是将该帧的一个个bit从一个节点移动到临近的节点。该层的协议仍和链路层相关，并且进一步和该链路的实际传输媒体相关。例如以太网具有很多物理层协议： 关于双绞铜线的 关于同轴电缆的 关于光纤的 …… 封装数据从发送端系统的协议栈向下，沿着中间的链路层交换机的路由器协议栈上上下下，然后向上到达接收端系统的协议栈。 链路层交换机实现了第一层和第二层，即物理层和链路层 路由器实现了第一层到第三层，即物理层到链路层再到网络层。 这意味着路由器能实现IP协议，链路层交换机则不能。但是链路层交换机能够识别第二层地址如以太网地址。主机实现了所有5个层次，因为在发送数据时，需要将数据层层封装，最后封装为帧(链路层分组)，在接收数据时相反。因此主机必须实现所有的5个层次。 每一层的封装 在发送主机端应用层报文被传送给传输层 运输层传输层收取到报文并附上附加信息，该首部信息将被接收端的运输层使用。应用层报文和运输层首部信息一起构成了运输层分组—-报文段。并将该报文段传递给网络层。 网络层增加了源和目的地端系统的地址等网络层首部信息，运输层报文段和网络层首部信息一起构成了网络层分组—-数据报。并将该数据报传递给链路层。 链路层增加自己的链路层首部信息，网络层数据报和链路层首部信息一起构成了链路层分组—-帧。 所以我们看到，在每一层，一个分组具有两种类型的字段 首部字段：在当前层添加上的 有效载荷字段：该字段通常是来自于上一层的分组 实际上，封装的过程可能更加复杂。例如，一个大报文可能被划分为多个运输层的报文段(同样的，这些报文段可能被划分为多个网络层数据报)，在接收端，必须从其连续的数据包中重构这样一个报文段。 第一章内容大致就这些，后面的网络攻击就不说了。后续的等看完一章写一章吧，一共16k个字，纯手打。在记录的过程中无形中对第一章内容又回顾了一遍，很明显感觉得到理解的更深入了，希望看完这篇博客的你也能学到一些知识哦。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之选择排序]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面说过了冒泡排序，这次来说一下选择排序。同样的，这次也会从算法思路、代码实现以及算法分析三个思路来剖析选择排序 算法思路 第一次从arr[0]和arr[n-1]中选取最小值，与arr[0]交换 第二次从arr[1]和arr[n-1]中选取最小值，与arr[1]交换 ……以此类推 第n-1次从arr[n-2]和arr[n-1]中选取最小值，与arr[n-2]交换 至此，得到一个从小到大的有序数组，一共进行n-1轮 对于一个数组arr={3,-1,9,10,-2} 代码实现 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个min和一个index，和n的大小无关，所以是O(1) 稳定性 不难发现，选择排序不是稳定的 另外，该排序算法在n比较小时较好 和冒泡排序比较这里，我创建了一个80000大小的数组对其进行排序，分别使用冒泡排序和选择排序，并记录两种排序耗费的时间 冒泡排序 选择排序 通过上面的对比发现，对同样规模的随机生成的数组进行排序，选择排序要比冒泡排序快很多 通过查看两种排序的实现过程不难发现： 冒泡排序，每一趟排序中，相邻元素如果逆序，都要进行交换操作，整个排序过程会进行很多次交换操作 选择排序，每一趟排序中，只需要找到最大值/最小值的元素即其下标，最后只进行一次交换交换操作，整个排序过程最多进行n-1次交换操作 两方法时间上的差异就在这里体现的]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之冒泡排序]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[正如categories所言：算法之美，是的，算法是美妙的，尤其是好的算法，总会让人感到眼前一亮，让人茅塞顿开。而今天说到的排序算法，是我们日常生活中用的及其之多的一种算法，排序算法种类也有很多，这篇博客记录的是其中较为简单地一种——冒泡排序 算法思路 通过对排序序列从前向后(数组下标从小到大)开始，依次比较相邻元素的值 若发现两相邻元素逆序，则交换两相邻元素的位置，使值较大的元素逐渐从前移到后 第一趟排序使序列中最大的元素移到最后一个位置 第二趟排序使序列中第二大的元素移到倒数第二个位置 ……以此类推 一共需要n-1趟排序(n为序列的大小) 对于一个数组arr={3,-1,9,10,-2} 代码实现 优化冒泡排序因为每一趟排序都是将未排序部分的相邻元素进行比较，逆序则交换位置，那么反过来，在某一趟排序中，如果没有发生元素交换，说明该数组已经有序，就不用在进行之后的排序对于一个数组arr={3,-1,9,10,20} 设置一个boolean类型的flag，初始化为true 将循环趟数的条件改为flag==true&amp;&amp;i &lt; arr.length 在进入某一趟排序之前，先将flag设置为false。 如果在这一趟排序中，发生了相邻元素的交换，那么将flag重新设置为true 如果在这一趟排序中，没有发生相邻元素的交换，flag不变 在进行下一趟循环时，判断flag是否为true 如果为true，进行下一趟循环 如果为false，说明在上一趟排序中已经得到有序数组，那么不再进行下一趟排序 优化冒泡排序算法代码实现同样对于上面的数组arr={3,-1,9,10,20}，使用优化冒泡排序这样就达到了优化的目的 分析 算法的时间复杂度 平均时间：O(n²) 最差情况：O(n²) 这不难理解，因为对于一个简单地双重循环来说，时间复杂度都是O(n²) 空间复杂度 只用了一个临时变量和一个flag，和n的大小无关，所以是O(1) 稳定性 稳定性：即在排序过程中，对于两个大小相等的数A和B，排序前A在B的前面，如果排序后A还在B的前面，即排序前后不改变想等元素的顺序，那么称该排序方法是稳定的 不难发现，冒泡排序是稳定的 另外，该排序算法在n比较小时较好]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[八皇后问题一个古老而著名的问题，该问题是回溯算法的典型案例。在8*8格的国际棋盘上摆放8个皇后，使其相互不能攻击。即：任意两个皇后不能处于同一行、同一列或同意斜线上，问有多少中摆法？ 问题分析 第一个皇后先放在第一行第一列 第二个皇后放在第二行第一列，然后判断是否满足条件 不满足：继续放在第二行第二列…依次把所有列放完，找到一个合适的位置 满足：摆放下一个皇后(递归) 直到第八个皇后也能放在一个满足条件的位置，就算找到一个正确解(递归出口) 当得到第一个正确解时，就会开始回溯，即将第一个皇后放在第一列的所有正确节点全部找到 然后回头继续将第一个皇后放在第二列，后面继续循环执行上面的步骤 一维数组代替二维数组理论上，我们应该创建一个二维数组表示棋盘，但实际上可以通过算法，用一个一维数组解决问题例如：arr[8]={0,4,7,5,2,6,1,3} 数组arr的下标：表示第几行，即第几个皇后 arr[i]=val：表示第i+1个皇后放在第i+1行的val+1的位置 检查冲突的方法该方法用于检查当前第n个皇后和前面的n-1个皇后是否发生冲突(即是否在同一行、同一列或同一斜线上) arr[n] == arr[i]：数组的值表示的是列，这里是判断第i+1个皇后是否和第n+1个皇后在同一列 Math.abs(n-i)==Math.abs(arr[n]-arr[i])：判断第i+1个皇后是否和第n+1个皇后在同一斜线 Math.abs(n-i)：第i+1个皇后和第n+1个皇后的行数差 Math.abs(arr[n]-arr[i])：第i+1个皇后和第n+1个皇后的列数差如果行数差==列数差，说明两个皇后在同一斜线上 递归回溯方法 首先，创建一个长度为9的数组，0-7用于表示8个皇后，最后一个用于记录摆放方法个数 当n==MAX=8时：之前说过，n代表第n+1个皇后(例如n=0时代表第一个皇后)，那么n=8应该代表的是第9个皇后，这时候说明前8个皇后都已经摆放好了，即找到了一种摆放方法 arr[MAX]++：个数+1； 打印当前摆放方法 n&lt;MAX说明皇后还没有摆放完，先将当前皇后摆放在第i列，检查这个位置是否和前面已经摆放的皇后位置冲突 如果不冲突，递归调用方法，摆放下一个皇后 如果冲突，i++，回到第3步。(即将当前皇后摆放到下一列，继续判断) 当找到一种正确方法后，会向上回溯 前面7个皇后位置不变，将第8个皇后从当前列往后摆，找到所有正确的摆法 前面6个皇后不变，将第7个皇后向后摆放1列 将第8个皇后从第1列往后摆，找到所有正确的摆法 回到第2步，直到将第7个皇后摆放到最后1列，找到所有正确的摆法 前面5个皇后不变…. 以此类推，直到最后将第1个皇后摆放到最后1列。这样，就找到了所有正确的解法！]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫问题]]></title>
    <url>%2F2019%2F09%2F18%2F%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[迷宫问题有一个迷宫，迷宫中有一个小球，要求给小球一个起始位置和迷宫的终点位置，给小球找到一条路能够到达终点位置。 构建迷宫 用一个二维数组模拟迷宫 用1表示围墙和障碍物 用2表示小球从起始位置到终点位置走过的点以下就是构建好的迷宫 递归解决 定义一个方法、传递一下参数 毫无疑问、要将map二维数组传递进去 将小球的起始位置传递进去 由于这里默认出口是最右下角，就不传递终点位置了 递归出口：前面说到了，用2表示小球走过的点，那么当终点位置map[6][5]==2时，说明小球已经走到了终点，递归结束 判断当前点map[i][j]是否为0,如果为0 先假定通过当前点能到达终点位置，即将当前点设置为2 设置寻路策略：即每次到达一个点，就会有上下左右四种走法，所谓寻路策略，即指定小球先向哪个方向走，该方向走不通后再向哪个方向走，这里我指定的寻路策略是下右上左 如果该点的四个位置都走不通，那么说明该点不通，此时将当前点设置为3，即map[i][j]=3,表明该点走过，确认走不通 如果不为0，那么当前点的取值情况有三种 map[i][j]==1，说明该点为墙，走不通，返回false map[i][j]==2，说明该点走过了，就不能再走了，返回false map[i][j]==3，说明该点已经确定了走不通，返回false 找到出路最后根据我下右上左的寻路策略找到的路线其中2代表的就是起点到终点的路线，通过不同寻路策略找到的路线可能不同 对于递归解决迷宫问题，我想可以这么理解每次走到一个点时，都会按照寻路策略的顺序走 如果某个方向能走通，那就继续往下走 如果到了某个点时，该点四个方向都走不通，那么就回溯，即回到该点的上一个节点，从上一个点的其他方向继续走 例如：对于A点，我们按照寻路策略先向下走，走到了B点，这时候发现，B点四个方向都走不通，那么就回退到A点，按照寻路策略向右走。以此类推，直到找到终点和每个点都被标记为3。]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰计算器]]></title>
    <url>%2F2019%2F09%2F16%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[今天重新学习了一下栈这一经典的数据结构，突然想起来当时大二为了进实验室用安卓写的一个计算器app，当时也是年轻，虽然写出来了，但是对于中缀转后缀却仍是似懂非懂、迷迷糊糊，所以趁着刚复习完栈这个号时候，准备趁热打铁，把这方面给弄明白了。 概念什么是中缀表达式中缀表达式，就是我们平常见到的表达式，例如1+((2+3)*4)-5。它便于我们理解和计算，但是却不利于计算机来运算，因为在运算过程中需要不停的判断操作符优先级 什么是后缀表达式后缀表达式，又称为逆波兰式，上面的1+((2+3)4)-5。转换成后缀表达式就是123+4+5-，计算机在计算后缀表达式的时候，不用判断操作符的优先级，每次遇到操作符，直接从栈中弹出两个操作数进行相应的运算即可，但是这样的表达式对我们来说写出来就比较困难，尤其是在表达式比较长比较复杂的时候。 中缀转后缀首先，我先说一下我的大致思路 将中缀表达式的字符串存储到一个ArrayList中==&gt;这一步主要是方便操作、 一个存放操作符的栈s1 注意：网上大多的教程是准备两个栈，一个存放操作符，一个存放的是逆序的后缀表达式，但这里我用ArrayList集合代替了第二个栈，这样做的好处就是可以直接得到后缀表达式，而非逆序的，至于为什么后面会说 中缀表达式集合 遍历字符串 如果当前字符是操作符，那么直接加入到集合中 如果当前字符是操作数，那么就要考虑多位数操作数的问题 继续向后遍历，如果后面的字符仍是操作数，就将这些数拼接起来 直到当前字符不是操作数为止，将拼接的字符串加入到集合中 判断操作符优先级 后缀表达式集合上一步我们得到了一个集合，集合中存储着中缀表达式内容，这一步就要将中缀表达式转换为后缀表达式并存储到集合中步骤： 创建变量 栈s1用于存放操作数 集合ls用于存放后缀表达式 遍历中缀表达式集合list，如果是操作数，直接放到ls集合中 如果是”(“，直接压入s1中 如果是”)”，将s1中的操作符出栈并加入到ls集合中，直到s1栈顶元素为”(“为止，最后将”(“也出栈(但是不加入ls中)，这一步操作目的是消去”()” 如果是操作符 如果s1栈为空，那么直接入栈 如果当前操作符优先级大于栈顶操作符优先级，将当前操作符入栈 如果当前操作符优先级不大于栈顶操作符优先级，那么将栈顶元素出栈并加入到ls集合中，继续和新的栈顶操作符比较，直到栈为空或者当前操作符优先级大于栈顶操作符优先级为止 将当前操作符压入s1中 集合list遍历完毕后，将s1中所有元素依次出栈加入到ls集合中 最后得到的ls集合就是后缀表达式 注意：这里如果用栈代替集合，那么由于栈先进后出的特性，得到的只能是逆序的后缀表达式，还要进一步的转换才能得到后缀表达式 计算后缀表达式 创建一个栈stack用于存放操作数 从左向右扫描后缀表达式集合 如果是操作数，直接入栈 如果是操作符，就从stack中弹出两个操作数进行运算，并将运算结果重新入栈 集合遍历完毕，stack剩下的元素就是最后的结果 这样一个简单地逆波兰计算器就成功了，核心逻辑在于如何利用栈将中缀表达式转换为后缀表达式(逆波兰式)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的环问题]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先，关于单链表的环，一般涉及到以下几个问题 给一个单链表，判断是否有环 如果存在环，找出环的入口点 如果存在环，求出环上节点的个数 如果存在环，求出链表的长度 判断是否有环解法一：快慢指针法 有两个指针fast和slow，开始时两个指针都指向链表头head 将两个指针同时向后移动 fast每次走两步==&gt;fast=fast.next.next slow每次走一步==&gt;slow=slow.next 如果没有环，那么fast和slow一定不会相遇；当fast.next==null||slow==null时说明该链表没有环，因为有环的链表没有nul指针 如果有环，那么slow一定会和fast相遇,并且此时slow指针最多绕环一圈，即slow走的步数一定小于等于单链表的节点数 可以这么理解，当链表时环形链表时，环是最大的，此时slow刚好绕环一圈回到头指针指向的节点时 fast的速度是slow的二倍(因为fast每次走2步)，所以fast此时一定走了两圈，也回到了头指针指向的节点，最终会在头节点相遇 如果链表不是环形链表，那么环的长度就会更短，此时fast一定能在slow走完一圈之前和slow相遇 (可以画图帮助理解)方法返回的是相遇的节点 解法二：HashSet法 遍历链表，将当前节点的引用存储到HashSet中 如果当遍历到某个节点时，HashSet集合中已经存在该节点的引用，那么说明该链表有环，并且第一个重复的节点就是入环口 找出环的入口点如果用HashSet方法来解决第一个问题，那么这个问题就同时得到了解决如果用快慢指针法解决第一题，那么得到fast和slow第一次相遇的节点， 假设slow和fast相遇时，slow还没有走完链表，即链表不是首尾相接的环形链表分析 假设 链表的长度为L 环的长度为r(即环有r个节点) head节点到入环口的距离为a(即从head到入环节点要走a步) 入环口和相遇点的距离是x(从入环节点到相遇点要走a步) 假设fast和slow相遇时，fast已经在环内循环了n圈，slow走了s步，在环内走一圈的步数=环的长度 那么fast走过的步数为：2s步 则有：2s=s+n *r–&gt;s=nr 又有s=a+x–&gt;因为前面说过slow节点没有走完一圈，所以这就是最简单的步数相加 所以得到a+x=n*r a+x=(n-1)*r+r a+x=(n-1)*r+L-a a=(n-1)*r+(L-a-x) a：head到入环节点要走a步 (L-a-x)：从向相遇节点到入环节点要走(L-a-x)步 经过上面分析可以总结得到解决方法 设置两个临时指针str1和str2 str1=head str2=slow(slow是第一问得出的相遇节点) 让两个节点同时往后走，直到str1==str2为止 str1=str1.next str2=str2.next str1==str2时退出循环，此时的str1/str2就是入环节点 特殊情况：即链表首尾相接(环长度最大) 此时slow节点和fast节点在head相遇，即slow==head 根据上面的代码会直接返回head/slow，因此也满足特殊情况 求出环上节点的个数解法一：相遇节点法 设置一个临时指针temp=slow(相遇节点) 让临时指针temp后移–&gt;temp=temp.next，并记录移动次数count 当temp==slow时，说明temp绕环走了一圈，count就是换的长度 解法二：快慢指针法 设置两个临时指针，str1=str2=slow(相遇节点) str1每次走一步、str2每次走两步，并记录str1走的步数count str1=str1.next str2=str2.next.next 当str1==str2(再次相遇)时，说明str2刚好比str1多走1圈，此时count就是环上节点的个数 假设再次相遇时str1走了s步、str2走了2*s步、环的长度为r 由分析得到2*s=s+r，所以s=r; 求出链表的长度链表长度L=head节点到入口节点的距离a+环的长度r根据上面两个问题，这个就很好解决]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>HashSet</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Josefu问题(约瑟夫环)两种解决方法]]></title>
    <url>%2F2019%2F09%2F15%2FJosefu%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF-%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[约瑟夫问题设编号为1、2….n的n个人坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出圈，他的下一位又从1开始报数，数到m的人又出圈，以此类推，直到所有人出圈为止，由此产生一个出圈编号的序列 解法一：循环链表 首先对参数k、m、n进行校验，确保k、m、n在正常范围内 创建一个辅助指针helper 让helper指向first前一个节点，即指向最初链表的最后一个节点 将first和helper向后移动k-1次，即让first指向开始报数的小孩 当helper==first时，说明圈中只有一个小孩 helper！=first时，将first和helper同时向后移动m-1次 将移动m-1此之后first指向的节点出圈 继续执行5，直到helper==first为止 其中方法的参数： k：第一次开始报数的小孩 count：每次数几下(m) nums：最开始圈中小孩数 这个约瑟夫问题是基于我自己创建的单向环形链表实现的(或者说我创建的单向环形链表是用来解决约瑟夫问题的)，helper节点最初就指向first前一个节点，所以2和3两步骤可以省略(可以看一下我创建单项循环链表的博客) 解法二：数组对于数组，进行出圈操作的时候就不能向链表一样删除节点了，因为数组的长度是固定的，那么怎么解决呢？我们可以将已经出圈的孩子所在的元素值赋值为0，这样，当我们遍历到元素值为0的节点时，就可以跳过该节点。步骤： 首先对参数k、m、n进行校验，确保k、m、n在正常范围内 因为数组下标是从0开始，小孩编号从1开始，所以让开始数数的小孩编号-1==&gt;k=k-1 根据nums创建数组，模拟nums个小孩组成的圈 一共有nums个小孩，所以一共要循环报数nums次==&gt;for (int i = 0; i &lt; nums; i++) {} 每一次报数m次，所以k要移动m-1次(起初报数时，自己也算一次)，当k代表的数组元素a[k]==0时，说明当前孩子已经出圈，所以需要k再次移动，直到a[k]!=0==&gt;for (int j = 0; j &lt; m - 1||arr[k]==0;) {} 第5步得到的k是该赋值为0的元素，即该出圈的孩子编号-1==&gt;k+1即为当前该出圈的孩子编号 a[k]=0，并且将k取模移向下一位 重复567nums次，直到所有孩子都出圈]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>环形链表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-环形链表]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[环形链表，顾名思义，就是整个链表构成一个环，将单链表的最后一个节点的next指针指向头节点，这样就构成了循环链表。这里说的循环链表主要用于解决约瑟夫环问题和判断链表是否有环两个算法问题。 环形链表节点 int val：存储数据 Node next：指向另外一个Node节点 单向循环链表成员变量 head：环形链表的头指针 helper：环形链表的尾指针，每次都指向新插入的节点(helper.next=head) 成员方法public void Add(int ele)向链表中添加元素 在添加之前，判断当前链表是否为空 如果为空 将head头指针指向新创建的节点==&gt;head=new Node(ele) helper指针也指向新创建的节点==&gt;helper=head 将新创建节点的next指针指向head，构成一个环==&gt;helper.next=head 如果不为空 将helper指针指向节点(尾节点)的next指针指向新节点==&gt;helper.next=new Node(ele) 将helper指针向后移，保证helper指针仍然指向尾节点==&gt;helper=helper.next 将尾节点的next指针指向head头节点，形成一个环==&gt;helper.next=head 环形链表，其实就是将单链表的尾节点的next指针指向头节点 public void show()打印环形链表逻辑比较简单，因为在打印的过程中指针会移动，所以可以创建两个临时变量，这样打印过后head和helper指针都没有发生变化，下次添加元素的时候仍然能够按照顺序添加 单链表的两个算法问题会在算法之美分类中说到]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>环形链表</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队列]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列的特点：FIFO–&gt;First in First out，即先进先出这篇文章讲的是数组结构存储队列，队列从功能上来说分为两种 普通队列 循环队列。 后面将会分别用Java手写两个队列类来讲述普通队列和循环队列 普通队列概述队列本身是一个有序列表，因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队头和队尾 front会随着数据输出而改变 rear会随着数据输入而改变 成员变量 private int maxSize; –&gt;队列最大容量 private int front; –&gt;队列头 private int rear; –&gt;队列尾 private T[] arr;(使用泛型) –&gt;队列存储结构：数组 构造方法这里创建了两个构造方法： 通过参数确定数组大小，即队列的容量 无参构造方法默认数组大小为10 front和rear指向的位置 front：指向队列头的前一个位置 rear：指向队列最后一个元素 成员方法public boolean isFull()对于非循环队列来说，判断队列是否已满很简单，只需要判断rear是否到达数组末尾即可 public boolean isEmpty()对于非循环队列来说，队列为空就是初始状态，即rear==front public void Add(T ele)对于添加元素的方法，有两个步骤 先判断队列是否已满 如果队满，抛出异常 否则，先将rear后移，再进行赋值操作 public T get()取队头元素的方法，同样有两个步骤 判断队列是否为空 如果队空，抛出异常 否则，先将front后移指向队头元素，再返回队头元素 public void show()打印当前队列所有元素 以上就是一个基本的普通数组模拟队列类，不难发现这样的队列是有很大缺陷的 无法复用：即只能用一次，当front指向arr[maxSize-1]的时候，就算此时队列中没有元素，也无法向队列中添加数据。下面来说循环队列 循环队列成员变量 private int maxSize; –&gt;队列最大容量 private int front; –&gt;队列头 private int rear; –&gt;队列尾 private T[] arr;(使用泛型) –&gt;队列存储结构：数组 构造方法这里创建了两个构造方法： 通过参数确定数组大小，即队列的容量 无参构造方法默认数组大小为10 front和rear指向的位置和普通队列不同 front：指向队列头元素 rear：指向队列尾元素的后一个位置 为了便于循环，rear指向的位置自始至终都是空着的，即队列的容量=maxsize-1 public boolean isFull()在循环队列中，判断队满的条件(rear+1)%maxSize==front public boolean isEmpty()在循环队列中，判断队满的条件仍是rear==front，因为rear指向的位置是不存放元素的，当front==rear时，说明队列已经没有元素了 public void Add(T ele)在循环队列中，当rear到达队列末尾时，我们需要它从0开始，因此不能+1，要用取模运算 public T get()在循环队列中，对于front也要用取模运算 public int getNum()对于(rear - front + mixsize) % mixsize运算，可以这么理解 当rear&gt;front时候，说明所有的元素都处于rear和front中间，num=rear-front 当rear&lt;front时候，说明所有元素都处在rear和front两边，即rear比front多走了一个mixsize的长度，num=rear+maxSize-front; 因此两者加起来就是(rear - front + mixsize) % mixsize public void show()特别注意循环条件，i从front开始，做带循环的后移(取模)，直到i==rear是遍历完所有元素]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--稀疏数组]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%C2%9E%2F</url>
    <content type="text"><![CDATA[这篇文章主要讲的是数组的应用之一–稀疏数组。那么什么是稀疏数组呢？我们来看一个问题：假设你做了一个五子棋游戏，玩儿过的都知道这个游戏有一个叫做复盘的功能，就是你可以将这句游戏先存档，之后再读档的时候就会接着之前的继续下。我们都知道 用二维数组来构造棋盘 用0表示棋盘上没有落子的位置 用1和2分别表示黑棋和白棋的位置 存档：把二维数组通过流保存到硬盘中那么这里面就有一个问题：如果要存档的棋盘中有大片的空白(数组中有大量的元素为0)，直接将原数组存储进去会浪费空间，这时候可以用到稀疏数组来压缩 稀疏数组的结构行 稀疏数组的行数取决于原数组非0元素的个数–&gt;row=num+1; 第一行存储着原数组的信息 [0][0]=原数组的行数 [0][1]=原数组列数 [0][2]=原数组非0元素的个数 剩下的每一行都存储着原数组非0元素的信息 [i][0]=元素所在行 [i][1]=元素所在列 [i][2]=元素的值 稀疏数组的行数row=num+1：稀疏数组的第一行要用来存储原数组的信息，在还原的时候会用到 列 所有的稀疏数组都只有3列 除了第一行外： 第一列存储非0元素的行位置 第二列存储非0元素的列位置 第三列存储非0元素的值 上面说的非0元素，只是在数组中存在的大量重复元素值为0时的情况 数组–&gt;稀疏数组假设存在一个数组 遍历原数组，获取非0元素的个数 创建稀疏数组 稀疏数组的行数row=num+1 稀疏数组的列数col=3 将原数组信息存储到稀疏数组第一行 稀疏数组的第一行，存储原数组的行数、列数以及非0元素个数 遍历原数组，储存其中非0元素的信息 每一行的第一列存储元素的行信息 每一行的第二列存储元素的列信息 每一行第三列存储元素的值 最后得到的稀疏数组 稀疏数组–&gt;数组 创建普通数组 数组的行数为稀疏数组第一行第一列的值 数组的列数为稀疏数组第一行第二列的值 遍历稀疏数组的每一行 当前行的第一列为元素的行位置 当前行的第二列为元素的列位置 当前行的第三列为元素的值 最后得到原数组 通过实际操作我们发现，将数组转换为稀疏数组后，节省的空间还较为客观，当要存储的数组中含有大量的重复元素时，我们可以采用稀疏数组来存储，能够在一定程度上节省空间]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--String类]]></title>
    <url>%2F2019%2F09%2F10%2FJDK%E6%BA%90%E7%A0%81-String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[这一篇的String源码基于JDK8版本，来自于慕课网上文贺老师的JAVA源码专栏(收费)结合张家界的雪以及自己学习String源码的总结，主要的目的在于总结知识，方便后续回顾查看，如转载，请注明出处 成员变量在学习String源码之前，首先要知道String对象再内存中的存放位置，我们都知道JAVA对象一般都是存放在堆中，但是String对象是一个特例，它被存放在常量池中可以看到，String类实现了 Serializable：序列化接口，String对象可以被序列化 Comparable：表明字符串可以比较 CharSequence：表明String对象是一个字符序列 String底层实现是一个char类型的数组并且被final修饰 构造方法public String()值为空串，很少使用 *public String(String original)这个构造方法在创建的过程中会创建两个对象，一个在堆中，一个在常量池中当调用这个构造方法时String str=new String(“abc”) 现在堆中new出一个String对象，并将str指向该对象 查看常量池中是否存在”abc” 如果不存在，那么就会在常量池中在创建一个String对象 如果存在，不做操作 最终str是指向堆中的对象，而不是常量池中的对象 str1和str3都是指向常量池中的”abc”对象，所以str1==str3返回true str4涉及到了变量的相加，内部实现是先new一个StringBuilder，然后 append(str2),append(“c”);然后让str4引用toString()返回的对象;如图，StringBuilder的toString方法实质上也是new了一个String对象，所以str4指向堆中的另外一个String对象，所以str1==str4返回false 上面说了，str5指向堆中的一个String对象，所以str1==str5返回falsepublic String(char value[])如图，该构造方法实质上是调用Arrays工具类的copyof方法public String(char value[], int offset, int count)如图，该构造方法会先对起始位置进行判断，如果不合法会抛出异常。最后调用Arrays工具类的copyOfRange来实现public String(byte bytes[], int offset, int length, String charsetName)如图，该构造方法用byte数组构造String对象，用指定字符集转换后构造String对象。其中StringCoding.decode(charsetName, bytes, offset, length)方法根据指定编码对byte数组进行解码，返回char数组checkBounds方法是对参数进行检查，该方法为私有，只能在String类中使用该构造方法如果不指定charsetName，那么按照系统默认字符集进行解码public String(StringBuffer buffer)通过StringBuffer构造String，因为StringBuffer内部也是一个char数组，所以实质上还是调用Arrays.copyOf方法实现，并且由于StringBuffer是线程安全的，所以这里也加了synchronized块保证线程安全通过StringBuilder构造String对象和StringBuffer原理相同。不过由于StringBuilder是线程不安全的，所以没有加synchronized块*String(char value[] boolean share)这个构造方法是protected修饰的，它和public String(char value[])的区别在于多了一个boolean参数，并且不支持false只支持true，这样做的原因是为了和public String(char value[])方法进行区分，否则没办法构成重载，查看方法体可以发现，它直接将char数组的的地址传递给String对象，要比注意拷贝快很多但是这样做的弊端很大：String对象和char数组共享同一块内存，破坏了String的不可变性，所以将该构造方法设置为protected保证安全,但是由于性能比较好，节约内存，所以replace、concat、valueof等方法也用到了这个构造方法 成员方法public int length()返回char数组的长度 public boolean isEmpty()char数组长度是否为0 public char charAt(int index) 判断index是否超出char数组长度，超出则抛异常 否则返回value[index]。 public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)将String对象指定的字符从dst[]数组的dstBegin位置向后复制,通过System.arraycopy实现，这是一个本地方法(native)。参数： srcBegin：复制的起始位置(包括) srcEnd：复制的结束位置(不包括) dst[]：目的数组 dstBegin：目的数组dstBegin起始 如果要复制的字符个数srcEnd-srcBegin&gt;dst.length-dstBegin,会抛出异常 public byte[] getBytes(String charsetName)和前面传递Byte数组的构造方法相反，这里将String对象的value数组按照指定字符集编码成字符数组并返回如果不指定字符集，按照默认字符集编码 public boolean equals(Object anObject)重写了Object的equals方法 public boolean equalsIgnoreCase(String anotherString)先判断地址是否相同，地址相同内容肯定相同，再判断长度是否相同，如果长度一样再调用regionMatches方法进行判断，这里用了&amp;&amp;运算符的断路原理regionMatches方法有两种形式 没有boolean参数的 有boolean参数的 该方法的作用是区域比较，比较两个字符串指定长度的内容是否相等，从指定位置开始逐一比较字符数组内容是否相等两方法的区别在于：如果booloean参数为true，那么当字符不相等时 先将两字符转换成大写字符比较，还不相等 将两字符转换成小写比较，还不相等返回false 和String的内部类实现原理一样 public int compareTo(String anotherString)这个方法是实现Comparable接口的方法，用于对字符串大小进行比较这个方法取了两个字符串长度较小的那个作为循环次数，对两个字符串进行逐位比较。 如果不同，就返回两字符串不同那一位字符的差 如果都相同，就返回两字符串的长度差 差的计算:调用方法的字符串-参数字符串 public int compareToIgnoreCase(String str)该方法实际上是调用了静态内部类对象的忽略大小写的compareTo方法 public boolean startsWith(String prefix, int toffset) public int hashCode()重写了Object的hashCode方法在JAVA中，hashCode有两个作用： Object的hashCode返回对象的内存地址 重写的hashCode配合基于散列的集合使用 在使用散列集合例如HashMap时，要保证key唯一，但是对于大量元素比较时直接比较equals效率低下，可以先判断hashCode，如果hashCode相等，然后判断equals，因为不同的对象其hashCode值可能相同，例如”通话”和”重地”、”Aa”和”BB” 为了使字符串计算的hashCode尽可能地少重复(降低哈希冲突)，这里采用的是31这个乘数，有两个好处 31是个不大不小的质数，是作为hashCode乘子的优秀质数之一 31可以被JVM优化，31*i=(i&lt;&lt;5)-i(暂时没弄明白JVM优化) public int indexOf(int ch, int fromIndex)作用：找到ch字符从字符串fromIndex位置开始第一次出现的位置方法中的判断条件ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT是什么意思呢？我们知道，在JAVA中，一个char类型字符占2个字节也就是16位 当参数中的ch在这个范围内时，就在String中从fromIndex开始逐一查找ch第一次上出现的位置 当参数超过这个范围(即大于65535)时，调用indexOfSupplementary()方法进行比较 通过查看Character源码可知这个数值就是65535 public int indexOfSupplementary(int ch, int fromIndex)这个方法是private修饰的，只能由String内部调用，用来处理当参数ch大于2个字节时的查找方法不难发现，它将ch字符拆分成高低位来查找，高位和value[i]比较，低位和value[i+1]比较lastIndexof逻辑和Indexof基本类似，不多说 public int indexOf(String str, int fromIndex)参数为字符串，实际上比较的时字符串里的char数组方法是保护的，只能在包内调用 首先分析一下方法的参数： char[] source：调用方法的字符串内部数组–&gt;暂且称为源数组 int sourceOffset：数组的起始位置(一般是0) int sourceCount：数组的长度 char[] target：参数字符串的内部数组–&gt;暂且称为目的数组 int targetOffset：数组的起始位置(一般是0) int targetCount：数组的长度 int fromIndex：从源数组fromIndex位置开始向后查找 前三个if条件判断 当fromIndex &gt;= sourceCount(即指定的起始搜索位置大于源数组数组的长度)时 判断目的数组是否为空串 若为空，则返回源数组的长度 不为空，返回-1 当指定起始搜索位置小于0，默认从0开始搜索 当目的数组为空，并且fromIndex在正常范围内，返回fromIndex 找源数组和目的数组第一个字符相同的位置记为i 逐一比较接来的字符是否相等，如果遍历完目的数组后仍相等，返回i，不相等进行5 从源数组第i个位置后找与目的数组第一个字符相等的位置，再比较接下来的每一个字符是否相等 一直循环查找直到找到i并返回，或源字符串遍历完毕返回-1对于几种特殊情况的测试public int indexOf(String str)默认fromIndex=0，调用上面的indexOf方法 public int lastIndexOf(String str, int fromIndex)逻辑和上面个一样，都是调用比较char数组的保护方法，需要时查看一下JDK8的源码 public String substring(int beginIndex) 对beginIndex进行判断 beginIndex&lt;0，抛出StringIndexOutOfBoundsException异常 大于源数组的长度，抛出StringIndexOutOfBoundsException异常 begin=0，直接返回当前字符串 调用String(char[] value,int beginIndex,int count(value.length-beginIndex))来实现 public String substring(int beginIndex, int endIndex)逻辑和上面一样(含头不含尾) public String concat(String str)拼接字符串，将str拼接到this串后面 如果参数串为空串，直接返回this(当前字符串) 调用Arrays.copyOf方法创建一个新的字符串buf，长度为this.length+str.length，内容为this.value 调用String类的getChars方法，将str复制到buf串中(从buf串的this.length位置开始) 调用String类的protected修饰的构造方法，直接将buf串的地址赋值给新创建的字符串对象–&gt;参考前面protected的构造方法 大致上来说，该方法的实现原理：先创建一个字符数组，复制了两个字符串中的内容，然后通过String(char value[] boolean share)方法来new一个新的字符串因为buf串是在方法内部创建的，外部是不可见的，因此不会破坏String对象的不可变性 public String replace(char oldChar, char newChar)将字符串中所有的oldChar替换为newChar 如果OldChar==newChar，直接返回当前字符串 找到字符串中第一个OldChar，记录位置为i； 新建一个char数组buf，将字符串赋值给buf数组，从buf的i开始，将所有的OldChar替换为newChar 通过String(char value[] boolean share)来创建新的字符串对象并返回 说一下为什么要重建一个val数组，用val数组给buf数组赋值，而不直接用value数组赋值呢？上网查阅，val数组是局部变量，value数组是类变量，getfield操作是一个访问类变量的操作当使用value数组循环赋值的时候，每一次循环都会有一个getfield操作入栈使用局部变量val时，只有一次getfield操作操作，就是将value数组赋值给val的时候当数组长度很大的时候，使用局部变量性能会更好一些(大神真不愧是大神，太细节了) public boolean contains(CharSequence s)判断字符串是否包含制定的字符序列，实际上是调用indexOf(String str)方法，查找序列在字符串中出现的位置来判断的，如果不包含返回-1。 public String toLowerCase()/toUpperCase()对字符串进行大小写转换，只对英文字符有效 public String trim()去掉两端空白字符(空格、tab、回车符) 从左到右循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置st 从右往左循环字符数组，若字符为空字符则继续循环，直到第一个不为空的字符记录位置len 如果st=0并且len=value.length，说明该字符两端没有空字符，直接返回字符串 否则，调用substring(st, len)方法获取去掉首尾空字符的字串。 通过分析：一个首尾没有空字符的str调用trim方法，返回它本身，所以得到的新String对象地址相同一个开头或结尾存在空字符的str调用trim方法，返回的新String对象是new出来的，两者地址不同 public String toString()返回他自身 public char[] toCharArray()创建一个resault数组，调用System.arraycopy方法将value复制给resault数组并返回不能直接返回value数组，破坏了String的不可变性源码中有一行注释：Cannot use Arrays.copyOf because of class initialization order issues，由于类初始化顺序问题，不能使用Arrays.copyOf方法可能的原因：String初始化比Arrays早，但是在JDK中存在其他对象使用了toCharArray()方法，而这个对象初始化比String晚但是比Arrays早，导致在使用时Arrays还没有初始化完成而报错而Syatem.arraycopy不会有这样的问题，因为这是本地方法 public static String valueOf系列方法直接查看JDK源码即可，很简单，就不赘述 public native String intern();本地方法，详细解释请见传送门，讲的挺好传送门1传送门2 静态内部类实际上就是String内部定义的一个比较器，用于忽略大小写比较字符串是否相等，CompareToIgnoreCase方法用到了这个类 到这里String类也大致总结完了，但是对于String类，我想要学的远不止这些，做这些只是整理方便后期学习理解，如果哪里不对或者有其他源码学习途径，欢迎私信我一起讨论交流，让我们一起学习，共同进步 暂时只能通过微博，后续会开微信公众号来一起交流，毕竟现在实力还不够]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--SQL语句总结(二)]]></title>
    <url>%2F2019%2F09%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[今天初步的做了一个web的小Demo，才发现数据库操作对于Web开发的重要性，频繁的对数据库进行操作，发现才学完数据库没多久，连基础的CRUD语句都写不出来，真是让人头大。突然想起来之前的SQL语句还有一半没有总结，现在趁着手机没电不能继续做Demo，就花30分钟左右的时间来总结一下剩下的DQL语句和DCL语句吧 DQL语法 select *from +表名 select字段列表 from表名列表 where条件列表 group by分组字段 having分组之后的条件 order by排序 limit分页限定 基础查询基于上面这个表进行演示 多个字段的查询 select 字段名1，字段名2… from 表名 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复：如果要单独查地址栏：SELECT address FROM student; 就会发现有多个香港地址但是在这种情况下我们并一般不希望出现这种情况 在select后面加distinct关键字就可以取出要查询的字段中重复的值格式：SELECT DISTINCT address(字段名) FROM 表名; 计算列 可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 表达式2：如果该字段为null后的替换值。 如图，计算英语成绩和数学成绩之和SELECT NAME,math,english,math+english FROM student;因为英语这一列存在null值，所以就会导致数学和英语的和也为null，这显然是不合理的使用ifnull，如果字段为null，就会在相加的时候替换为0；SELECT NAME,math,english,math+IFNULL(english,0) FROM student; 起别名： as：as也可以省略上面再计算列的时候，最后的列的值发生了变化，变成了(math+english)，顾名思义，其别名就是将列名换一个自己的名字SELECT NAME,math,english,math+IFNULL(english,0)AS 总分 FROM student; 条件查询 在where子句后面跟查询的条件 运算符 &lt; 、&gt;、&lt;= 、&gt;= 、= 、&lt;&gt;(不等于，相当于！=) BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! 实例演示 查询年龄大于20岁的：SELECT *FROM student WHERE age&gt;20; 查询年龄在20~30岁之间的(三种方法)SELECT *FROM student WHERE age BETWEEN 20 AND 30;/age&gt;=20&amp;&amp;age&lt;=30;/age&gt;=20 AND age&lt;=30; 查询年龄22岁，18岁，25岁的信息(查询满足指定条件的数据)SELECT *FROM student WHERE age IN(19,22,25);age=22 OR age=19 OR age=25;/age=22 || age=19 || age=25; 查询英语成绩为null–&gt;不能用=和！=来判断是否为null，要用is和is not来判断SELECT * FROM student WHERE english IS NULL; 查询姓马的有哪些 模糊查询–likeSELECT *FROM student WHERE NAME LIKE “马%”;因为用的%占位符，所以马后面不管有几个字符，都符合条件排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2… 排序方式： ASC：升序，默认的。 DESC：降序。 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 实例演示 按照数学成绩排名(默认升序排列)SELECT *FROM student ORDER BY math; 按照数学习成绩升序排名，如果数学成绩一样，就按照英语成绩升序排名。SELECT *FROM student ORDER BY math ASC,english ASC;聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 实例演示 某一列数据总行数(如果这一列有null值，那么为null的行不算)SELECT COUNT(english) FROM student;这时候还要用到ifnull计算行数的时候将null临时替换为0，SELECT COUNT(IFNULL(english,0)) FROM student;使用SELECT COUNT(*) FROM student;来计算行数，只要这一组数据中有一列数据全不为null，就能够正确的计算行数 计算数学成绩最大值(max)其余的min、sum以及avg用法和max一样分组查询 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 实例演示 按照性别分组。分别查询男、女同学的数学平均分,人数SELECT sex , AVG(math)(平均分),COUNT(id)(人数) FROM student GROUP BY sex(性别分组); 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex,AVG(math) ,COUNT(id) FROM student WHERE math&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2 ; 分页查询1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot; 通过上面的实例演示，结合DQL查询语句的语法不难发现，如果一次有多个查询条件，那么写的顺序一次是Where、Group By、Having、Order By、Limit的顺序 可以这么来理解： where先对数据进行筛选，不满足条件的不进行后面的分组，这是第一次条件 Having再对分完组后的数据进行筛选，不满足条件的数据不会被查询到，这是第二次条件 前面的都完成后，Order By再对查询到的数据进行排序，这是第三次条件 Limit再对排序后的数据进行分页展示，这是第四次条件 发现数据库这方面的知识要掌握的东西太多，多练习才能掌握，死记硬背是很难的，本来以为30分钟，最后俩小时还没搞定，后面大约还有整个基础部分的一半吧，下次再说吧]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会话技术--Cookie&Session]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-Cookie-Session%2F</url>
    <content type="text"><![CDATA[会话：一次会话中包含多次请求和响应。在一次会话中，浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止会话技术能够在一次会话的多次请求响应间共享数据 会话技术的实现方式 客户端会话技术：Cookie 服务器端会话技术：Session 客户端会话技术–CookieCookie使用步骤 创建Cookie对象，绑定数据:new Cookie(String name, String value) 发送Cookie对象::response.addCookie(Cookie cookie) 获取Cookie，拿到数据:Cookie[] request.getCookies() Cookie实现原理基于响应头set-cookie和请求头cookie实现 客户端和服务器第一次请求响应：服务器创建Cookie对象，并在set-cookie响应头将Cookie响应给浏览器 浏览器接收到服务器带有set-cookie头的响应后，将Cookie存储在浏览器中，当下一次浏览器向服务器发送请求时，会在请求头cookie头中附带这cookie 这样就实现了多次请求响应之间的数据共享 Cookie的细节 一次可以发送多个cookie：在服务器端创建多个Cookie对象，多次调用response的addCookie方法将多个Cookie对象发送，但是如果两个Cookie的值相同，那么后加入的Cookie值会覆盖前面的值 cookie在浏览器中保存时间 默认情况下，当浏览器关闭后，Cookie数据被销毁(服务器关闭，Cookie仍然存在，因为Cookie存储在浏览器中) 持久化存储：调用Cookie对象的setMaxAge(int seconds)方法实现 参数取值情况： 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值，即浏览器关闭后Cookie被销毁 零：删除cookie信息 cookie存储中文问题:在tomcat 8 之前 cookie中不能直接存储中文数据。但是在tomcat8之后，支持直接存储中文，但是对于一些特殊字符(如空格等)，仍不能直接存储，需要借助URL编码才行(具体步骤下一篇文章说到) cookie的共享 在一个tomcat服务器中部署了多个项目，在默认情况下，这些项目之间的Cookie是不能共享的但是可以通过Cookie对象的setPath(String path)方法来设置Cookie的共享范围 默认情况下，设置的是当前项目的虚拟目录 如果要在多个项目之间共享，则可以将path设置为"/"(“/”为服务器路径) 不同服务器之间Cookie的共享 setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 例如：设置path为".baidu.com"，那么tieba.baidu.com和news.baidu.com两个不同的服务器之间可以共享数据，因为它们的一级域名是.baidu.com Cookie的特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) Cookie存储的键值对都是String类型 作用 cookie一般用于存出少量的不太敏感的数据，这是因为Cookie的存储位置决定的，存储在客户端容易丢失和被篡改。 在不登录的情况下，完成服务器对客户端的身份识别 服务器端会话技术–SessionSession使用步骤 通过resquest获取Session对象：request.getSession() 调用Session对象的方法存储数据(和request请求转发方法一样) Object getAttribute(String name)：通过键获取值 void setAttribute(String name, Object value)：将数据存储进Session对象 void removeAttribute(String name)：通过键移除相应的键值对 Session实现原理Session的实现是依赖于Cookie的。 客户端第一次向服务器发送请求，服务器在服务器内部开辟一块内存空间，存放Session对象，并给该内存空间指定一个id 服务器在响应头set-cookie中设置JSESSIONID=id这个键值对发送给客户端 客户端接收到服务器的相应后，会将保存着Sessionid的Cookie对象保存在浏览器内存 当客户端下一次向服务器发送请求的时候，会带着Cookie一起(在请求头cookie中有JSESSIONID=id键值对) 服务器接收到请求后，得到JSESSIONID=id键值对的id后，会在内存中找到对应id的Session对象 这就是为什么说Session依赖于Cookie的原因以及多次请求响应之间共享数据的原理 Session细节 当客户端关闭后，服务器不关闭，两次获取session不是同一个：前面说到过，Session是依赖于Cookie的，Cookie在默认情况下当客户端浏览器关闭后是自动销毁的，因此Cookie中的键值对自然也就销毁了，所以两次获取的Session不是同一个，如果需要两次的Cookie是同一个 创建一个Cookie对象，设置cookie的键为JSESSIONID，值为session对象的id 设置cookie的存活时间 那么在cookie存活时间内，服务器通过cookie请求头拿到session的id都是一样的，这样通过id找到的Session对象自然也是同一个 客户端不关闭，服务器关闭后，两次获取的session不是同一个，因为服务器关闭后相应内存会被释放，Session自然也会被释放 但是一般我们需要获取到的Session对象是同一个，确保数据不丢失，tomcat会自动完成Session的钝化和活化 Session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上 Session的活化：在服务器启动后，将session文件转化为内存中的session对象。 Session被销毁 服务器关闭 session对象调用invalidate() 自杀 session默认失效时间 30分钟,可以tomcat服务器的web.xml配置文件中session-config设置所有项目的失效时间,也可以在项目的wen.xml配置文件单独配置项目的失效时间 Session的特点 用于一次会话的多次请求间共享数据，存储在服务器端 session可以存储任意类型，任意大小的数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>会话技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器中的四种路径]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在Web开发中，会很频繁的用到各种路径，路径又大致分为四种，分别是相对路径、绝对路径、虚拟路径、资源路径 # 相对路径 通过相对路径不能确定唯一资源 例如：./index.html ## 相对路径的使用规则 以"./"开头, 在使用时先确定当前资源和目标资源的之间的相对位置关系 如果两资源位于同一级目录：./+目标资源名称 ./可以不加，默认有./ 如果目标资源位于上一级目录：../+目标资源名称 如何确定当前资源和目标资源的关系 对于src目录下的资源，可以用request.getRequestURL()来得到该资源的位置src下的java资源的URI都是虚拟路径+资源名称无论该java文件位于src下的哪一级目录，只要在src目录里，都是这个形式。这里说的资源名称并不是实际的java类名，而是@WebServlet中的资源名称，服务器通过这个资源名称找到实际的类。 对于web目录下的资源，如果直接在web目录下，那么资源的URI就是虚拟路径+/文件名称如果在web目录下的其他目录，那么资源的URI就是虚拟路径+/目录名称+/文件名称，有几级目录写几级目录。 绝对路径通过绝对路径确定唯一资源例如：http://localhost/response/responseDemo2或者/response/responseDemo2协议名+ip地址+端口号+虚拟路径+文件资源 两种路径使用规则规则：判断要定义的路径是给谁用的，即判断请求将来从哪发出 给客户端浏览器使用 需要加虚拟目录(项目的访问路径,查看项目的xml配置文件) 例如：&lt;\a&gt;标签，&lt;\form&gt;，重定向等从浏览器发出，需要加虚拟路径 给服务器使用不需要加虚拟目录例如：请求转发就是服务器内部的资源跳转，不需要加虚拟路径，直接写资源名称就可以了 虚拟路径虚拟路径代表的是项目实际部署的位置，服务器通过虚拟路径能够映射到项目实际部署的位置通过查看项目的xml文件可以发现:&lt;\Context path=”虚拟路径” docBase=”资源在电脑上存储的位置” /&gt;这就是配置文件的内容，我们在浏览器输入的是Contextpath，也就是项目的虚拟路径，服务器就通过该虚拟目录映射到后面项目部署的真实目录 虚拟路径的好处 虚拟目录的名称通常要比物理目录的名称易记，因此更便于用户访问。 使用虚拟目录可以提高安全性，因为客户端并不知道文件在服务器上的实际物理位置，所以无法使用该信息来修改服务器中的目标文件。 使用虚拟目录可以更方便地移动网站中的目录，只需更改虚拟目录物理位置之间的映射，无需更改目录的URL。 使用虚拟目录可以发布多个目录下的内容，并可以单独控制每个虚拟目录的访问权限。 使用虚拟目录可以均衡Web服务器的负载，因为网站中资源来自于多个不同的服务器，从而避免单一服务器负载过重，响应缓慢。 资源路径资源路径也不是文件的真实路径，它和真是路径之间存在着映射关系，服务器可以通过资源路径找到文件link这篇文章提到了配置Servlet的方法，一种是通过web.xml来配置，通过这种方法很容易理解资源路径和文件路径的映射关系，服务器通过资源路径映射到实际文件，通过@WebServlet配置原理一样 我们在浏览器输入的是项目的URL是由协议名+ip地址+端口号+虚拟路径+文件资源组成，服务器会通过虚拟路径找到项目在电脑上部署的位置，通过文件资源路径找到文件在电脑上的实际位置]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ServletContext对象]]></title>
    <url>%2F2019%2F09%2F08%2FServletContext%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ServletContext对象，代表了整个web应用，可以和程序的容器(服务器)来通信 获取方式 通过request对象获取:request.getServletContext() 通过HttpServlet获取:this.getServletContext(); ServletContext对象的功能 获取MIME类型(文后将什么是MIME类型):String getMimeType(String file) 获取到数据的类型后，可以用于设置响应头content-type的值 获取方法：String getMimeType(String file)； 域对象：共享数据，前面说到，ServletContext代表了整个web应用，因此ServletContext对象中存放的数据整个web应用的资源都可以访问和修改 方法和request域对象的三个方法一样，只是两者的作用范围不同 动态的获取文件的真实(服务器)路径 方法：String getRealPath(String path) 文件直接位于web目录下时：context.getRealPath("/+文件名称"); 文件位于web目录下下的目录a中时：context.getRealPath("/a/+文件名称"); 文件直接位于src目录下时：context.getRealPath("/WEB-INF/classes+文件名称"); 以上可以通过查看tomcat项目的层次结构，以tomcat项目的web目录为基准 tomcat项目目录位于IDEA工作空间目录的\out\artifacts下 MIME类型MIME类型:在互联网通信过程中定义的一种文件数据类型MIME类型的格式：大类型/小类型&nbsp;&nbsp;&nbsp;&nbsp;例如：text/html、image/jpg getMimeType方法获取MIME类型的原理在web.xml配置文件中，tomcat定义了上千种MIME类型和文件后缀名的对应关系，而ServletContext又可以和服务器通信，所以ServletContext的getMimeType实际上是通过文件的后缀名来映射获取的文件的MIME类型。]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求转发和重定向]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[目前已经学习了两种资源跳转的方式：分别是request对象的请求转发和response的重定向，那么这两者各自有什么特点以及它们之间的区别是什么呢？ request请求转发一种在服务器内部的资源跳转方式举个例子：浏览器向服务器发出请求，服务器中的AServlet收到了请求，但是AServlet无法单独完成这个请求，如果要完成这个请求，还需要服务器内BServlet的参与，这时候就会用到请求转发，AServlet执行完自己能执行的部分后跳转到BServlet中继续执行，(这中间还涉及到了共享数据，文章后面会将) 请求转发的特点 浏览器地址栏路径不发生变化：就是说，浏览器请求访问AServlet，Aservlet执行完自己能执行的部分后跳转到BServlet，在这个过程中浏览器地址栏的路径还是AServlet的路径，并不会发生改变 只能转发到当前服务器内部资源中。 转发是一次请求：从上面的例子可以看出，整个转发的过程中，无论在服务器内部资源跳转多少次，浏览器只发出过一次请求，而服务请经过多次跳转处理完浏览器的请求后只会做出一次响应 共享数据上面说到了，AServlet和BServlet一起完成浏览器的请求，那么这两者之间必定是有数据交互的，因为AServlet要告诉BServlet自己做了哪些部分(修改了那些数据..)，并将这些部分共享给BServlet说共享数据之前，先说一个概念域对象：一个有作用范围的对象，可以在范围内共享数据request域：代表一次请求的范围，即在一个请求的范围内各个服务器资源可以共享数据。因为上面说到了请求转发这个过程是一次请求响应的过程，所以请求转发过程中的多个资源可以共享数据 存储数据，在当前资源中调用此方法(转发之前调用)void setAttribute(String name, Object o)参数：String name：给数据起一个名，在后面取出数据用到Object o：要共享的数据 在跳转后的资源调用此方法，可以达到共享数据的目的：Object getAttribute(String name) 参数：String name：存储数据时起的名 还有一个相关的方法：通过键来移除键值对void removeAttribute(String name) response重定向一种资源跳转的方式，不限于服务器内部，可以跳转到其他服务器资源(如跳转到百度) 重定向实现步骤 设置状态码为302(代表重定向) 设置响应头location：response.setHeader("location","目的资源的路径"); 以上是分步实现，其实一个方法就能够完成上述步骤 调用response的sendRedirect方法，方法中传递跳转资源的路径 response.sendRedirect("https://www.baidu.com"); 重定向的原理 浏览器向服务器发出请求，AServlet接收到了这个请求,AServlet表示无法处理服务器的这个请求，但AServlet却知道BServlet(可以是服务器内部的资源也可以是其他服务器的资源) 所以AServlet在在响应消息中干了两件事情 设置状态码为302，告诉服务器重定向 告诉浏览器BServlet的路径，(设置响应头location为BServlet的路径) 浏览器收到了AServlet的响应消息后，根据AServlet给出的location路径去访问BServlet 重定向的特点 地址栏发生变化：在资源跳转的过程中，浏览器地址栏会发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response输出中文乱码]]></title>
    <url>%2F2019%2F09%2F08%2Fresponse%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用response对象设置响应体时有两个步骤： 获取输出流(字节流或字符流) 使用输出流，将数据输出到客户端浏览器这时候如果传输的数据是中文，输出到浏览器就会乱码 乱码原因首先，要知道乱码的根本原因是什么，乱码的根本原因在于编码和解码使用的字符集不一样。那么在从服务器输出数据到客户端的过程中，有几次编码和解码过程？又分别是在哪里执行的？在输出数据的过程中，有一次编码，是tomcat执行的，它按照自己的字符集将数据编码后发送给客户端浏览器有一次解码，是浏览器执行的，浏览器将接收的数据按照自己的字符集解码后打印在屏幕上。而tomcat的默认编码是ISO-8859-1，浏览器的默认编码是操作系统的编码，也就是GBK，两者的编码格式不一样，就造成了中文乱码问题 解决方案解决方案不止一种，记录一种比较简单地使用response设置响应头的方法来设置 Content-Type 具体操作在获取输出流之前(一定是之前)设置响应头content-typeresponse.setHeader(“content-type”,”text/html;charset=utf-8”);这个方法不仅可以设置流的编码，还可以告诉浏览器发送数据的编码方式，并建议浏览器使用同样的字符集解码，这样就解决了乱码的问题由于只需要设置content-type这个响应头，所以有另一个方法更为简单response.setContentType(“text/html;charset=utf-8”);]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--request和response对象]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[首先要知道request对象和response对象是由服务器创建的，我们只是使用并不创建request对象是来获取请求消息，response对象是来设置响应消息 request对象request继承结构&nbsp;&nbsp;&nbsp;&nbsp;ServletRequest(接口)–&gt;HttpServletRequest(接口)–&gt;RequestFacade 类(tomcat实现) request功能获取请求消息数据 获取请求行数据:这是一个GET请求方式的请求行：GET /day14/demo1?name=zhangsan HTTP/1.1 获取请求方式 ：String getMethod() -->上例得到结果：GET 获取虚拟目录(常用)：String getContextPath() -->上例得到结果：/day14 获取Servlet路径: String getServletPath()-->上例得到结果：/demo1 获取get方式请求参数：String getQueryString()-->上例得到结果：name=zhangsan 获取请求URI(常用)(有两个方法) String getRequestURI()-->上例得到结果：/day14/demo1 StringBuffer getRequestURL()上例得到结果 :http://localhost/day14/demo1 获取协议及版本：String getProtocol()-->上例得到结果：HTTP/1.1 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据: 通过请求头的名称获取请求头的值(常用):String getHeader(String name) 获取所有的请求头名称:Enumeration getHeaderNames() 获取请求体数据:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 获取流对象 获取字符输入流，只能操作字符数据:BufferedReader getReader() 获取字节输入流，可以操作所有类型数据:ServletInputStream getInputStream() 其他功能因为对于不同的请求方式，它们的请求参数所在位置不同，GET方式请求参数在请求行中，POST方式请求参数封装在请求体中，所以服务器在获取请求参数的时候，需要分别在doGet和doPost方法中写不同的逻辑代码来获取请求参数，比较麻烦，因此就有一种通用的获取请求参数的方法 获取请求参数通用方式 根据参数名称获取参数值:String getParameter(String name) 根据参数名称获取参数值的数组(多选框):String[] getParameterValues(String name) 获取所有请求的参数名称:Enumeration getParameterNames() 获取所有参数的map集合:Map' 请求转发:一种在服务器内部的资源跳转方式 通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发:forward(ServletRequest re, ServletResponse res) 注意:path是要跳转的资源的路径， 获取ServletContext(后面博客会详细讲到): ServletContext getServletContext() request的请求转发和资源共享以及response的重定向，它们各自的特点和区别会新开一篇博客 response对象response功能:设置响应消息 设置响应行(设置状态码):setStatus(int sc) 设置响应头:setHeader(String name, String value) 设置响应体: 使用步骤 获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议概述--请求响应模型]]></title>
    <url>%2F2019%2F09%2F08%2FHttp%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Http–Hyper Text Transfer Protocol 超文本传输协议传输协议：定义了客户端和服务器端通信时，发送数据的格式 # Http协议的特点 基于TCP/IP的高级协议,默认端口是80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 Http协议的历史版本 1.0版本每次请求响应之后都会断开连接，下一次请求响应又会建立新的连接，即每次请求响应都会建立新的连接缺点：连接会被多次建立和多次丢弃掉，影响传输速度，消耗资源 1.1版本在一次请求响应之后，连接不会立刻断开，而是会等待一定的时间，如果在这一定时间内，还有其他请求，就会默认使用该连接，而不去建立新的连接，这样就实现了连接的复用 上面说了，Http定义了客户端和服务器通信时传输数据的格式，而传输数据分为两种： 客户端向服务器传输数据：请求消息数据 服务器向客户端传输数据：相应消息数据 Http请求消息数据格式 请求行:请求方式 请求url 请求协议/版本例如：GET /login.html HTTP/1.1请求url=虚拟路径+Servlet资源路径 请求头：客户端浏览器告诉服务器一些信息请求头消息以键值对的方式给出：请求头名称：请求头值常见的请求头： User-Agent：浏览器告诉服务器，使用的浏览器版本信息,可以在服务器端获取该头的信息，解决浏览器的兼容性问题(可以在服务器端对不同的服务器写不同的逻辑代码，然后根据该头的内容获取浏览器名称，执行对应浏览器的代码) Referer：告诉服务器，当前请求从哪里来？可以用来防盗链和统计工作 请求空行：一个空行，用于分割请求头和请求体 请求体(正文)：封装POST请求消息的请求参数 对于请求行中的请求方式，http协议7中请求方式，常用的有2种 GET:请求参数在请求行中，跟在url后。 请求的url长度有限制的 不太安全 POST: 请求参数在请求体中 请求的url长度没有限制的 相对安全 Http响应消息数据格式 响应行:协议/版本 响应状态码 状态码描述例如：HTTP/1.1 200 OK请求url=虚拟路径+Servlet资源路径 响应头：服务器告诉浏览器一些信息响应头消息以键值对的方式给出：响应头名称：响应头值常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据常见有两种取值 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体，用于文件下载 注意：这个filename是浏览器在弹出框显示，和服务器中要下载的文件名无关 响应空行：一个空行，用于分割响应头和响应体 响应体(正文)：传输的数据 响应状态码服务器告诉客户端浏览器本次请求和响应的一个状态。状态码都是3位数字 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：本次请求响应成功。代表码：200 4xx：客户端错误。 404:请求路径没有对应的资源-->路径错误 405:请求方式没有对应的doxxx方法-->比如浏览器请求方式是Post方式，而客户端没有doPost方法 5xx：服务器端错误。代表码：500(服务器内部出现异常)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FServlet%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Servlet：server applet官方给出的解释是运行在服务器端的小程序 # Servlet的本质 浏览器通过ip和端口来找到服务器，服务器中的资源分为两类 静态资源， 动态资源所谓动态资源，就是不同的用户访问到的页面是不一样的，这说明动态资源中肯定有一些逻辑性，来实现不同的用户访问同样的资源看到的是不一样的。而这些逻辑性，就要通过Java代码(Java类)来实现。 也就是说浏览器请求动态资源的时候，访问的就是服务器上的Java类 要注意的是：这里说的Java类没有main方法，不能自己运行，需要依赖服务器才能运行，相当于Tomcat(服务器软件)来执行它。那么问题来了，如果要Tomcat能够认识这个类并执行这个类，这个类就需要遵守一定的规则，在Java中，规则==接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说的规则，就是Servlet，它本质上就是一个接口，定义了Java类被tomcat识别的规则 Servlet的使用 创建JavaEE项目 在src目录内定义一个类，实现Servlet接口 实现接口中的抽象方法 配置Servlet(一共有两种方法，这里先记录第一种)在web.xml中配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;全类名(包名+类名)&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1(Servlet资源路径)&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在web.xml中加上以上内容 Servlet配置原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的url-pattern标签体内容。 如果有，则通过映射找到对应的servlet-class全类名 tomcat会将字节码文件加载进内存，并且创建其对象注意：这个实现了Servlet接口的类是由Tomcat通过反射创建的对象，并不是由程序员创建的 调用对象的方法 Servlet的生命周期 被创建：执行init()方法，该方法只执行一次 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么Servlet在什么时候被创建呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，在资源第一次被访问时，Servlet被创建 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在web.xml文件中配置改变Servlet被创建的时机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面说到的servlet标签下配置，具体下面有图 提供服务：执行service方法，可以执行多次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有服务器正常关闭时，才会执行destroy方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy方法在Servlet被销毁之前执行，一般用于释放资源 设置Servlet被创建的时机使用load-on-startup标签，这是一个围堵标签，当标签的值为负数的时候，默认第一次被访问时创建当标签的值为正数或0的时候，服务器启动时创建 注解配置Servlet在Servlet3.0以后，可以使用注解配置Servlet，相比较在web.xml文件中配置更加方便使用方法：在类上加注解@WebServlet(“资源路径”)，这样就可以通过注解的资源路径找到相应的类，直接将类加载进内存 Servlet体系结构 Servlet是一个接口，里面有5个抽象方法，每次继承Servlet接口的时候，都需要重写这5个抽象方法，而实际上，很多时候并用不到其中的有些方法，所以每次都要重写，很麻烦 Servlet的子类GenericServletGenericServlet也是一个抽象类，将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象，将来定义Servlet类时，可以继承GenericServlet，只实现service()方法即可(但实际上，这种方法使用较少) HttpServletHttpServlet出现原因HttpServlet extends GenericServlet该类是对Http协议的一种封装和描述对于一般的Servlet实现类，在service方法中通过一些操作获取浏览器的数据，但在获取数据之前，需要判断浏览器的请求方式是get方式还是put方式，因为两种方式封装数据的位置和格式是不一样的，对于不同的方式需要进行不同的逻辑处理。也就是说，我们需要在service方法里作两步操作： 判断浏览器请求方式 根据不同的请求方式编写不同的逻辑代码 HttpServlet实现原理这个过程比较麻烦，但却是所有的service方法都必须要做的一个过程，因此sun公司就提供了HttpServlet这个类。在HttpServlet类的Service方法中，已经写好了判断浏览器请求方式的逻辑代码，我们需要做的就是重写相应doxxx()方法，service方法判断请求方式后，会根据判断的结果调用我们重写的doxxx()方法以上是HttpServlet类service的源码，可以发现，HttpServlet中的service方法主要用于判断浏览器的请求方式，然后根据不同的请求方式调用相应的doxxx()方法，我们只需要重写这些方法，省略了判断请求方式的步骤]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Servlet类</tag>
        <tag>HttpServlet类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--SQL语句总结(一)]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这里主要总结两类SQL语句 DDL和DML，即操作数据库和表的语句以及对表中数据进行增删改操作的语句 DDL语句这类语句又分为两部分 操作数据库(CRUD) 操作表(CRUD) 操作数据库 (Create)创建： 1. 创建数据库：create database 数据库名称; 2. 先判断数据库是否存在，如果不存在，再创建：create database if not exists 数据库名称; 3. 创建数据库，并指定字符集：create database 数据库名称 character set 字符集名; 4. 创建db4数据库，判断是否存在，并指定字符集为gbk：create database if not exists db4 character set gbk; (Retrieve)查询： 1. 查询所有数据库名称：show databases; 2. 查询某个数据库的字符集:show create database 数据库名称; (Update)修改： 修改数据库的字符集:alter database 数据库名称 character set 字符集名称; (Delete)删除： 1. 删除数据库:drop database 数据库名称; 2. 判断数据库存在，存在再删除:drop database if exists 数据库名称; 使用数据库： 1. 查询当前正在使用的数据库名称:select database(); 2. 使用数据库:use 数据库名称; 操作表 (Create)创建： 1. 创建表：create table 表名( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名1 数据类型1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名2 数据类型2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列名n 数据类型n); 注意：最后一列不加逗号 2. 复制表：create table 表名 like 被复制的表名; 数据库数据类型 int：整数类型 double:小数类型 date:日期，只包含年月日，形如yyyy-MM-dd datetime:日期，包含年月日时分秒, yyyy-MM-dd HH:mm:ss timestamp:时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串，在使用的时候需要指定长度，例如varchar(2)表示最大长度2个字符 (Retrieve)查询： 1. 查询某个数据库中所有的表名称:show tables; 2. 查询表结构:desc 表名; (Update)修改： 1. 修改表名:alter table 表名 rename to 新的表名; 2. alter table 表名 character set 字符集名称:alter table 表名 character set 字符集名称; 3. 添加一列:alter table 表名 add 列名 数据类型; 4. 修改列名称 类型:alter table 表名 modify 列名 新数据类型; (Delete)删除： 1. 判断数据库存在，存在再删除:drop table if exists 表名 ; 从上面这些语句不难总结得出，无论是数据库还是表，它们的增删改语句都和create、alter、drop、show有关 DML语句增删改表中的语句 添加数据insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n);列名和值要一一对应如果不指定列名，则默认给所有列添加值：insert into 表名 values(值1,值2,…值n);除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据delete from 表名 [where 条件]如果不加条件，则默认删除表中所有数据但是，如果要删除表中所有的话，不推荐使用这种方法，因为效率低推荐使用TRUNCATE TABLE 表名; 效率更高 先删除表，然后再创建一张一样的表。 修改数据update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件];注意：如果不加条件，则会将表中的记录全部修改 总结：DML语句用来操作表中的数据，主要对数据进行增删改操作，主要有insert 、delete、update三个关键字]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础--数据库概念和SQL简介]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%92%8CSQL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[数据库(DataBase)，简称DB，用于存储和管理数据的仓库能够持久化存储数据，实际上，数据库就是一个文件系统，能够方便的存储和管理数据，使用了统一的方式来操作数据库，即SQL MySQL的配置MySQL服务启动 cmd--> services.msc 打开服务的窗口 使用管理员方式打开cmd net start mysql : 启动mysql的服务 net start mysql :关闭mysql的服务 MySQL登录 mysql -uroot -p密码 mysql -hip -uroot -p连接目标的密码 mysql –host=ip –user=root –password=连接目标的密码 MySQL退出 exit/quit命令 SQLStructured Query Language：结构化查询语言定义了操作所有关系型数据库的规则，但是不同的数据库操作的方式可能存在不同的地方，可以理解为‘方言’SQL分为四类 DL(Data Definition Language)数据定义语言用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 一张图来帮助理解四类SQL语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中创建多个Project]]></title>
    <url>%2F2019%2F09%2F08%2FIDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProject%2F</url>
    <content type="text"><![CDATA[我们知道，IDEA是没有workspace这个概念的，它是以Project为单位，一个窗口对应着一个Project，而一个Project对应着很多Model，Model相当于eclipse中的project，那么如何在一个项目中存放多个Project呢？ 首先，创建一个空的Project 给项目命名并点击finish会进入到新创建的Project窗口中，接着IDEA就会弹出下面界面，让你为新的Priject创建一个Model：在这里很重要，不选择给新的Project创建一个Model，直接点OK这样，常见出来的没有Model的Project就相当于一个空文件夹，(查看创建的Project文件夹，会发现它是没有src的) 在新的Projrect中，new一个Model我这里创建的时web项目，如果要创建普通的项目，点击左侧第一个按钮JAVA就可以给新创建的Model起名，通过这里就可以发现，第一个untitled是创建的project名(由于没有命名，默认就是untitled)，第二个是正在创建的Model名，点击finish这样就创建成功了一个，按照上面的方法再来一遍这样就成功地在一个窗口创建了两个Project 另外IDEA会为这两个web项目分别部署一份配置文件，这样这两个web项目就可以分别设置不同的端口，虚拟路径等配置运行项目的时候，查看控制台的log：Using CATALINA_BASE: 的值，就能找到配置文件的路径]]></content>
      <categories>
        <category>Utils</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat部署项目的方式]]></title>
    <url>%2F2019%2F09%2F08%2FTomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Tomcat有三种部署项目的方式将项目直接放到Tomcat的webapps目录下也可以将项目打包成war包，放到webapps目录下，运行时Tomcat会自动解压 利用Tomcat的配置文件sever.xm打开conf目录，找到sever.xml配置文件(先关闭Tomcat服务) 找到Host标签，加上一个Context标签，path值可以自己设置 启动Tomcat服务 在浏览器输入localhost:8080(端口号)/path的值/docBase的值就能正确访问项目 这种部署方式项目可以放在硬盘上的任意位置，Tomcat会通过path映射到docBase。 注意：因为server.xml是Tomcat服务核心的配置文件，是配置Tomcat整体的，在里面配置项目有可能损坏配置文件，导致出错，比较危险，所以一般不推荐使用 自定义xml配置文件(先**关闭Tomcat**) 打开Tomcat下的conf\Catalina\localhost这个目录，在localhost下创建一个xml配置文件， 文件名可以任意起(但是这个文件名就是浏览器搜索时的虚拟路径)，假设是aaa.xml； 在配置文件中：将上图中红框里的Context标签及内容写进去，把后面的path键值对删掉(因为虚拟路径已经指定为xml文件名，所以不需要再指定虚拟路径) 再次启动Tomcat 浏览器搜索**localhost:8080(端口号)/xml文件名/docBase的值**即可这种部署方式还有一个好处： 这是一种热部署的方式，如果不想要这个项目，可以将创建的xml文件删掉，或者后缀名改一下 例如：将aaa.xml改为aaa.xml_bak；无需重新启动Tomcat就能生效(浏览器就访问不到项目资源)]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动问题分析]]></title>
    <url>%2F2019%2F09%2F08%2Ftomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[问题前提在Tomcat目录下的bin目录中双击startup.bat直接打开tomcat时，可能会出现以下两个问题 Tomcat的窗口一闪而过 启动报错 Tomcat的窗口一闪而过原因没有正确配置JAVA_HOME环境变量在安装JDK时，需要将JDK的目录配置到Path变量下，问题就在这里，因为配置的时候，有可能是直接将JDK的目录配置到了Path环境变量双击Path变量，如下图所示这样的做法是错误的 正确的做法应该先创建一个JAVA_HOME环境变量将JAVA_HOME的值设置问JDK的路径，如下图然后再将JAVA_HOME代替JDK安装路径给Path变量将startup.bat关掉，重新启动即可 分析一下原因先以文档的形式打开startup.bat，发现和catolina.bat有关，我们就以文档形式打开bin目录下的catolina.bat在文档里可以看到，这里用到了环境变量的JAVA_HOME，所以在配置环境变量的时候，必须用JAVA_HOME来设置JDK路径，否则这里就无法找到JDK，由于Tomcat是纯java编写的，它的启动和运行要依赖与JDK，所以Tomcat就无法正常运行 启动报错，然后窗口自动关闭原因有可能是已经打开了一个Tomcat(或者有其他程序占用了Tomcat的端口号)，再次启动的时候由于端口被占用，所以无法正常启动如果是这种情况，通过查看日志会发现有一个异常：java.net.BindException:Address already in use 解决方法找到占用Tomcat端口号(一般是8080)的程序，关闭该程序1、打开cmd窗口，输入 netstat -ano命令找到Tomcat端口(我的是默认8080)，记录该端口程序的PID2、打开任务管理器找到刚记录的PID对应的程序，把它关掉。这样，Tomcat就能正确启动了]]></content>
      <categories>
        <category>JAVAWEB</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>问题分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM模型基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FBOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[BOM，全称Browser Object Model，浏览器对象模型它将浏览器的各个组成部分封装成对象 五个对象window-窗口对象Location-地址栏对象History-历史记录对象Screen-显示器屏幕对象Navigator-浏览器对象 window-窗口对象该对象无需创建，可以直接使用对象的方法和属性 window对象的方法与弹出框有关的方法alert()显示带有一段消息和一个确认按钮的警告框。 confirm()显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法close()关闭浏览器窗口。 谁调用我 ，我关谁 open()打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式setTimeout()在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器clearTimeout()取消由 setTimeout() 方法设置的 timeout。setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()取消由 setInterval() 设置的 timeout。window对象的属性获取其他BOM对象historylocationNavigatorScreen获取DOM对象document Location-地址栏对象创建(获取)1. window.location 2. location方法reload() 重新加载当前文档。刷新 属性href 设置或返回完整的 URL。如图，给按钮设置监听器，点击按钮后修改页面的URL为百度页面，就会自动跳转到百度的页面 History-历史记录对象创建(获取)1. window.history 2. history方法back()加载 history 列表中的前一个 URL。 forward()加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性length返回当前窗口历史列表中的 URL 数量。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>BOM</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F09%2F08%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS和HTML结合方式内部样式在html文件内部定义一个script标签、在标签里面写的JS代码注意：和CSS不同的是，JS标签可以有很多个，而且可以写在HTML文件中的任意位置 外部样式在html文件内部定义一个script标签，通过script的src属性，来指定JS配置文件的路径 JS代码写在JS配置文件中 数据类型和变量JS数据类型和JAVA类似，分为**原始数据类型**和**引用数据类型**两大类数据类型number包括整数、小数和NaN类型(不是数字的数字类型 not a numebr) string字符/字符串类型 booleantrue/false、 null一个对象为空的占位符 undefined未定义，如果一个表量没有给初始化值，就会被默认赋值为 undefined ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828110402952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)变量一小块存储数据的内存空间 JAVA是强类型语言，而JavaScript是弱类型语言强类型在开辟内存空间时，定义了空间将来存储数据的类型，只能存储固定的类型 弱类型在开辟内存空间时，没有定义空间将来存储数据的类型，可以存放任意类型的数据 运算符在JS中，如果运算数不是运算符要求的类型，那么JS会自动将运算数进行类型转换 例如：一元运算符+(正号)和-(负号)是对数字类型进行操作，但是有+&apos;a&apos;这样的运算，就会将字符串类型的&apos;a&apos;转换为number类型其他类型转numberstring--&gt;number：**按照字面值转换**，如果字面值是数字，如&apos;123&apos;，会转换成数字123， 如果字面值不是数字，如&apos;abc&apos;，会转换为NaN(不是数字的数字)注意：NaN和整数小数运算，还是NaN; boolean–&gt;number: true=1 false=0 比较运算符字符串按照字典顺序比较(如c&gt;b),按位逐一比较，直到得出大小 **类型不同比较，先进行类型转换** ”===“运算符：在比较之前先进行类型判断，如果类型不同，直接返回false逻辑运算符！：非运算其他类型转boolean number--&gt;boolean：0和NaN为false，其他都是true string--&gt;boolean：除了空字符串，都是true null/undefined--&gt;boolean：false 对象--&gt;boolean：true 注意：在JS中，所有的**变量都是关键字var**定义的，var可以省略，但是，**用var定义的是局部变量**，不用var定义的 是全局变量常用对象function对象 方法对象 Array对象数组对象 数组长度可变 Date对象 Math对象该对象不用创建，可以直接使用对象的方法和属性，Math.调用 常用方法和属性： Global对象 特点：是一个全局对象，这个对象中封装的方法不需要对象就能够直接使用,和Math不同的是，使用它的方法前面不 用加对象名 在说该对象的方法之前先说一下**URL编码**： 浏览器将从表单中收集的数据经过URL编码后发送给服务器，服务器再将接收到的URL编码的数据解码。 URL编码的规则：对于汉字，先将汉字按照GBK/UTF8编码成对应的二进制数字，再将每四位二进制数字组合在 一起转换成十六进制数字，这样就将汉字转换成了一串十六进制数字，最后，每两个十六进制数字一组，在前面 +%，这样就组成了URL编码，字母和数字不编码第二组方法编码的字符更多，会将网址中./等符号也用URL编码]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器和常用属性]]></title>
    <url>%2F2019%2F09%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基础选择器id选择器使用此选择器要求HTML相应的标签必须指定了id属性 格式： #+标签id属性{ //对应id标签的属性 如color等}通过HTML标签的id来指定标签，修改样式 元素选择器格式：标签名称{ //通过标签名称找到标签(可能不止一个)并修改内容样式 }这个元素选择器会找到HTML中所有的div标签，并将标签内容字体改为红色 类选择器 格式： .+类名{ 通过标签的class属性值找到标签 }其中：三个选择器中 id选择器优先级最高，元素选择器优先级最低 扩展选择器![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828103900651.png) CSS常见属性 盒子模型 参见JAVA_WEB/HTML&amp;CSS]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础回顾]]></title>
    <url>%2F2019%2F09%2F08%2FHTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[HTML用于搭建基础页面，展示页面内容，一般和CSS以及JS搭配使用HTML标签分类# 1、围堵标签 顾名思义，就是开始和结束标签，例如&lt; html&gt; &lt; /html&gt;，内容放在标签中 # 2、自闭合标签 开始标签和结束标签在一起。例如换行标签&lt; br/&gt;、超链接标签&lt; a&gt;等 标签不区分大小写，建议小写无论是哪种标签，都可以在开始标签中定义属性，属性是由键值对组成，其中值需要由引(单/双)号引起来 &lt; html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt; /html&gt;文件标签&lt; html&gt;文档的根标签 &lt; head&gt;头标签，用于指定html文档的一些属性，引入外部资源，如CSS、JS文件等 &lt; title&gt; 标题标签 &lt; body&gt; 体标签，html代码写在body标签中 以上均为围堵标签 文本标签&lt; h1&gt;~&lt; h6&gt;标题标签，从h1到h6字体大小递减 –&gt;围堵标签 &lt; p&gt;段落标签：被该标签包裹的文本会换行两次 –&gt;围堵标签 &lt; br&gt;换行标签 &lt; hr&gt;展示一条水平线 该标签有一些属性：color、width、height、align(对齐方式)来设置水平线的样式 &lt; b&gt;字体加粗标签 &lt; i&gt;字体斜体标签以上四个均为自闭合标签 &lt; font&gt;字体标签 该标签属性：color、size、face(字体)来改变字体 center：文本居中标签 图片标签&lt; img&gt;图片标签，是一个自闭合标签，其中有src属性，可以指定展示图片的路径 相对路径： 其中如果html文件和图片所在文件夹目录是同一级目录，那么./+图片所在文件夹目录/图片 如果图片所在文件夹目录是html文件上一级目录，那么就用../ 列表标签&lt; ol&gt;/&lt; li&gt;有序列表 type属性：指定序号的样式 &lt; ul&gt;/&lt; li&gt;无序列表无序列表的type属性有三种： disc：原点 square：正方形点 circle：圆圈 链接标签&lt; a&gt;定义一个超链接 属性： href 指定访问资源的URL()统一资源定位符)，可以是网址 target 指定打开资源的方式，有两种方式 _ selt:在当前页面打开 _ blank：在新空白页面打开 和CSS以及JS搭配的标签 div标签和span标签，两者的区别是div自带换行，而span没有换行功能 表格标签&lt; table&gt; 定义表格，table的开始标签可以指定一些属性 width：表格宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt; tr&gt;标签定义行标签 &lt; td&gt;标签定义单元格标签 &lt; th&gt;标签定义表头单元格标签 表单标签注意：表单中的数据要想被提交，必须指定其name属性 表单：用于采集用户输入的数据，用于和服务器进行交互 &lt; form&gt;用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围form标签有以下属性 action：指定提交数据的URL路径 method：指定提交方式，有两种比较常用，分别是post和get form只是制定了收集用户数据的范围，并没有指定提交形式(输入框、按钮、下拉列表…)因此就会用到表单项标签表单项标签主要有三种：input标签、select标签、textarea标签 &lt; input&gt;标签展示效果 &lt; select&gt;标签子元素：option，指定列表项展示效果 文本域标签主要有两个属性：cols：指定列数，每一行有多少个字符rows：默认多少行。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--Byte类]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[学习过程中参考此篇文章，写的很好 1、观察它继承的父类，实现了那些接口 2、找到它的成员变量 3、学习构造方法 4、学习方法 一、父类和接口从图中可以知道，Byte类继承了Number类，实现了Comparable接口 对于Comparable接口，只有一个抽象方法这个接口赋予它和它的子类比较的能力，用于排序，比较大小对于一个存储自定义类的数组或集合，只有这个类实现了该接口，重写了接口中的compareTo()方法，重写了排序规则才能使用Arrays类的sort方法进行排序； 二、成员变量定义了Byte类型数据的边界值，就是说，Byte类型的值只能在-128~127之间TYPE是一个Byte的Class类对象，相当于TYPE=Byte.class；这就是Byte类型的基础类型，数据存储的地方(从下面的构造方法可以看出)这三个成员变量分别表示Byte数据的位数，字节数和UID(用于序列化和反序列化) 三、构造方法Byte的构造方法有两个，可以看出，两个构造方法都会将传入的数据存放到成员变量byte中 四、私有静态内部类![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171705760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70) 这是Byte类的一个静态内部类，类里面还有一个静态代码块 静态代码块会在类第一次被加载的时候执行，并且只执行一次 这里的作用就是，创建一个Byte类型的数组，数组的长度是256 里面存储着-128~127的数字(Byte类数据所有可能的取值) 并且数组是静态的并且final修饰， 因为后面的有些成员方法会需要用到Byte对象，所以这样做就避免了重复创建对象和回收对象五、成员方法1、toString(byte b)方法![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171318100.png) 注意：这个toString()方法不是重写Object的toString方法，因为它有参数 作用：将一个byte类型数据转化为String字符串类型 实质上是直接调用Integer类的toString方法， radix：10：用10进制表示2、valueOf(byte b)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172235507.png) 作用：将基本类型--&gt;包装类型，直接从上面的数组中得到3、parseByte(String s,int radix) 参数： String s:要解析的字符串 int radix:指定字符串表示的进制 例如：s=“10000”，radix=2，解析出来的值就是16 作用： 将字符串按照指定进制解析为byte类型 实质上调用的是Integer的parseInt方法，解析成int类型 判断是否超出范围，超出范围就抛异常，否则就返回 4、parseByte(String s)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172742458.png) 不指定进制默认十进制解析5、valueOf(String s,int radix) 参数： String s:要转换的字符串 int radix：字符串表示的进制，和解析方法一样作用： 将字符串转换为按照指定进制形式表示的Byte类型，先将字符串解析为byte类型，在调用valueOf()方法，从静态代码块初始的数组中找到对应的Byte并返回 6、valueOf(String s)默认10进制7、xxxValue()方法重写父类的方法，由于byte数值最小，不用担心出现溢出 直接用强制类型转换，然后return8、hashCode()重写了父类的hashCode方法，对于Byte类型，它的hashCode方法实质上就是返回它的值 9、equals()方法 重写了父类的equals方法 10、compareTo()方法 重写了接口中的compareTo方法，直接返回两个对象的差值 调用方法的对象-方法的参数]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>Byte</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC70%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度： 简单 1、动态规划可以知道，如果要到达第n阶台阶，有两种方式：第一：从n-1阶台阶跨1步第二：从n-2阶台阶跨2步设到达第n阶台阶的方法总数为sum(n)那么由上面可以知道：sum(n)=sum(n-2)+sum(n-1) 可以举例假设一下假设n等于3，那么到达第3阶台阶由两种方法1、从第1阶台阶跨2步上去2、从第2阶跨1步上去 相应的，到达第1阶台阶只有一种方法，sum(1)=1；到达第2阶台阶也有两种方法：从起始位置跨2步，和先跨1步再跨1步，sum(2)=2；所以sum(3)=3; 2、斐波那契数列通过观察规律可以知道：假设第0阶为1；那么可以得到从第1阶往后分别是：1，2，3，5，8，13…..这是一个很明显的斐波那契数列 3、递归同样的思路，爬第n阶台阶的方法和等于爬上第n-1阶台阶和爬上第n-2阶台阶方法之和递归出口：n=0的时候返回1，n&lt;0的时候返回0；运行到44个样例的时候栈爆了…..]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树镜像对称]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC101%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度–简单题目 分析： 通过题目可以知道，这个树镜像对称，那么这棵树关于根节点这条线对称 就是说，将它所有的左子树变成右子树，所有右子树变成左子树，它是不变的 递归//这里直接传递tree根节点的左右子树会比pre(TreeNode tree,TreeNode tree)好，因为减少一层递归，LeetCode速度直接 //快1ms，亲测 1、pre(TreeNode tree.left,TreeNode tree.right) 2、如果A.val==B.val --&gt;return true 3、如果A==null&amp;&amp;B==null --&gt;return true 4、如果A和B不同时为空，说明树是不对称的 --&gt;return false 5、遍历A的左子树和B的右子树 //pre(A.left,B.right) 6、遍历A的右子树和A的左子树 //pre(A.right,B.left)迭代法使用队列，比较容易理解，直接上代码(LeetCode官方题解)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流和字节流]]></title>
    <url>%2F2019%2F09%2F07%2FJAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[深入理解字符流编码 首先要理解字符流输入的原理：字符流输入其实底层也是字节流输入 字符–&gt;计算机二进制数字（字节）：编码字节(计算机二进制数字)–&gt;字符：解码 写入时：1、当使用字符流的write方法向文件写入数据的时候，数据会先写进内存缓冲区中， 2、内存缓冲区会先字符对比着系统码表编码(中文系统是GBK)为对应的字节：字符--&gt;数字 3、调用了flush方法或者是close方法后，内存缓冲区中编码为字节(数字)会写入到文件中读取时：使用read方法读取文件的时候，文建会先将存储在计算机中的二进制对照系统码表解码成相应的字符，读入程序图片不能用字符流的原因因为图片是字节文件，计算机中存储的也是字节数字，所以用字节流输入的时候不需要编码解码的过程，直接将计算机中的字节读取写入就可以了 但是用字符流读取的时候，一次读取两个字节，然后将这两个字节按照码表解码成相应的字符，当读取图片的时候，将两个字节拼在一起对比码表解码，码表中可能没有相应的字符，就会将此二进制数据标记为未知字符， 在写入的时候，会将未知字符丢掉，所以图片拷贝不成功 因为原图片和你拷贝的“图片”在计算机中的字节都是不一样的 拷贝的“图片”丢失了很多 **解码后**被标记为“未知字符”的**字节** 举个例子：一个图片在计算机中存储的字节是：-121，34，124，53，-65，-43，1.... 使用字节流读取的时候，一次读取一个字节，会原封不动的读取出来：-121，34，124，53，-65，-43，1.... 但是当使用字符流读取的时候，一次读两个字节-12134，12453....然后将每次读取到的两个字节对照系统码表解码成相应的字符，但是码表中可能没有相应的字符； 例如没有和-12134对应的字符，就会将此二进制数据标记为未知字符(假设标记为￥)； 在写入的时候，就会将￥字符给丢掉，所以**最后实际写入的数据为**124，53，-65，-43，1.... 这样拷贝自然就失败了关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接**最后**：字符流因为解码编码等原因，比字节流慢很多 字符流一般用于传输纯文本文件，尤其是中文文档，不能用于视频，图片等传输 图片等视频音频文件要用字节流]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>乱码</tag>
        <tag>字符流/字节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
