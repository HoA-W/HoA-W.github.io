<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BOM模型基础学习]]></title>
    <url>%2F2019%2F09%2F08%2FBOM%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[BOM，全称Browser Object Model，浏览器对象模型它将浏览器的各个组成部分封装成对象五个对象window-窗口对象Location-地址栏对象History-历史记录对象Screen-显示器屏幕对象Navigator-浏览器对象window-窗口对象该对象无需创建，可以直接使用对象的方法和属性 window对象的方法与弹出框有关的方法alert()显示带有一段消息和一个确认按钮的警告框。 confirm()显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法close()关闭浏览器窗口。 谁调用我 ，我关谁 open()打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式setTimeout()在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器clearTimeout()取消由 setTimeout() 方法设置的 timeout。setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()取消由 setInterval() 设置的 timeout。window对象的属性获取其他BOM对象historylocationNavigatorScreen获取DOM对象document Location-地址栏对象创建(获取)1. window.location 2. location方法reload() 重新加载当前文档。刷新 属性href 设置或返回完整的 URL。如图，给按钮设置监听器，点击按钮后修改页面的URL为百度页面，就会自动跳转到百度的页面 History-历史记录对象创建(获取)1. window.history 2. history方法back()加载 history 列表中的前一个 URL。 forward()加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性length返回当前窗口历史列表中的 URL 数量。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>BOM</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F09%2F08%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS和HTML结合方式内部样式在html文件内部定义一个script标签、在标签里面写的JS代码注意：和CSS不同的是，JS标签可以有很多个，而且可以写在HTML文件中的任意位置 外部样式在html文件内部定义一个script标签，通过script的src属性，来指定JS配置文件的路径 JS代码写在JS配置文件中 数据类型和变量JS数据类型和JAVA类似，分为**原始数据类型**和**引用数据类型**两大类数据类型number包括整数、小数和NaN类型(不是数字的数字类型 not a numebr) string字符/字符串类型 booleantrue/false、 null一个对象为空的占位符 undefined未定义，如果一个表量没有给初始化值，就会被默认赋值为 undefined ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828110402952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70)变量一小块存储数据的内存空间 JAVA是强类型语言，而JavaScript是弱类型语言强类型在开辟内存空间时，定义了空间将来存储数据的类型，只能存储固定的类型 弱类型在开辟内存空间时，没有定义空间将来存储数据的类型，可以存放任意类型的数据 运算符在JS中，如果运算数不是运算符要求的类型，那么JS会自动将运算数进行类型转换 例如：一元运算符+(正号)和-(负号)是对数字类型进行操作，但是有+&apos;a&apos;这样的运算，就会将字符串类型的&apos;a&apos;转换为number类型其他类型转numberstring--&gt;number：**按照字面值转换**，如果字面值是数字，如&apos;123&apos;，会转换成数字123， 如果字面值不是数字，如&apos;abc&apos;，会转换为NaN(不是数字的数字)注意：NaN和整数小数运算，还是NaN; boolean–&gt;number: true=1 false=0 比较运算符字符串按照字典顺序比较(如c&gt;b),按位逐一比较，直到得出大小 **类型不同比较，先进行类型转换** ”===“运算符：在比较之前先进行类型判断，如果类型不同，直接返回false逻辑运算符！：非运算其他类型转boolean number--&gt;boolean：0和NaN为false，其他都是true string--&gt;boolean：除了空字符串，都是true null/undefined--&gt;boolean：false 对象--&gt;boolean：true 注意：在JS中，所有的**变量都是关键字var**定义的，var可以省略，但是，**用var定义的是局部变量**，不用var定义的 是全局变量常用对象function对象 方法对象 Array对象数组对象 数组长度可变 Date对象 Math对象该对象不用创建，可以直接使用对象的方法和属性，Math.调用 常用方法和属性： Global对象 特点：是一个全局对象，这个对象中封装的方法不需要对象就能够直接使用,和Math不同的是，使用它的方法前面不 用加对象名 在说该对象的方法之前先说一下**URL编码**： 浏览器将从表单中收集的数据经过URL编码后发送给服务器，服务器再将接收到的URL编码的数据解码。 URL编码的规则：对于汉字，先将汉字按照GBK/UTF8编码成对应的二进制数字，再将每四位二进制数字组合在 一起转换成十六进制数字，这样就将汉字转换成了一串十六进制数字，最后，每两个十六进制数字一组，在前面 +%，这样就组成了URL编码，字母和数字不编码第二组方法编码的字符更多，会将网址中./等符号也用URL编码]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器和常用属性]]></title>
    <url>%2F2019%2F09%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基础选择器id选择器使用此选择器要求HTML相应的标签必须指定了id属性格式：#+标签id属性{ //对应id标签的属性 如color等}通过HTML标签的id来指定标签，修改样式元素选择器格式：标签名称{ //通过标签名称找到标签(可能不止一个)并修改内容样式 }这个元素选择器会找到HTML中所有的div标签，并将标签内容字体改为红色 类选择器 格式： .+类名{ 通过标签的class属性值找到标签 }其中：三个选择器中 id选择器优先级最高，元素选择器优先级最低 扩展选择器![在这里插入图片描述](https://img-blog.csdnimg.cn/20190828103900651.png) CSS常见属性 盒子模型 参见JAVA_WEB/HTML&amp;CSS]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础回顾]]></title>
    <url>%2F2019%2F09%2F08%2FHTML5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[HTML用于搭建基础页面，展示页面内容，一般和CSS以及JS搭配使用HTML标签分类# 1、围堵标签 顾名思义，就是开始和结束标签，例如&lt; html&gt; &lt; /html&gt;，内容放在标签中 # 2、自闭合标签 开始标签和结束标签在一起。例如换行标签&lt; br/&gt;、超链接标签&lt; a&gt;等 标签不区分大小写，建议小写无论是哪种标签，都可以在开始标签中定义属性，属性是由键值对组成，其中值需要由引(单/双)号引起来 &lt; html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt; /html&gt;文件标签&lt; html&gt;文档的根标签 &lt; head&gt;头标签，用于指定html文档的一些属性，引入外部资源，如CSS、JS文件等 &lt; title&gt; 标题标签 &lt; body&gt; 体标签，html代码写在body标签中 以上均为围堵标签 文本标签&lt; h1&gt;~&lt; h6&gt;标题标签，从h1到h6字体大小递减 –&gt;围堵标签 &lt; p&gt;段落标签：被该标签包裹的文本会换行两次 –&gt;围堵标签 &lt; br&gt;换行标签 &lt; hr&gt;展示一条水平线 该标签有一些属性：color、width、height、align(对齐方式)来设置水平线的样式 &lt; b&gt;字体加粗标签 &lt; i&gt;字体斜体标签以上四个均为自闭合标签 &lt; font&gt;字体标签 该标签属性：color、size、face(字体)来改变字体 center：文本居中标签 图片标签&lt; img&gt;图片标签，是一个自闭合标签，其中有src属性，可以指定展示图片的路径 相对路径： 其中如果html文件和图片所在文件夹目录是同一级目录，那么./+图片所在文件夹目录/图片 如果图片所在文件夹目录是html文件上一级目录，那么就用../ 列表标签&lt; ol&gt;/&lt; li&gt;有序列表 type属性：指定序号的样式 &lt; ul&gt;/&lt; li&gt;无序列表无序列表的type属性有三种： disc：原点 square：正方形点 circle：圆圈 链接标签&lt; a&gt;定义一个超链接 属性： href 指定访问资源的URL()统一资源定位符)，可以是网址 target 指定打开资源的方式，有两种方式 _ selt:在当前页面打开 _ blank：在新空白页面打开 和CSS以及JS搭配的标签 div标签和span标签，两者的区别是div自带换行，而span没有换行功能 表格标签&lt; table&gt; 定义表格，table的开始标签可以指定一些属性 width：表格宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 &lt; tr&gt;标签定义行标签 &lt; td&gt;标签定义单元格标签 &lt; th&gt;标签定义表头单元格标签 表单标签注意：表单中的数据要想被提交，必须指定其name属性 表单：用于采集用户输入的数据，用于和服务器进行交互 &lt; form&gt;用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围form标签有以下属性 action：指定提交数据的URL路径 method：指定提交方式，有两种比较常用，分别是post和get form只是制定了收集用户数据的范围，并没有指定提交形式(输入框、按钮、下拉列表…)因此就会用到表单项标签表单项标签主要有三种：input标签、select标签、textarea标签 &lt; input&gt;标签展示效果 &lt; select&gt;标签子元素：option，指定列表项展示效果 文本域标签主要有两个属性：cols：指定列数，每一行有多少个字符rows：默认多少行。]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码--Byte类]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%B0%8F%E7%99%BD%E5%AD%A6JDK%E6%BA%90%E7%A0%81--Byte%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[学习过程中参考此篇文章，写的很好1、观察它继承的父类，实现了那些接口 2、找到它的成员变量 3、学习构造方法 4、学习方法一、父类和接口从图中可以知道，Byte类继承了Number类，实现了Comparable接口对于Comparable接口，只有一个抽象方法这个接口赋予它和它的子类比较的能力，用于排序，比较大小对于一个存储自定义类的数组或集合，只有这个类实现了该接口，重写了接口中的compareTo()方法，重写了排序规则才能使用Arrays类的sort方法进行排序； 二、成员变量定义了Byte类型数据的边界值，就是说，Byte类型的值只能在-128~127之间TYPE是一个Byte的Class类对象，相当于TYPE=Byte.class；这就是Byte类型的基础类型，数据存储的地方(从下面的构造方法可以看出)这三个成员变量分别表示Byte数据的位数，字节数和UID(用于序列化和反序列化) 三、构造方法Byte的构造方法有两个，可以看出，两个构造方法都会将传入的数据存放到成员变量byte中 四、私有静态内部类![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171705760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM4NzQxMQ==,size_16,color_FFFFFF,t_70) 这是Byte类的一个静态内部类，类里面还有一个静态代码块 静态代码块会在类第一次被加载的时候执行，并且只执行一次 这里的作用就是，创建一个Byte类型的数组，数组的长度是256 里面存储着-128~127的数字(Byte类数据所有可能的取值) 并且数组是静态的并且final修饰， 因为后面的有些成员方法会需要用到Byte对象，所以这样做就避免了重复创建对象和回收对象五、成员方法1、toString(byte b)方法![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820171318100.png) 注意：这个toString()方法不是重写Object的toString方法，因为它有参数 作用：将一个byte类型数据转化为String字符串类型 实质上是直接调用Integer类的toString方法， radix：10：用10进制表示2、valueOf(byte b)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172235507.png) 作用：将基本类型--&gt;包装类型，直接从上面的数组中得到3、parseByte(String s,int radix) 参数： String s:要解析的字符串 int radix:指定字符串表示的进制 例如：s=“10000”，radix=2，解析出来的值就是16 作用： 将字符串按照指定进制解析为byte类型 实质上调用的是Integer的parseInt方法，解析成int类型 判断是否超出范围，超出范围就抛异常，否则就返回 4、parseByte(String s)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190820172742458.png) 不指定进制默认十进制解析5、valueOf(String s,int radix) 参数： String s:要转换的字符串 int radix：字符串表示的进制，和解析方法一样作用： 将字符串转换为按照指定进制形式表示的Byte类型，先将字符串解析为byte类型，在调用valueOf()方法，从静态代码块初始的数组中找到对应的Byte并返回 6、valueOf(String s)默认10进制7、xxxValue()方法重写父类的方法，由于byte数值最小，不用担心出现溢出 直接用强制类型转换，然后return8、hashCode()重写了父类的hashCode方法，对于Byte类型，它的hashCode方法实质上就是返回它的值 9、equals()方法 重写了父类的equals方法 10、compareTo()方法 重写了接口中的compareTo方法，直接返回两个对象的差值 调用方法的对象-方法的参数]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>Byte</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流和字节流]]></title>
    <url>%2F2019%2F09%2F07%2FJAVA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[深入理解字符流编码首先要理解字符流输入的原理：字符流输入其实底层也是字节流输入字符–&gt;计算机二进制数字（字节）：编码字节(计算机二进制数字)–&gt;字符：解码写入时：1、当使用字符流的write方法向文件写入数据的时候，数据会先写进内存缓冲区中， 2、内存缓冲区会先字符对比着系统码表编码(中文系统是GBK)为对应的字节：字符--&gt;数字 3、调用了flush方法或者是close方法后，内存缓冲区中编码为字节(数字)会写入到文件中 读取时：使用read方法读取文件的时候，文建会先将存储在计算机中的二进制对照系统码表解码成相应的字符，读入程序图片不能用字符流的原因因为图片是字节文件，计算机中存储的也是字节数字，所以用字节流输入的时候不需要编码解码的过程，直接将计算机中的字节读取写入就可以了 但是用字符流读取的时候，一次读取两个字节，然后将这两个字节按照码表解码成相应的字符，当读取图片的时候，将两个字节拼在一起对比码表解码，码表中可能没有相应的字符，就会将此二进制数据标记为未知字符， 在写入的时候，会将未知字符丢掉，所以图片拷贝不成功 因为原图片和你拷贝的“图片”在计算机中的字节都是不一样的 拷贝的“图片”丢失了很多 **解码后**被标记为“未知字符”的**字节** 举个例子：一个图片在计算机中存储的字节是：-121，34，124，53，-65，-43，1.... 使用字节流读取的时候，一次读取一个字节，会原封不动的读取出来：-121，34，124，53，-65，-43，1.... 但是当使用字符流读取的时候，一次读两个字节-12134，12453....然后将每次读取到的两个字节对照系统码表解码成相应的字符，但是码表中可能没有相应的字符； 例如没有和-12134对应的字符，就会将此二进制数据标记为未知字符(假设标记为￥)； 在写入的时候，就会将￥字符给丢掉，所以**最后实际写入的数据为**124，53，-65，-43，1.... 这样拷贝自然就失败了关于写入字符到文件中，打开文件查看乱码的原因，参考上面链接**最后**：字符流因为解码编码等原因，比字节流慢很多 字符流一般用于传输纯文本文件，尤其是中文文档，不能用于视频，图片等传输 图片等视频音频文件要用字节流]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>乱码</tag>
        <tag>字符流/字节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树镜像对称]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC101%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度–简单题目分析： 通过题目可以知道，这个树镜像对称，那么这棵树关于根节点这条线对称 就是说，将它所有的左子树变成右子树，所有右子树变成左子树，它是不变的递归//这里直接传递tree根节点的左右子树会比pre(TreeNode tree,TreeNode tree)好，因为减少一层递归，LeetCode速度直接 //快1ms，亲测 1、pre(TreeNode tree.left,TreeNode tree.right) 2、如果A.val==B.val --&gt;return true 3、如果A==null&amp;&amp;B==null --&gt;return true 4、如果A和B不同时为空，说明树是不对称的 --&gt;return false 5、遍历A的左子树和B的右子树 //pre(A.left,B.right) 6、遍历A的右子树和A的左子树 //pre(A.right,B.left) 迭代法使用队列，比较容易理解，直接上代码(LeetCode官方题解)]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F09%2F07%2FLeetCode-%E7%AC%AC70%E9%A2%98%2F</url>
    <content type="text"><![CDATA[难度： 简单1、动态规划可以知道，如果要到达第n阶台阶，有两种方式：第一：从n-1阶台阶跨1步第二：从n-2阶台阶跨2步设到达第n阶台阶的方法总数为sum(n)那么由上面可以知道：sum(n)=sum(n-2)+sum(n-1)可以举例假设一下假设n等于3，那么到达第3阶台阶由两种方法1、从第1阶台阶跨2步上去2、从第2阶跨1步上去 相应的，到达第1阶台阶只有一种方法，sum(1)=1；到达第2阶台阶也有两种方法：从起始位置跨2步，和先跨1步再跨1步，sum(2)=2；所以sum(3)=3; 2、斐波那契数列通过观察规律可以知道：假设第0阶为1；那么可以得到从第1阶往后分别是：1，2，3，5，8，13…..这是一个很明显的斐波那契数列 3、递归同样的思路，爬第n阶台阶的方法和等于爬上第n-1阶台阶和爬上第n-2阶台阶方法之和递归出口：n=0的时候返回1，n&lt;0的时候返回0；运行到44个样例的时候栈爆了…..]]></content>
      <categories>
        <category>算法之美</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
